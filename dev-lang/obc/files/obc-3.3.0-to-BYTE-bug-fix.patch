diff --git a/.hgignore b/.hgignore
index 8d552c8..2df7524 100644
--- a/.hgignore
+++ b/.hgignore
@@ -244,3 +244,5 @@ lablgtk3/sourceView3_tags.c
 lablgtk3/sourceView3_tags.h
 lablgtk3/varcc
 lablgtk3/sys_compat.ml
+lablgtk3/lablgen/propcc
+lablgtk3/lablgen/varcc
diff --git a/Makefile.in b/Makefile.in
index 2686ad0..c143e2d 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -381,14 +381,14 @@ force:
 
 # Automatic reconfiguration
 
-$(srcdir)/configure: configure.in aclocal.m4
+$(srcdir)/configure: configure.ac aclocal.m4
 	cd $(srcdir) && $(AUTOCONF)
 
 config.status: configure
 	./config.status --recheck
 
 $(srcdir)/config.h.in: stamp-h.in
-$(srcdir)/stamp-h.in: configure.in aclocal.m4
+$(srcdir)/stamp-h.in: configure.ac aclocal.m4
 	cd $(srcdir) && $(AUTOHEADER)
 	echo timestamp >$(srcdir)/stamp-h.in
 
diff --git a/aclocal.m4 b/aclocal.m4
index 26895e2..d27d51e 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -34,8 +34,9 @@ dnl
 dnl See if indexed jumps will compile
 AC_DEFUN(AC_C_INDEXED_JUMPS,
   [AC_CACHE_CHECK(for indexed jumps, ac_cv_c_indexed_jumps,
-      [AC_TRY_COMPILE(, [void *a[] = { &&b, &&c }; b: goto *a[1]; c:;],
-        ac_cv_c_indexed_jumps=yes, ac_cv_c_indexed_jumps=no)])
+      [AC_COMPILE_IFELSE(
+        [AC_LANG_PROGRAM(,[[void *a[] = { &&b, &&c }; b: goto *a[1]; c:;]])],
+        [ac_cv_c_indexed_jumps=yes], [ac_cv_c_indexed_jumps=no])])
     if test $ac_cv_c_indexed_jumps = yes; then
       AC_DEFINE(HAVE_INDEXED_JUMPS, 1, 
         [Define if indexed jumps work.])
@@ -44,8 +45,9 @@ AC_DEFUN(AC_C_INDEXED_JUMPS,
 dnl See if the C compiler understands __attribute__ ((unused))
 AC_DEFUN(AC_C_UNUSED,
   [AC_CACHE_CHECK(for 'unused' attribute, ac_cv_unused_attr,
-      [AC_TRY_COMPILE(, [int __attribute__ ((unused)) n],
-	ac_cv_unused_attr=yes, ac_cv_unused_attr=no)])
+      [AC_COMPILE_IFELSE(
+        [AC_LANG_SOURCE([[int __attribute__ ((unused)) n;]])],
+	[ac_cv_unused_attr=yes], [ac_cv_unused_attr=no])])
     if test $ac_cv_unused_attr = yes; then 
       UNUSED="__attribute__ ((unused))"
     fi
@@ -54,8 +56,9 @@ AC_DEFUN(AC_C_UNUSED,
 dnl See if the C compiler understands __attribute__ ((used))
 AC_DEFUN(AC_C_USED,
   [AC_CACHE_CHECK(for 'used' attribute, ac_cv_used_attr,
-      [AC_TRY_COMPILE(, [int __attribute__ ((used)) n],
-	ac_cv_used_attr=yes, ac_cv_used_attr=no)])
+      [AC_COMPILE_IFELSE(
+        [AC_LANG_SOURCE([[int __attribute__ ((used)) n;]])],
+	[ac_cv_used_attr=yes], [ac_cv_used_attr=no])])
     if test $ac_cv_used_attr = yes; then 
       USED="__attribute__ ((used))"
     fi
@@ -77,7 +80,7 @@ AC_DEFUN(AC_C_NORETURN,
 dnl test if C compiler understands -rdynamic
 AC_DEFUN(AC_TEST_RDYNAMIC,
   [AC_CACHE_CHECK(if ${CC-cc} understands -rdynamic, ac_cv_rdynamic,
-    [echo 'main() { return 0; }' >conftest.c
+    [echo 'int main() { return 0; }' >conftest.c
       if AC_TRY_COMMAND(${CC-cc} $CFLAGS -o conftest${ac_exeext} -rdynamic
 						conftest.c 2>conftest.err) \
 			&& ! grep -q 'unrecognized option' conftest.err 
@@ -89,7 +92,7 @@ dnl Find the page size (check sys/param.h if this doesn't work)
 AC_DEFUN(AC_FIND_PAGESIZE,
   [AC_CHECK_FUNCS(getpagesize)
     AC_CACHE_CHECK(page size, ac_cv_pagesize,
-      [AC_TRY_RUN([#include <stdio.h>
+      [AC_RUN_IFELSE([AC_LANG_SOURCE([[#include <stdio.h>
 	#ifndef HAVE_GETPAGESIZE
 	#ifdef HAVE_UNISTD_H
 	#include <unistd.h>
@@ -98,13 +101,14 @@ AC_DEFUN(AC_FIND_PAGESIZE,
 	#define getpagesize() sysconf(_SC_PAGESIZE)
 	#endif
 	#endif
-	main() {
+	int main() {
 	  FILE *f = fopen("conftestval", "w");
 	  if (f == NULL) exit(1);
 	  /* No newline here, in case a CRLF creeps in and cygwin chokes */
 	  fprintf(f, "%d", getpagesize());
 	  exit(0);
-	}], ac_cv_pagesize=`cat conftestval`, ac_cv_pagesize=4096)])
+	}]])], [ac_cv_pagesize=`cat conftestval`],
+	[ac_cv_pagesize=4096], [ac_cv_pagesize=4096])])
     AC_DEFINE_UNQUOTED(PAGESIZE, $ac_cv_pagesize, [Page size])
     AC_SUBST(PAGESIZE, $ac_cv_pagesize)
 
diff --git a/compiler/Makefile.in b/compiler/Makefile.in
index cc8e173..3da38c6 100644
--- a/compiler/Makefile.in
+++ b/compiler/Makefile.in
@@ -31,8 +31,8 @@
 #
 
 # Config stuff
-OCAMLC = ocamlc
-OCAMLLEX = ocamllex
+OCAMLC = @OCAMLC@
+OCAMLLEX = @OCAMLLEX@
 MYACC = ../yacc/myacc
 CAMLDEP = @top_srcdir@/camldep
 MLFLAGS = @MLFLAGS@
diff --git a/compiler/peepopt.ml b/compiler/peepopt.ml
index b06ebe9..24f40b0 100644
--- a/compiler/peepopt.ml
+++ b/compiler/peepopt.ml
@@ -255,7 +255,7 @@ let simple =
 
 let width =
   function
-       CharT | BoolT | SysByteT -> 1 
+       CharT | BoolT | ByteT | SysByteT -> 1 
      | ShortT -> 2
      | IntT | FloatT | PtrT -> 4
      | LongT | LongPtrT | DoubleT -> 8
diff --git a/configure.ac b/configure.ac
new file mode 100644
index 0000000..8a8ae4b
--- /dev/null
+++ b/configure.ac
@@ -0,0 +1,401 @@
+#
+# configure.in
+# 
+# This file is part of the Oxford Oberon-2 compiler
+# Copyright (c) 2006--2016 J. M. Spivey
+# All rights reserved
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met: 
+#
+# 1. Redistributions of source code must retain the above copyright
+#    notice, this list of conditions and the following disclaimer.
+# 2. Redistributions in binary form must reproduce the above
+#    copyright notice, this list of conditions and the following
+#    disclaimer in the documentation and/or other materials provided
+#    with the distribution. 
+# 3. The name of the author may not be used to endorse or promote products
+#    derived from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+# Process this file with autoconf to produce a configure script.
+
+AC_INIT(obc, 3.3.0, mike@cs.ox.ac.uk or http://github.com/Spivoxity/obc-3/issues)
+AC_PREREQ(2.50)
+AC_CONFIG_SRCDIR(compiler/tree.mli)
+AC_CONFIG_AUX_DIR(scripts)
+AC_CONFIG_FILES(Makefile compiler/Makefile runtime/Makefile lib/Makefile \
+	test/Makefile winport/Makefile debugger/Makefile \
+	lablgtk3/Makefile macport/Makefile mllib/Makefile \
+        yacc/Makefile thunder/Makefile)
+AC_CONFIG_FILES(compiler/config.ml debugger/debconf.ml)
+AC_CONFIG_FILES(test/regress, chmod +x test/regress)
+AC_CONFIG_FILES(test/bigtest, chmod +x test/bigtest)
+AC_CONFIG_FILES(test/edtest, chmod +x test/edtest)
+AC_CONFIG_HEADERS(config.h)
+
+: ${AUTOCONF=autoconf} ${AUTOHEADER=autoheader}
+AC_SUBST(AUTOCONF)
+AC_SUBST(AUTOHEADER)
+AC_SUBST(DEPEND, 1)
+
+# Version info
+MAGIC=OBCX
+AC_DEFINE_UNQUOTED(MAGIC, "$MAGIC", [Magic number for trailer])
+SIG=[`echo $PACKAGE_VERSION | sed -e 's/alpha/.90/' \
+        -e 's/beta\([1-9]\)/.9\1/' -e 's/[0-9]*/0&/g' \
+	-e 's/0\([0-9][0-9]\)/\1/' -e 's/\.//g' -e 's/^/0x00/'`]
+AC_DEFINE_UNQUOTED(SIG, $SIG, [Version signature for symbol tables])
+AC_SUBST(SIG)
+DOS_VERSION=`echo $PACKAGE_VERSION | sed 's/\./-/g'`
+
+ABS_SRCDIR=`cd $srcdir; pwd`
+ABS_BINDIR=`pwd`
+AC_SUBST(ABS_SRCDIR)
+AC_SUBST(ABS_BINDIR)
+
+# Host dependent setup
+AC_CANONICAL_HOST
+
+AC_ARG_ENABLE(m64x32,
+  AS_HELP_STRING([--disable-m64x32], [disable 64-bit runtime for amd64]))
+
+DIRSEP="/"
+LD=ld
+
+case $host in
+  *-*-linux-*)
+    AC_DEFINE(LINUX, 1, [Define for Linux]);;
+
+  *-*-mingw*|*-*-cygwin)
+    AC_SUBST(WINDOWS, 1)
+    AC_DEFINE(WINDOWS, 1, [Define to enable hacks for Windows])
+    DIRSEP="\\\\";;
+
+  *-*-darwin*)
+    AC_SUBST(MACOS, 1)
+    AC_DEFINE(MACOS, 1, [Define to enable hacks for MacOS X]);;
+
+  *-*-freebsd*)
+    AC_SUBST(FREEBSD, 1)
+    AC_DEFINE(FREEBSD, 1, [Define to enable hacks for FreeBSD]);;
+esac    
+
+AC_DEFINE_UNQUOTED(DIRSEP, "$DIRSEP", [Directory separator in file names])
+
+case $host in
+  x86_64-*)
+    if test "$enable_m64x32" != no; then
+      AC_DEFINE(M64X32, 1, [Define for 64-bit runtime with 32-bit pointers])
+      AC_DEFINE(USE_SSE, 1, [Define to use SSE2 in place of x87 floats])
+    fi
+    # Architecture for windows installation
+    AC_SUBST(WIN_ARCH, x64);;
+esac
+
+case $host in
+  i686-*|x86_64-*)
+    AC_DEFINE(UNALIGNED_MEM, 1, [Define if unaligned loads and stores work]);;
+esac
+
+case $host in
+  x86_64-*-linux-*)
+    if test "$enable_m64x32" = no; then
+      CC='gcc -std=gnu99 -m32'; LD='ld -melf_i386'
+    fi;;
+
+  x86_64-*-mingw*|*-*-cygwin) 
+    WIN=win64
+    AC_SUBST(ROOT, C:/msys64)
+    AC_SUBST(GTKROOT, C:/msys64/mingw64)
+    AC_SUBST(PKG_FLAGS, --define-variable=prefix=C:/msys64/mingw64)
+    AC_SUBST(CFLAGS_JIT, [-Wl,--stack,16777216])
+    if test "$enable_m64x32" = no; then
+      CC='gcc32 -std=gnu99'; LD=ld32
+    fi;;
+    
+  i686-*-mingw*|*-*-cygwin) 
+    AC_SUBST(ROOT, C:/msys32)
+    AC_SUBST(GTKROOT, C:/msys32/mingw32)
+    AC_SUBST(PKG_FLAGS, --define-variable=prefix=C:/msys32/mingw32)
+    WIN=win32
+    AC_SUBST(CFLAGS_JIT, [-Wl,--stack,4194304]);;
+    
+  x86_64-*-darwin*)
+    if test "$enable_m64x32" = no; then
+      CC='gcc -std=gnu99 -m32'
+    fi;;
+esac
+
+AC_SUBST(WIN_INSTALL, obc-$WIN-$DOS_VERSION)
+AC_SUBST(LD)
+
+AC_ARG_ENABLE(segmem,
+  AS_HELP_STRING([--enable-segmem], [use segmented addressing]))
+if test "$enable_segmem" = yes; then
+  AC_DEFINE(SEGMEM, 1, [Define to use segmented addressing])
+fi
+
+GTKPKGS="gtk+-3.0 gtksourceview-3.0"
+
+if test "$MACOS" = 1; then GTKPKGS="$GTKPKGS gtk-mac-integration-gtk3"; fi
+AC_SUBST(GTKPKGS)
+
+# Checks for programs
+AC_PROG_CC
+AC_PROG_INSTALL
+AC_PROG_MAKE_SET
+AC_PROG_RANLIB
+
+AC_CHECK_PROGS(OCAMLC, ocamlc)
+test -z "$OCAMLC" && AC_MSG_FAILURE(ocamlc not found)
+
+AC_CHECK_PROGS(OCAMLLEX, ocamllex)
+test -z "$OCAMLLEX" && AC_MSG_FAILURE(ocamllex not found)
+
+AC_CHECK_PROGS(TCLSH, tclsh)
+test -z "$TCLSH" && AC_MSG_FAILURE(tclsh not found)
+
+AC_CHECK_PROGS(DIFF, gdiff diff)
+test -z "$DIFF" && AC_MSG_FAILURE(diff not found)
+
+: ${GTKDIR=/usr}
+AC_ARG_VAR(GTKDIR, [Directory to find GTK])
+AC_PATH_PROG(PKG_CONFIG, pkg-config, /usr/bin/pkg-config, 
+  $GTKDIR/bin$PATH_SEPARATOR$PATH)
+test "$PKG_CONFIG" != "" || AC_MSG_ERROR(pkg-config not found)
+
+# Disable fancy alias analysis if compiling with gcc
+: ${RTFLAGS='${CFLAGS}'}
+if test "$GCC" == yes; then
+    RTFLAGS="$RTFLAGS -fno-strict-aliasing"
+fi
+AC_SUBST(RTFLAGS)
+
+# Checks for typedefs, structures, and compiler characteristics.
+AC_C_CONST
+AC_C_BIGENDIAN
+AC_C_INLINE
+AC_C_INDEXED_JUMPS
+AC_C_UNUSED
+AC_C_USED
+AC_C_NORETURN
+AC_FIND_PAGESIZE
+
+# Checks for header files.
+AC_CHECK_HEADERS(time.h sys/time.h)
+
+# Checks for library functions.
+AC_FUNC_VPRINTF
+AC_CHECK_FUNCS(clock time gettimeofday strtoul stpcpy)
+AC_CHECK_FUNCS(mmap sigprocmask) # assume they work OK for our purposes
+AC_CHECK_FUNCS(getopt_long_only)
+AC_CHECK_LIB(m, sinf, MATHLIB=-lm)
+AC_SUBST(MATHLIB)
+
+# Checks for X
+AC_PATH_XTRA
+if test "$no_x" != yes; then
+  AC_SUBST(HAVE_X, 1)
+  AC_SUBST(XYPLANE, XYplane)
+  AC_SUBST(XLIB, "$X_LIBS -lX11")
+fi
+
+# OCaml stuff
+AC_ARG_VAR(MLFLAGS, [Flags to pass to ocamlc])
+if test "$WINDOWS" = 1; then
+  AC_SUBST(MLLINKFLAGS, "-ccopt -L/lib/mingw")
+fi
+
+# Check ocaml version
+AS_ECHO_N("checking ocaml version...")
+OCAMLV=`$OCAMLC -v | sed -n '1s/.*version \([[0-9]]*\.[[0-9]]*\).*/\1/p'`
+AS_ECHO(" $OCAMLV")
+TMPV=`echo $OCAMLV | \
+    sed -e 's/\./\.0000/' -e 's/\.0*\([[0-9]][[0-9]][[0-9]][[0-9]]\)/\1/'`
+if test $TMPV -lt 40002; then
+    AC_SUBST(COMPAT, bytes.cmo)
+fi
+if test $TMPV -lt 40006; then
+    AC_SUBST(SYS_COMPAT, sys_compat1.ml.in)
+else
+    AC_SUBST(SYS_COMPAT, sys_compat2.ml.in)
+fi
+if test $TMPV -ge 50000; then
+    AC_SUBST(LIBDIRS, 1)
+fi
+
+
+# PACKAGE OPTIONS
+
+# Option debug
+AC_ARG_ENABLE(debug,
+  AS_HELP_STRING([--enable-debug], [set up for debugging]),
+  if test "$enable_debug" = yes; then 
+    DEBUG=1
+    AC_DEFINE(DEBUG, 1, [Define to set up for debugging]) 
+    : ${MLFLAGS=-g}
+  fi)
+AC_SUBST(DEBUG)
+
+# Option dynlink
+AC_ARG_ENABLE(dynlink,
+  AS_HELP_STRING([--disable-dynlink], [do not use dynamic linking]))
+if test "$enable_dynlink" != no && test "$WINDOWS" != 1; then
+  DYNLINK=1
+  AC_DEFINE(DYNLINK, 1, [Define if dynamic linking enabled])
+  AC_SEARCH_LIBS(dlopen, dl)
+  AC_TEST_RDYNAMIC(DLFLAGS="-rdynamic")
+fi
+AC_SUBST(DYNLINK)
+AC_SUBST(DLFLAGS)
+
+case $host in
+  *-*-darwin*) 
+    SHL_CFLAGS="-fPIC -bundle -undefined dynamic_lookup";;
+  *)           
+    SHL_CFLAGS="-fPIC"; SHL_LFLAGS="-shared";;
+esac
+AC_SUBST(SHL_CFLAGS)
+AC_SUBST(SHL_LFLAGS)
+AC_SUBST(DLEXT, [.so])
+AC_DEFINE_UNQUOTED(DLEXT, "$DLEXT", [Extension for dynamic libraries])
+
+# Option ffi
+AC_ARG_ENABLE(ffi,
+  AS_HELP_STRING([--disable-ffi], [do not use FFI with dynlink]))
+AC_CHECK_HEADERS(ffi.h, HAVE_FFI_H=1)
+if test "$enable_ffi" != no && test "$DYNLINK" = 1 \
+    && test "$HAVE_FFI_H" = 1; then
+  AC_DEFINE(USE_FFI, 1, [Define if FFI enabled])
+  AC_SEARCH_LIBS(ffi_call, ffi)
+fi
+
+# Option gc
+AC_ARG_ENABLE(gc,
+  AS_HELP_STRING([--enable-gc=option],
+    [Use 'yes' for Oberon GC, 'boehm' for Boehm library]))
+if test "$enable_gc" = boehm; then
+  GC_OBJ=gc0.o; GC_LIB=-lgc
+  AC_DEFINE(USE_BOEHM, 1, [Define to use Boehm garbage collector])
+elif test "$enable_gc" != no; then
+  GC_OBJ=gc.o; GC_LIB=
+else
+  GC_OBJ=gc0.o; GC_LIB=
+fi
+AC_SUBST(GC_OBJ)
+AC_SUBST(GC_LIB)
+
+# Option jit
+CODEPAGE=16384
+FLOATOPS=1
+AC_ARG_ENABLE(jit,
+  AS_HELP_STRING([--disable-jit], [disable JIT translator]))
+if test "$enable_segmem" == yes; then enable_jit=no; fi
+if test "$enable_jit" != no; then
+  case $host in
+    i?86-*) 
+      ENABLE_JIT=1; VM=vm386.o
+      AC_DEFINE(NEED_FPINIT, 1, [Reboot FPU for each primitive]);;
+    x86_64-*) 
+      ENABLE_JIT=1; VM=vm386.o;;
+    armv6l-*|armv7l-*|arm-*)
+      ENABLE_JIT=1; VM=vmpi.o; CODEPAGE=4096
+      AC_DEFINE(USE_FLUSH, 1, [Whether to flush the cache]);;
+    mipsel-*)
+      ENABLE_JIT=1; VM=vmomega.o; FLOATOPS=0
+      AC_DEFINE(USE_FLUSH, 1);;
+  esac
+fi
+AC_ARG_ENABLE(floatops,
+  AS_HELP_STRING([--disable-floatops], [disable JIT for floating point]))
+if test "$enable_floatops" = no; then FLOATOPS=0; fi
+AC_SUBST(VM)
+AC_SUBST(ENABLE_JIT)
+AC_DEFINE_UNQUOTED([CODEPAGE], $CODEPAGE, [Size of block for JIT code])
+if test $FLOATOPS = 1; then
+  AC_DEFINE(FLOATOPS, 1, [Whether to use thunder for floating point])
+fi
+
+# Option debugger
+AC_ARG_ENABLE(debugger,
+  AS_HELP_STRING([--disable-debugger], [disable runtime debugger]))
+if test "$enable_debugger" != no; then 
+  AC_SUBST(ENABLE_DEBUGGER, 1)
+fi
+if test "$enable_debugger" = inet || test "$WINDOWS" = 1; then 
+  AC_SUBST(USE_INET, 1)
+  AC_DEFINE(USE_INET, 1, [Whether to use inet sockets for the debugger])
+fi
+
+OBDB1='"$LIBDIR/obdb1 -R $LIBDIR/resources"'
+OBDB1_DEBUG='"$BINDIR/debugger/obdb1 -R $ROOT$TOPDIR/resources"'
+if test "$MACOS" = 1; then
+  OBDB1='"$LIBDIR/Obdb.app/Contents/MacOS/obdb"'
+  OBDB1_DEBUG='"$BINDIR/macport/Obdb.app/Contents/MacOS/obdb"'
+fi
+AC_SUBST(OBDB1)
+AC_SUBST(OBDB1_DEBUG)   
+
+# GTK setup for debugger
+MONOFONT="Monospace 10"
+SANSFONT="Sans 10"
+if test "$MACOS" = 1; then
+  MONOFONT="Monospace 14"
+  SANSFONT="Lucida Grande 14"
+fi
+AC_SUBST(MONOFONT)
+AC_SUBST(SANSFONT)
+AC_SUBST(RESOURCES, "blank.png breakpoint.png continue.png here.png \
+oberon.lang pause.png sober.xml stepinto.png stepout.png stepover.png \
+restart.png exit.png")
+
+if test "$WINDOWS" = 1; then
+  DEB_LIBS="$LIBS -lws2_32"
+else
+  BASE_LIBS=$LIBS
+  if test "$ENABLE_DEBUGGER" = 1; then
+      AC_SEARCH_LIBS(connect, socket)
+  fi
+  DEB_LIBS=$LIBS
+  LIBS=$BASE_LIBS
+fi
+AC_SUBST(DEB_LIBS)
+
+
+# Module list
+
+# Standard modules
+AC_SUBST(STDMODS, "Files Conv In Out Err Args Bit Timer \
+Strings Random Math MathL")
+
+AC_SUBST(STDMODS_B, "Files Conv In-b Out Err Args Bit Timer \
+Strings-b Random-b Math MathL")
+
+# Modules that contain runtime checks -- recompile with -b
+AC_SUBST(CHECKMODS, "In Random Strings")
+
+# Modules containing C code
+AC_SUBST(PRIMMODS, "Args Timer Files Conv Random")
+
+# Modules with primitives in separate shared libraries:
+AC_SUBST(SHLMODS, "$XYPLANE")
+
+# All library modules
+AC_SUBST(ALLMODS, "$STDMODS $SHLMODS")
+
+# The endgame
+AC_OUTPUT
diff --git a/configure.in b/configure.in
deleted file mode 100644
index ef37a43..0000000
--- a/configure.in
+++ /dev/null
@@ -1,400 +0,0 @@
-#
-# configure.in
-# 
-# This file is part of the Oxford Oberon-2 compiler
-# Copyright (c) 2006--2016 J. M. Spivey
-# All rights reserved
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions
-# are met: 
-#
-# 1. Redistributions of source code must retain the above copyright
-#    notice, this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above
-#    copyright notice, this list of conditions and the following
-#    disclaimer in the documentation and/or other materials provided
-#    with the distribution. 
-# 3. The name of the author may not be used to endorse or promote products
-#    derived from this software without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
-# OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
-# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
-# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-
-# Process this file with autoconf to produce a configure script.
-
-AC_INIT(obc, 3.3.0, mike@cs.ox.ac.uk or http://github.com/Spivoxity/obc-3/issues)
-AC_PREREQ(2.50)
-AC_CONFIG_SRCDIR(compiler/tree.mli)
-AC_CONFIG_AUX_DIR(scripts)
-AC_CONFIG_FILES(Makefile compiler/Makefile runtime/Makefile lib/Makefile \
-	test/Makefile winport/Makefile debugger/Makefile \
-	lablgtk3/Makefile macport/Makefile mllib/Makefile \
-        yacc/Makefile thunder/Makefile)
-AC_CONFIG_FILES(compiler/config.ml debugger/debconf.ml)
-AC_CONFIG_FILES(test/regress, chmod +x test/regress)
-AC_CONFIG_FILES(test/bigtest, chmod +x test/bigtest)
-AC_CONFIG_FILES(test/edtest, chmod +x test/edtest)
-AC_CONFIG_HEADERS(config.h)
-
-: ${AUTOCONF=autoconf} ${AUTOHEADER=autoheader}
-AC_SUBST(AUTOCONF)
-AC_SUBST(AUTOHEADER)
-AC_SUBST(DEPEND, 1)
-
-# Version info
-MAGIC=OBCX
-AC_DEFINE_UNQUOTED(MAGIC, "$MAGIC", [Magic number for trailer])
-SIG=[`echo $PACKAGE_VERSION | sed -e 's/alpha/.90/' \
-        -e 's/beta\([1-9]\)/.9\1/' -e 's/[0-9]*/0&/g' \
-	-e 's/0\([0-9][0-9]\)/\1/' -e 's/\.//g' -e 's/^/0x00/'`]
-AC_DEFINE_UNQUOTED(SIG, $SIG, [Version signature for symbol tables])
-AC_SUBST(SIG)
-DOS_VERSION=`echo $PACKAGE_VERSION | sed 's/\./-/g'`
-
-ABS_SRCDIR=`cd $srcdir; pwd`
-ABS_BINDIR=`pwd`
-AC_SUBST(ABS_SRCDIR)
-AC_SUBST(ABS_BINDIR)
-
-# Host dependent setup
-AC_CANONICAL_HOST
-
-AC_ARG_ENABLE(m64x32,
-  AS_HELP_STRING([--disable-m64x32], [disable 64-bit runtime for amd64]))
-
-DIRSEP="/"
-: ${CC:='gcc -std=gnu99'}
-LD=ld
-
-case $host in
-  *-*-linux-*)
-    AC_DEFINE(LINUX, 1, [Define for Linux]);;
-
-  *-*-mingw*|*-*-cygwin)
-    AC_SUBST(WINDOWS, 1)
-    AC_DEFINE(WINDOWS, 1, [Define to enable hacks for Windows])
-    DIRSEP="\\\\";;
-
-  *-*-darwin*)
-    AC_SUBST(MACOS, 1)
-    AC_DEFINE(MACOS, 1, [Define to enable hacks for MacOS X]);;
-
-  *-*-freebsd*)
-    AC_SUBST(FREEBSD, 1)
-    AC_DEFINE(FREEBSD, 1, [Define to enable hacks for FreeBSD]);;
-esac    
-
-AC_DEFINE_UNQUOTED(DIRSEP, "$DIRSEP", [Directory separator in file names])
-
-case $host in
-  x86_64-*)
-    if test "$enable_m64x32" != no; then
-      AC_DEFINE(M64X32, 1, [Define for 64-bit runtime with 32-bit pointers])
-      AC_DEFINE(USE_SSE, 1, [Define to use SSE2 in place of x87 floats])
-    fi
-    # Architecture for windows installation
-    AC_SUBST(WIN_ARCH, x64);;
-esac
-
-case $host in
-  i686-*|x86_64-*)
-    AC_DEFINE(UNALIGNED_MEM, 1, [Define if unaligned loads and stores work]);;
-esac
-
-case $host in
-  x86_64-*-linux-*)
-    if test "$enable_m64x32" = no; then
-      CC='gcc -std=gnu99 -m32'; LD='ld -melf_i386'
-    fi;;
-
-  x86_64-*-mingw*|*-*-cygwin) 
-    WIN=win64
-    AC_SUBST(ROOT, C:/msys64)
-    AC_SUBST(GTKROOT, C:/msys64/mingw64)
-    AC_SUBST(PKG_FLAGS, --define-variable=prefix=C:/msys64/mingw64)
-    AC_SUBST(CFLAGS_JIT, [-Wl,--stack,16777216])
-    if test "$enable_m64x32" = no; then
-      CC='gcc32 -std=gnu99'; LD=ld32
-    fi;;
-    
-  i686-*-mingw*|*-*-cygwin) 
-    AC_SUBST(ROOT, C:/msys32)
-    AC_SUBST(GTKROOT, C:/msys32/mingw32)
-    AC_SUBST(PKG_FLAGS, --define-variable=prefix=C:/msys32/mingw32)
-    WIN=win32
-    AC_SUBST(CFLAGS_JIT, [-Wl,--stack,4194304]);;
-    
-  x86_64-*-darwin*)
-    if test "$enable_m64x32" = no; then
-      CC='gcc -std=gnu99 -m32'
-    fi;;
-esac
-
-AC_SUBST(WIN_INSTALL, obc-$WIN-$DOS_VERSION)
-AC_SUBST(LD)
-
-AC_ARG_ENABLE(segmem,
-  AS_HELP_STRING([--enable-segmem], [use segmented addressing]))
-if test "$enable_segmem" = yes; then
-  AC_DEFINE(SEGMEM, 1, [Define to use segmented addressing])
-fi
-
-GTKPKGS="gtk+-3.0 gtksourceview-3.0"
-
-if test "$MACOS" = 1; then GTKPKGS="$GTKPKGS gtk-mac-integration"; fi
-AC_SUBST(GTKPKGS)
-
-# Checks for programs
-AC_PROG_CC
-AC_PROG_INSTALL
-AC_PROG_MAKE_SET
-AC_PROG_RANLIB
-
-AC_CHECK_PROGS(TCLSH, tclsh)
-test "$TCLSH" != "" || AC_MSG_ERROR(tclsh not found)
-
-AC_CHECK_PROGS(DIFF, gdiff diff)
-test "$DIFF" != "" || AC_MSG_ERROR(diff not found)
-
-: ${GTKDIR=/usr}
-AC_ARG_VAR(GTKDIR, [Directory to find GTK])
-AC_PATH_PROG(PKG_CONFIG, pkg-config, /usr/bin/pkg-config, 
-  $GTKDIR/bin$PATH_SEPARATOR$PATH)
-test "$PKG_CONFIG" != "" || AC_MSG_ERROR(pkg-config not found)
-
-# Disable fancy alias analysis if compiling with gcc
-: ${RTFLAGS='${CFLAGS}'}
-if test "$GCC" == yes; then
-    RTFLAGS="$RTFLAGS -fno-strict-aliasing"
-fi
-AC_SUBST(RTFLAGS)
-
-# Checks for typedefs, structures, and compiler characteristics.
-AC_C_CONST
-AC_C_BIGENDIAN
-AC_C_INLINE
-AC_C_INDEXED_JUMPS
-AC_C_UNUSED
-AC_C_USED
-AC_C_NORETURN
-AC_FIND_PAGESIZE
-
-# Checks for header files.
-AC_HEADER_STDC
-AC_CHECK_HEADERS(time.h sys/time.h)
-
-# Checks for library functions.
-AC_FUNC_VPRINTF
-AC_CHECK_FUNCS(clock time gettimeofday strtoul stpcpy)
-AC_CHECK_FUNCS(mmap sigprocmask) # assume they work OK for our purposes
-AC_CHECK_FUNCS(getopt_long_only)
-
-AC_CHECK_LIB(m, sinf, MATHLIB=-lm)
-AC_SUBST(MATHLIB)
-
-# Checks for X
-AC_PATH_XTRA
-if test "$no_x" != yes; then
-  AC_SUBST(HAVE_X, 1)
-  AC_SUBST(XYPLANE, XYplane)
-  AC_SUBST(XLIB, "$X_LIBS -lX11")
-fi
-
-# OCaml stuff
-AC_ARG_VAR(MLFLAGS, [Flags to pass to ocamlc])
-if test "$WINDOWS" = 1; then
-  AC_SUBST(MLLINKFLAGS, "-ccopt -L/lib/mingw")
-fi
-
-# Check ocaml version
-$as_echo_n "checking ocaml version... "
-if ! ocamlc; then echo not found; else
-  OCAMLV=`ocamlc -v | sed -n '1s/.*version \([[0-9]]*\.[[0-9]]*\).*/\1/p'`
-  $as_echo $OCAMLV
-  TMPV=`echo $OCAMLV | \
-      sed -e 's/\./\.0000/' -e 's/\.0*\([[0-9]][[0-9]][[0-9]][[0-9]]\)/\1/'`
-  if test $TMPV -lt 40002; then
-      AC_SUBST(COMPAT, bytes.cmo)
-  fi
-  if test $TMPV -lt 40006; then
-      AC_SUBST(SYS_COMPAT, sys_compat1.ml.in)
-  else
-      AC_SUBST(SYS_COMPAT, sys_compat2.ml.in)
-  fi
-fi
-
-
-# PACKAGE OPTIONS
-
-# Option debug
-AC_ARG_ENABLE(debug,
-  AS_HELP_STRING([--enable-debug], [set up for debugging]),
-  if test "$enable_debug" = yes; then 
-    DEBUG=1
-    AC_DEFINE(DEBUG, 1, [Define to set up for debugging]) 
-    : ${MLFLAGS=-g}
-  fi)
-AC_SUBST(DEBUG)
-
-# Option dynlink
-AC_ARG_ENABLE(dynlink,
-  AS_HELP_STRING([--disable-dynlink], [do not use dynamic linking]))
-if test "$enable_dynlink" != no && test "$WINDOWS" != 1; then
-  DYNLINK=1
-  AC_DEFINE(DYNLINK, 1, [Define if dynamic linking enabled])
-  AC_SEARCH_LIBS(dlopen, dl)
-  AC_TEST_RDYNAMIC(DLFLAGS="-rdynamic")
-fi
-AC_SUBST(DYNLINK)
-AC_SUBST(DLFLAGS)
-
-case $host in
-  *-*-darwin*) 
-    SHL_CFLAGS="-fPIC -bundle -undefined dynamic_lookup";;
-  *)           
-    SHL_CFLAGS="-fPIC"; SHL_LFLAGS="-shared";;
-esac
-AC_SUBST(SHL_CFLAGS)
-AC_SUBST(SHL_LFLAGS)
-AC_SUBST(DLEXT, [.so])
-AC_DEFINE_UNQUOTED(DLEXT, "$DLEXT", [Extension for dynamic libraries])
-
-# Option ffi
-AC_ARG_ENABLE(ffi,
-  AS_HELP_STRING([--disable-ffi], [do not use FFI with dynlink]))
-AC_CHECK_HEADERS(ffi.h, HAVE_FFI_H=1)
-if test "$enable_ffi" != no && test "$DYNLINK" = 1 \
-    && test "$HAVE_FFI_H" = 1; then
-  AC_DEFINE(USE_FFI, 1, [Define if FFI enabled])
-  AC_SEARCH_LIBS(ffi_call, ffi)
-fi
-
-# Option gc
-AC_ARG_ENABLE(gc,
-  AS_HELP_STRING([--enable-gc=option],
-    [Use 'yes' for Oberon GC, 'boehm' for Boehm library]))
-if test "$enable_gc" = boehm; then
-  GC_OBJ=gc0.o; GC_LIB=-lgc
-  AC_DEFINE(USE_BOEHM, 1, [Define to use Boehm garbage collector])
-elif test "$enable_gc" != no; then
-  GC_OBJ=gc.o; GC_LIB=
-else
-  GC_OBJ=gc0.o; GC_LIB=
-fi
-AC_SUBST(GC_OBJ)
-AC_SUBST(GC_LIB)
-
-# Option jit
-CODEPAGE=16384
-FLOATOPS=1
-AC_ARG_ENABLE(jit,
-  AS_HELP_STRING([--disable-jit], [disable JIT translator]))
-if test "$enable_segmem" == yes; then enable_jit=no; fi
-if test "$enable_jit" != no; then
-  case $host in
-    i?86-*) 
-      ENABLE_JIT=1; VM=vm386.o
-      AC_DEFINE(NEED_FPINIT, 1, [Reboot FPU for each primitive]);;
-    x86_64-*) 
-      ENABLE_JIT=1; VM=vm386.o;;
-    armv6l-*|armv7l-*|arm-*)
-      ENABLE_JIT=1; VM=vmpi.o; CODEPAGE=4096
-      AC_DEFINE(USE_FLUSH, 1, [Whether to flush the cache]);;
-    mipsel-*)
-      ENABLE_JIT=1; VM=vmomega.o; FLOATOPS=0
-      AC_DEFINE(USE_FLUSH, 1);;
-  esac
-fi
-AC_ARG_ENABLE(floatops,
-  AS_HELP_STRING([--disable-floatops], [disable JIT for floating point]))
-if test "$enable_floatops" = no; then FLOATOPS=0; fi
-AC_SUBST(VM)
-AC_SUBST(ENABLE_JIT)
-AC_DEFINE_UNQUOTED([CODEPAGE], $CODEPAGE, [Size of block for JIT code])
-if test $FLOATOPS = 1; then
-  AC_DEFINE(FLOATOPS, 1, [Whether to use thunder for floating point])
-fi
-
-# Option debugger
-AC_ARG_ENABLE(debugger,
-  AS_HELP_STRING([--disable-debugger], [disable runtime debugger]))
-if test "$enable_debugger" != no; then 
-  AC_SUBST(ENABLE_DEBUGGER, 1)
-fi
-if test "$enable_debugger" = inet || test "$WINDOWS" = 1; then 
-  AC_SUBST(USE_INET, 1)
-  AC_DEFINE(USE_INET, 1, [Whether to use inet sockets for the debugger])
-fi
-
-OBDB1='"$LIBDIR/obdb1 -R $LIBDIR/resources"'
-OBDB1_DEBUG='"$BINDIR/debugger/obdb1 -R $ROOT$TOPDIR/resources"'
-if test "$MACOS" = 1; then
-  OBDB1='"$LIBDIR/Obdb.app/Contents/MacOS/obdb"'
-  OBDB1_DEBUG='"$BINDIR/macport/Obdb.app/Contents/MacOS/obdb"'
-fi
-AC_SUBST(OBDB1)
-AC_SUBST(OBDB1_DEBUG)   
-
-# GTK setup for debugger
-MONOFONT="Monospace 10"
-SANSFONT="Sans 10"
-if test "$MACOS" = 1; then
-  MONOFONT="Monospace 14"
-  SANSFONT="Lucida Grande 14"
-fi
-AC_SUBST(MONOFONT)
-AC_SUBST(SANSFONT)
-AC_SUBST(RESOURCES, "blank.png breakpoint.png continue.png here.png \
-oberon.lang pause.png sober.xml stepinto.png stepout.png stepover.png \
-restart.png exit.png")
-
-if test "$WINDOWS" = 1; then
-  OCAMLDIR='"/cygdrive/c/Program Files/Objective Caml/lib"'
-  DEB_LIBS="$LIBS -lws2_32"
-else
-  OCAMLDIR=`ocamlc -where`
-  BASE_LIBS=$LIBS
-  if test "$ENABLE_DEBUGGER" = 1; then
-      AC_SEARCH_LIBS(connect, socket)
-  fi
-  DEB_LIBS=$LIBS
-  LIBS=$BASE_LIBS
-fi
-AC_SUBST(OCAMLDIR)
-AC_SUBST(DEB_LIBS)
-
-
-# Module list
-
-# Standard modules
-AC_SUBST(STDMODS, "Files Conv In Out Err Args Bit Timer \
-Strings Random Math MathL")
-
-AC_SUBST(STDMODS_B, "Files Conv In-b Out Err Args Bit Timer \
-Strings-b Random-b Math MathL")
-
-# Modules that contain runtime checks -- recompile with -b
-AC_SUBST(CHECKMODS, "In Random Strings")
-
-# Modules containing C code
-AC_SUBST(PRIMMODS, "Args Timer Files Conv Random")
-
-# Modules with primitives in separate shared libraries:
-AC_SUBST(SHLMODS, "$XYPLANE")
-
-# All library modules
-AC_SUBST(ALLMODS, "$STDMODS $SHLMODS")
-
-# The endgame
-AC_OUTPUT
diff --git a/debugger/Makefile.in b/debugger/Makefile.in
index 2346070..afb77f7 100644
--- a/debugger/Makefile.in
+++ b/debugger/Makefile.in
@@ -31,9 +31,7 @@
 #
 
 # Config stuff
-OCAMLC = ocamlc
-OCAMLLEX = ocamllex
-MYACC = ../yacc/myacc
+OCAMLC = @OCAMLC@
 CAMLDEP = @top_srcdir@/camldep
 MLFLAGS = @MLFLAGS@
 MLLINKFLAGS = @MLLINKFLAGS@
@@ -46,12 +44,12 @@ SHELL = /bin/sh
 DEPEND = @DEPEND@
 EXEEXT = @EXEEXT@
 VPATH = @srcdir@
-OCAMLDIR = @OCAMLDIR@
 PKG_CONFIG = @PKG_CONFIG@
 PKG_FLAGS = @PKG_FLAGS@
 GTKPKGS = @GTKPKGS@
 WINDOWS = @WINDOWS@
 MACOS = @MACOS@
+LIBDIRS = @LIBDIRS@
 # End
 
 all: obdb1
@@ -68,36 +66,34 @@ else
 endif
 
 INCLUDE = -I ../mllib -I ../compiler -I ../yacc -I ../lablgtk3
-LIBS = unix.cma threads.cma str.cma \
-	../lablgtk3/lablgtk3.cma ../lablgtk3/gtkThread.cmo
+ifdef LIBDIRS
+  INCLUDE += -I +unix
+endif
+
+LIBS = unix.cma threads.cma ../lablgtk3/lablgtk3.cma ../lablgtk3/gtkThread.cmo
 
 OBDB1 = ../mllib/mllib.cma ../yacc/yyparse.cmo ../compiler/basis.cma \
 	debugger.cma debmain.cmo debprims.o
 obdb1: $(OBDB1)
-	$(OCAMLC) $(MLFLAGS) -custom -thread $(LIBS) $(OBDB1) \
-	    -cclib "-L../lablgtk3 -llablgtk3 $(GTKLIBS)" $(MLLINKFLAGS) -o $@
+	$(OCAMLC) $(MLFLAGS) -custom -thread $(INCLUDE) $(LIBS) $(OBDB1) \
+	    -cclib "-L../lablgtk3 -llablgtk3 $(GTKLIBS)" $(MLLINKFLAGS) \
+	    -ccopt -Wno-lto-type-mismatch -o $@
 
 DEBUGGER = debconf.cmo binary.cmo info.cmo procio.cmo data.cmo \
 	control.cmo sourcebook.cmo varsview.cmo stackview.cmo
 debugger.cma: $(DEBUGGER)
-	ocamlc $(MLFLAGS) -a -o $@ $^
+	$(OCAMLC) $(MLFLAGS) -a -o $@ $^
 
 debprims.o: debprims.c
 	$(OCAMLC) -c -ccopt '-I ..' -ccopt '$(GTKFLAGS)' -o $@ $<
 
 ## Rules
 
-%.mli %.ml: %.mly
-	$(MYACC) -v $<
-
-%.ml: %.mll
-	$(OCAMLLEX) -o $@ $<
-
 %.cmi: %.mli
 	$(OCAMLC) $(MLFLAGS) -c $(INCLUDE) -o $@ $<
 
 %.cmo: %.ml
-	$(OCAMLC) $(MLFLAGS) -c $(INCLUDE) -thread -o $@ $<
+	$(OCAMLC) $(MLFLAGS) -w -l -c $(INCLUDE) -thread -o $@ $<
 
 .DELETE_ON_ERROR:
 
diff --git a/lablgtk3/Makefile.in b/lablgtk3/Makefile.in
index e079a04..94810c3 100644
--- a/lablgtk3/Makefile.in
+++ b/lablgtk3/Makefile.in
@@ -35,6 +35,7 @@ srcdir = @srcdir@
 subdir = lablgtk3
 abs_top_srcdir = @abs_top_srcdir@
 abs_top_builddir = @abs_top_builddir@
+OCAMLC = @OCAMLC@
 MLFLAGS = @MLFLAGS@
 RANLIB = @RANLIB@
 WINDOWS = @WINDOWS@
@@ -46,6 +47,7 @@ PKG_CONFIG = @PKG_CONFIG@
 GTKPKGS = @GTKPKGS@
 PKG_FLAGS = @PKG_FLAGS@
 SYS_COMPAT = @SYS_COMPAT@
+LIBDIRS = @LIBDIRS@
 # End of config
 
 ALL = lablgtk3.cma liblablgtk3.a gtkThread.cmo
@@ -66,8 +68,10 @@ ALLPROPS = gtkBase.props $(PROPS)
 TAGS = gdkpixbuf_tags.var gdk_tags.var glib_tags.var gobject_tags.var \
 	gtk_tags.var pango_tags.var
 
+ENUMS =	gdkEnums.ml gtkEnums.ml sourceView3Enums.ml pangoEnums.ml
+
 MLOBJS = sys_compat.cmo gaux.cmo gpointer.cmo gutf8.cmo glib.cmo gobject.cmo \
-	gdkEnums.cmo gtkEnums.cmo sourceView3Enums.cmo pangoEnums.cmo \
+	$(ENUMS:%.ml=%.cmo) \
 	pango.cmo gPango.cmo \
 	gdk.cmo gdkEvent.cmo gdkKeysyms.cmo gdkPixbuf.cmo \
 	gDraw.cmo \
@@ -84,6 +88,9 @@ MLOBJS = sys_compat.cmo gaux.cmo gpointer.cmo gutf8.cmo glib.cmo gobject.cmo \
 	gtkSourceView3.cmo gSourceView3.cmo 
 
 INCLUDE = -I ../mllib
+ifdef LIBDIRS
+INCLUDE += -I +unix
+endif
 
 all: $(ALL)
 
@@ -96,33 +103,31 @@ ifdef MACOS
 endif
 
 lablgtk3.cma: $(MLOBJS)
-	ocamlc $(MLFLAGS) -a -o $@ $^
+	$(OCAMLC) $(MLFLAGS) -a -o $@ $^
 
 liblablgtk3.a: $(COBJS)
 	ar cr $@ $^
 	$(RANLIB) $@	
 
-WARN = -w s
-
-# gobject.cmo: WARN += -w -52
+WARN = -w -s-l
 
 gtkThread.cmi: gtkThread.mli
-	ocamlc $(MLFLAGS) $(INCLUDE) -c -thread -o $@ $<
+	$(OCAMLC) $(MLFLAGS) $(INCLUDE) -c -thread -o $@ $<
 
 gtkThread.cmo: gtkThread.ml
-	ocamlc $(MLFLAGS) $(WARN) $(INCLUDE) -c -thread -o $@ $<
+	$(OCAMLC) $(MLFLAGS) $(WARN) $(INCLUDE) -c -thread -o $@ $<
 
 %.cmi: %.mli
-	ocamlc $(MLFLAGS) $(INCLUDE) -c -o $@ $< 
+	$(OCAMLC) $(MLFLAGS) $(INCLUDE) -c -o $@ $< 
 
 %.cmo: %.ml
-	ocamlc $(MLFLAGS) $(WARN) $(INCLUDE) -c -o $@ $< 
+	$(OCAMLC) $(MLFLAGS) $(WARN) $(INCLUDE) -c -o $@ $< 
 
 CCOPTS = -ccopt '-I .' -ccopt '-I ..' -ccopt '$(GTKFLAGS)' \
 	-ccopt -Wno-deprecated-declarations
 
 %.o: %.c
-	ocamlc $(MLFLAGS) -c $(CCOPTS) -o $@ $<
+	$(OCAMLC) $(MLFLAGS) -c $(CCOPTS) -o $@ $<
 
 $(COBJS) ml_gtksourceview3.o: \
 	gdk_tags.h gdkpixbuf_tags.h glib_tags.h gobject_tags.h \
@@ -131,30 +136,29 @@ $(COBJS) ml_gtksourceview3.o: \
 	ml_gobject.h ml_gpointer.h ml_gtk.h ml_gvaluecaml.h ml_pango.h \
 	pango_tags.h wrappers.h
 
-%Props.ml o%Props.ml: %.props propcc
-	./propcc -o $*Props.ml $<
+%Props.ml o%Props.ml: %.props lablgen/propcc
+	lablgen/propcc -o $*Props.ml $<
 
-%_tags.c %_tags.h %Enums.ml: %_tags.var varcc
-	./varcc -c $*_tags.c -h $*_tags.h $<
+$(ENUMS): %Enums.ml: %_tags.h
 
-propcc varcc: %: %.ml
-	ocamlc $(MLFLAGS) -o $@ $<
+%_tags.c %_tags.h: %_tags.var lablgen/varcc
+	lablgen/varcc -c $*_tags.c -h $*_tags.h $<
 
-#propcc.ml varcc.ml: %.ml: %.ml4
-#	camlp4 pa_o.cmo pa_op.cmo pr_o.cmo -impl $< >$@
+lablgen/propcc lablgen/varcc:
+	$(MAKE) -C lablgen all
 
 sys_compat.ml: $(SYS_COMPAT)
 	cp $< $@
 
 clean: force
-	rm -f *.cma *.cmi *.cmo *.o *.a propcc varcc
+	rm -f *.o *.a *.cmo *.cmi *.cma
 
 quiteclean : clean
+	$(MAKE) -C lablgen $@
 	rm -f $(ALLPROPS:%.props=%Props.ml) $(ALLPROPS:%.props=o%Props.ml) \
 		gtkSourceView3Props.ml ogtkSourceView3Props.ml \
 		$(TAGS:%.var=%.h) $(TAGS:%.var=%.c) \
-		$(TAGS:%_tags.var=%Enums.ml) sourceView3_tags.h \
-		sourceView3_tags.c sourceView3Enums.ml sys_compat.ml
+		$(ENUMS) sourceView3_tags.h sourceView3_tags.c sys_compat.ml
 
 distclean: quiteclean
 	rm Makefile
@@ -172,11 +176,11 @@ ML = gBin.mli gButton.mli gContainer.mli gData.mli gdk.mli		\
 	gMisc.mli gobject.mli gObj.mli gPack.mli gSourceView3.mli	\
 	gText.mli gtkSourceView3_types.mli gtkThread.mli gToolbox.mli	\
 	gTree.mli gWindow.mli gaux.ml gBin.ml gButton.ml	\
-	gContainer.ml gData.ml gdkEnums.ml gdkEvent.ml gdk.ml		\
+	gContainer.ml gData.ml gdkEvent.ml gdk.ml		\
 	gdkPixbuf.ml gDraw.ml glib.ml gMain.ml gMenu.ml gMisc.ml	\
 	gobject.ml gObj.ml gPack.ml gpointer.ml gSourceView3.ml		\
 	gText.ml gtkBase.ml gtkBaseProps.ml gtkBin.ml gtkBinProps.ml	\
-	gtkButton.ml gtkButtonProps.ml gtkData.ml gtkEnums.ml		\
+	gtkButton.ml gtkButtonProps.ml gtkData.ml 		\
 	gtkMain.ml gtkMenu.ml gtkMenuProps.ml gtkMisc.ml		\
 	gtkMiscProps.ml gtk.ml gtkObject.ml gtkPack.ml			\
 	gtkPackProps.ml gtkSignal.ml gtkSourceView3.ml			\
@@ -185,16 +189,13 @@ ML = gBin.mli gButton.mli gContainer.mli gData.mli gdk.mli		\
 	gToolbox.ml gTree.ml gWindow.ml ogtkBaseProps.ml	\
 	ogtkBinProps.ml ogtkButtonProps.ml ogtkMenuProps.ml		\
 	ogtkMiscProps.ml ogtkPackProps.ml ogtkSourceView3Props.ml	\
-	ogtkTextProps.ml ogtkTreeProps.ml pangoEnums.ml pango.ml	\
-	sourceView3Enums.ml gpointer.mli gutf8.mli gutf8.ml \
+	ogtkTextProps.ml ogtkTreeProps.ml pango.ml	\
+	gpointer.mli gutf8.mli gutf8.ml \
 	gtkSignal.mli gPango.mli gPango.ml gtkContainers.ml \
 	gtkContainersProps.ml ogtkContainersProps.ml gFile.mli \
 	gFile.ml gtkFileProps.ml ogtkFileProps.ml gtkFile.ml \
 	gdkKeysyms.ml gEdit.mli gEdit.ml gtkEditProps.ml \
-	ogtkEditProps.ml gtkEdit.ml
-
-link: $(ML)
-	ocamldsort $(ML)
+	ogtkEditProps.ml gtkEdit.ml $(ENUMS)
 
 ifdef DEPEND
 $(srcdir)/Depend: $(ML)
diff --git a/lablgtk3/glib.ml b/lablgtk3/glib.ml
index 0ba76ab..fd6dd6b 100644
--- a/lablgtk3/glib.ml
+++ b/lablgtk3/glib.ml
@@ -114,7 +114,7 @@ module Message = struct
 
   external _log : string -> int -> string -> unit = "ml_g_log"
   let log ?(domain="") level fmt =
-    Printf.kprintf (_log domain (log_level level)) fmt
+    Printf.ksprintf (_log domain (log_level level)) fmt
 end
 
 (*    
diff --git a/lablgtk3/lablgen/Makefile b/lablgtk3/lablgen/Makefile
new file mode 100644
index 0000000..e071f0c
--- /dev/null
+++ b/lablgtk3/lablgen/Makefile
@@ -0,0 +1,28 @@
+# lablgtk3/lablgen/Makefile
+
+OCAMLC = ocamlc
+
+all: propcc varcc
+
+propcc varcc: %: myStream.cmo myGenlex.cmo %.cmo
+	$(OCAMLC) $^ -o $@ 
+
+# The utilities propcc and varcc were originally built using camlp4,
+# but I've saved the resulting ML source to avoid depending on it.
+# 
+# propcc.ml varcc.ml: %.ml: %.ml4
+#	camlp4 pa_o.cmo pa_op.cmo pr_o.cmo -impl $< >$@
+
+propcc.cmo varcc.cmo myGenlex.cmo: myGenlex.cmi myStream.cmi
+myStream.cmo: myStream.cmi
+
+%.cmi: %.mli
+	$(OCAMLC) -c $< -o $@ 
+
+%.cmo: %.ml
+	$(OCAMLC) -c $< -o $@
+
+clean:
+
+quiteclean: clean
+	rm propcc varcc *.cmi *.cmo
diff --git a/lablgtk3/lablgen/myGenlex.ml b/lablgtk3/lablgen/myGenlex.ml
new file mode 100644
index 0000000..63a7433
--- /dev/null
+++ b/lablgtk3/lablgen/myGenlex.ml
@@ -0,0 +1,203 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*               Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+module Stream = MyStream
+
+type token =
+    Kwd of string
+  | Ident of string
+  | Int of int
+  | Float of float
+  | String of string
+  | Char of char
+
+(* The string buffering machinery *)
+
+let initial_buffer = Bytes.create 32
+
+let buffer = ref initial_buffer
+let bufpos = ref 0
+
+let reset_buffer () = buffer := initial_buffer; bufpos := 0
+
+let store c =
+  if !bufpos >= Bytes.length !buffer then begin
+    let newbuffer = Bytes.create (2 * !bufpos) in
+    Bytes.blit !buffer 0 newbuffer 0 !bufpos;
+    buffer := newbuffer
+  end;
+  Bytes.set !buffer !bufpos c;
+  incr bufpos
+
+let get_string () =
+  let s = Bytes.sub_string !buffer 0 !bufpos in buffer := initial_buffer; s
+
+(* The lexer *)
+
+let make_lexer keywords =
+  let kwd_table = Hashtbl.create 17 in
+  List.iter (fun s -> Hashtbl.add kwd_table s (Kwd s)) keywords;
+  let ident_or_keyword id =
+    try Hashtbl.find kwd_table id with
+      Not_found -> Ident id
+  and keyword_or_error c =
+    let s = String.make 1 c in
+    try Hashtbl.find kwd_table s with
+      Not_found -> raise (Stream.Error ("Illegal character " ^ s))
+  in
+  let rec next_token (strm__ : _ Stream.t) =
+    match Stream.peek strm__ with
+      Some (' ' | '\010' | '\013' | '\009' | '\026' | '\012') ->
+        Stream.junk strm__; next_token strm__
+    | Some ('A'..'Z' | 'a'..'z' | '_' | '\192'..'\255' as c) ->
+        Stream.junk strm__;
+        let s = strm__ in reset_buffer (); store c; ident s
+    | Some
+        ('!' | '%' | '&' | '$' | '#' | '+' | '/' | ':' | '<' | '=' | '>' |
+         '?' | '@' | '\\' | '~' | '^' | '|' | '*' as c) ->
+        Stream.junk strm__;
+        let s = strm__ in reset_buffer (); store c; ident2 s
+    | Some ('0'..'9' as c) ->
+        Stream.junk strm__;
+        let s = strm__ in reset_buffer (); store c; number s
+    | Some '\'' ->
+        Stream.junk strm__;
+        let c =
+          try char strm__ with
+            Stream.Failure -> raise (Stream.Error "")
+        in
+        begin match Stream.peek strm__ with
+          Some '\'' -> Stream.junk strm__; Some (Char c)
+        | _ -> raise (Stream.Error "")
+        end
+    | Some '\"' ->
+        Stream.junk strm__;
+        let s = strm__ in reset_buffer (); Some (String (string s))
+    | Some '-' -> Stream.junk strm__; neg_number strm__
+    | Some '(' -> Stream.junk strm__; maybe_comment strm__
+    | Some c -> Stream.junk strm__; Some (keyword_or_error c)
+    | _ -> None
+  and ident (strm__ : _ Stream.t) =
+    match Stream.peek strm__ with
+      Some
+        ('A'..'Z' | 'a'..'z' | '\192'..'\255' | '0'..'9' | '_' | '\'' as c) ->
+        Stream.junk strm__; let s = strm__ in store c; ident s
+    | _ -> Some (ident_or_keyword (get_string ()))
+  and ident2 (strm__ : _ Stream.t) =
+    match Stream.peek strm__ with
+      Some
+        ('!' | '%' | '&' | '$' | '#' | '+' | '-' | '/' | ':' | '<' | '=' |
+         '>' | '?' | '@' | '\\' | '~' | '^' | '|' | '*' as c) ->
+        Stream.junk strm__; let s = strm__ in store c; ident2 s
+    | _ -> Some (ident_or_keyword (get_string ()))
+  and neg_number (strm__ : _ Stream.t) =
+    match Stream.peek strm__ with
+      Some ('0'..'9' as c) ->
+        Stream.junk strm__;
+        let s = strm__ in reset_buffer (); store '-'; store c; number s
+    | _ -> let s = strm__ in reset_buffer (); store '-'; ident2 s
+  and number (strm__ : _ Stream.t) =
+    match Stream.peek strm__ with
+      Some ('0'..'9' as c) ->
+        Stream.junk strm__; let s = strm__ in store c; number s
+    | Some '.' ->
+        Stream.junk strm__; let s = strm__ in store '.'; decimal_part s
+    | Some ('e' | 'E') ->
+        Stream.junk strm__; let s = strm__ in store 'E'; exponent_part s
+    | _ -> Some (Int (int_of_string (get_string ())))
+  and decimal_part (strm__ : _ Stream.t) =
+    match Stream.peek strm__ with
+      Some ('0'..'9' as c) ->
+        Stream.junk strm__; let s = strm__ in store c; decimal_part s
+    | Some ('e' | 'E') ->
+        Stream.junk strm__; let s = strm__ in store 'E'; exponent_part s
+    | _ -> Some (Float (float_of_string (get_string ())))
+  and exponent_part (strm__ : _ Stream.t) =
+    match Stream.peek strm__ with
+      Some ('+' | '-' as c) ->
+        Stream.junk strm__; let s = strm__ in store c; end_exponent_part s
+    | _ -> end_exponent_part strm__
+  and end_exponent_part (strm__ : _ Stream.t) =
+    match Stream.peek strm__ with
+      Some ('0'..'9' as c) ->
+        Stream.junk strm__; let s = strm__ in store c; end_exponent_part s
+    | _ -> Some (Float (float_of_string (get_string ())))
+  and string (strm__ : _ Stream.t) =
+    match Stream.peek strm__ with
+      Some '\"' -> Stream.junk strm__; get_string ()
+    | Some '\\' ->
+        Stream.junk strm__;
+        let c =
+          try escape strm__ with
+            Stream.Failure -> raise (Stream.Error "")
+        in
+        let s = strm__ in store c; string s
+    | Some c -> Stream.junk strm__; let s = strm__ in store c; string s
+    | _ -> raise Stream.Failure
+  and char (strm__ : _ Stream.t) =
+    match Stream.peek strm__ with
+      Some '\\' ->
+        Stream.junk strm__;
+        begin try escape strm__ with
+          Stream.Failure -> raise (Stream.Error "")
+        end
+    | Some c -> Stream.junk strm__; c
+    | _ -> raise Stream.Failure
+  and escape (strm__ : _ Stream.t) =
+    match Stream.peek strm__ with
+      Some 'n' -> Stream.junk strm__; '\n'
+    | Some 'r' -> Stream.junk strm__; '\r'
+    | Some 't' -> Stream.junk strm__; '\t'
+    | Some ('0'..'9' as c1) ->
+        Stream.junk strm__;
+        begin match Stream.peek strm__ with
+          Some ('0'..'9' as c2) ->
+            Stream.junk strm__;
+            begin match Stream.peek strm__ with
+              Some ('0'..'9' as c3) ->
+                Stream.junk strm__;
+                Char.chr
+                  ((Char.code c1 - 48) * 100 + (Char.code c2 - 48) * 10 +
+                     (Char.code c3 - 48))
+            | _ -> raise (Stream.Error "")
+            end
+        | _ -> raise (Stream.Error "")
+        end
+    | Some c -> Stream.junk strm__; c
+    | _ -> raise Stream.Failure
+  and maybe_comment (strm__ : _ Stream.t) =
+    match Stream.peek strm__ with
+      Some '*' ->
+        Stream.junk strm__; let s = strm__ in comment s; next_token s
+    | _ -> Some (keyword_or_error '(')
+  and comment (strm__ : _ Stream.t) =
+    match Stream.peek strm__ with
+      Some '(' -> Stream.junk strm__; maybe_nested_comment strm__
+    | Some '*' -> Stream.junk strm__; maybe_end_comment strm__
+    | Some _ -> Stream.junk strm__; comment strm__
+    | _ -> raise Stream.Failure
+  and maybe_nested_comment (strm__ : _ Stream.t) =
+    match Stream.peek strm__ with
+      Some '*' -> Stream.junk strm__; let s = strm__ in comment s; comment s
+    | Some _ -> Stream.junk strm__; comment strm__
+    | _ -> raise Stream.Failure
+  and maybe_end_comment (strm__ : _ Stream.t) =
+    match Stream.peek strm__ with
+      Some ')' -> Stream.junk strm__; ()
+    | Some '*' -> Stream.junk strm__; maybe_end_comment strm__
+    | Some _ -> Stream.junk strm__; comment strm__
+    | _ -> raise Stream.Failure
+  in
+  fun input -> Stream.from (fun _count -> next_token input)
diff --git a/lablgtk3/lablgen/myGenlex.mli b/lablgtk3/lablgen/myGenlex.mli
new file mode 100644
index 0000000..fa2a91e
--- /dev/null
+++ b/lablgtk3/lablgen/myGenlex.mli
@@ -0,0 +1,75 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*               Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
+(*                                                                        *)
+(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+module Stream = MyStream
+
+(** A generic lexical analyzer.
+
+
+   This module implements a simple 'standard' lexical analyzer, presented
+   as a function from character streams to token streams. It implements
+   roughly the lexical conventions of OCaml, but is parameterized by the
+   set of keywords of your language.
+
+
+   Example: a lexer suitable for a desk calculator is obtained by
+{[     let lexer = make_lexer ["+"; "-"; "*"; "/"; "let"; "="; "("; ")"]]}
+
+   The associated parser would be a function from [token stream]
+   to, for instance, [int], and would have rules such as:
+
+   {[
+     let rec parse_expr = parser
+       | [< n1 = parse_atom; n2 = parse_remainder n1 >] -> n2
+     and parse_atom = parser
+       | [< 'Int n >] -> n
+       | [< 'Kwd "("; n = parse_expr; 'Kwd ")" >] -> n
+     and parse_remainder n1 = parser
+       | [< 'Kwd "+"; n2 = parse_expr >] -> n1 + n2
+       | [< >] -> n1
+   ]}
+
+   One should notice that the use of the [parser] keyword and associated
+   notation for streams are only available through camlp4 extensions. This
+   means that one has to preprocess its sources {i e. g.} by using the
+   ["-pp"] command-line switch of the compilers.
+*)
+
+(** The type of tokens. The lexical classes are: [Int] and [Float]
+   for integer and floating-point numbers; [String] for
+   string literals, enclosed in double quotes; [Char] for
+   character literals, enclosed in single quotes; [Ident] for
+   identifiers (either sequences of letters, digits, underscores
+   and quotes, or sequences of 'operator characters' such as
+   [+], [*], etc); and [Kwd] for keywords (either identifiers or
+   single 'special characters' such as [(], [}], etc). *)
+type token =
+    Kwd of string
+  | Ident of string
+  | Int of int
+  | Float of float
+  | String of string
+  | Char of char
+
+val make_lexer : string list -> char Stream.t -> token Stream.t
+(** Construct the lexer function. The first argument is the list of
+   keywords. An identifier [s] is returned as [Kwd s] if [s]
+   belongs to this list, and as [Ident s] otherwise.
+   A special character [s] is returned as [Kwd s] if [s]
+   belongs to this list, and cause a lexical error (exception
+   {!Stream.Error} with the offending lexeme as its parameter) otherwise.
+   Blanks and newlines are skipped. Comments delimited by [(*] and [*)]
+   are skipped as well, and can be nested. A {!Stream.Failure} exception
+   is raised if end of stream is unexpectedly reached.*)
diff --git a/lablgtk3/lablgen/myStream.ml b/lablgtk3/lablgen/myStream.ml
new file mode 100644
index 0000000..2bfef70
--- /dev/null
+++ b/lablgtk3/lablgen/myStream.ml
@@ -0,0 +1,236 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*         Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt       *)
+(*                                                                        *)
+(*   Copyright 1997 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+type 'a t = 'a cell option
+and 'a cell = { mutable count : int; mutable data : 'a data }
+and 'a data =
+    Sempty
+  | Scons of 'a * 'a data
+  | Sapp of 'a data * 'a data
+  | Slazy of 'a data Lazy.t
+  | Sgen of 'a gen
+  | Sbuffio : buffio -> char data
+and 'a gen = { mutable curr : 'a option option; func : int -> 'a option }
+and buffio =
+  { ic : in_channel; buff : bytes; mutable len : int; mutable ind : int }
+
+exception Failure
+exception Error of string
+
+let count = function
+  | None -> 0
+  | Some { count } -> count
+let data = function
+  | None -> Sempty
+  | Some { data } -> data
+
+let fill_buff b =
+  b.len <- input b.ic b.buff 0 (Bytes.length b.buff); b.ind <- 0
+
+
+let rec get_data : type v. int -> v data -> v data = fun count d -> match d with
+ (* Returns either Sempty or Scons(a, _) even when d is a generator
+    or a buffer. In those cases, the item a is seen as extracted from
+ the generator/buffer.
+ The count parameter is used for calling `Sgen-functions'.  *)
+   Sempty | Scons (_, _) -> d
+ | Sapp (d1, d2) ->
+     begin match get_data count d1 with
+       Scons (a, d11) -> Scons (a, Sapp (d11, d2))
+     | Sempty -> get_data count d2
+     | _ -> assert false
+     end
+ | Sgen {curr = Some None} -> Sempty
+ | Sgen ({curr = Some(Some a)} as g) ->
+     g.curr <- None; Scons(a, d)
+ | Sgen g ->
+     begin match g.func count with
+       None -> g.curr <- Some(None); Sempty
+     | Some a -> Scons(a, d)
+         (* Warning: anyone using g thinks that an item has been read *)
+     end
+ | Sbuffio b ->
+     if b.ind >= b.len then fill_buff b;
+     if b.len == 0 then Sempty else
+       let r = Bytes.unsafe_get b.buff b.ind in
+       (* Warning: anyone using g thinks that an item has been read *)
+       b.ind <- succ b.ind; Scons(r, d)
+ | Slazy f -> get_data count (Lazy.force f)
+
+
+let rec peek_data : type v. v cell -> v option = fun s ->
+ (* consult the first item of s *)
+ match s.data with
+   Sempty -> None
+ | Scons (a, _) -> Some a
+ | Sapp (_, _) ->
+     begin match get_data s.count s.data with
+       Scons(a, _) as d -> s.data <- d; Some a
+     | Sempty -> None
+     | _ -> assert false
+     end
+ | Slazy f -> s.data <- (Lazy.force f); peek_data s
+ | Sgen {curr = Some a} -> a
+ | Sgen g -> let x = g.func s.count in g.curr <- Some x; x
+ | Sbuffio b ->
+     if b.ind >= b.len then fill_buff b;
+     if b.len == 0 then begin s.data <- Sempty; None end
+     else Some (Bytes.unsafe_get b.buff b.ind)
+
+
+let peek = function
+  | None -> None
+  | Some s -> peek_data s
+
+
+let rec junk_data : type v. v cell -> unit = fun s ->
+  match s.data with
+    Scons (_, d) -> s.count <- (succ s.count); s.data <- d
+  | Sgen ({curr = Some _} as g) -> s.count <- (succ s.count); g.curr <- None
+  | Sbuffio b ->
+      if b.ind >= b.len then fill_buff b;
+      if b.len == 0 then s.data <- Sempty
+      else (s.count <- (succ s.count); b.ind <- succ b.ind)
+  | _ ->
+      match peek_data s with
+        None -> ()
+      | Some _ -> junk_data s
+
+
+let junk = function
+  | None -> ()
+  | Some data -> junk_data data
+
+let rec nget_data n s =
+  if n <= 0 then [], s.data, 0
+  else
+    match peek_data s with
+      Some a ->
+        junk_data s;
+        let (al, d, k) = nget_data (pred n) s in a :: al, Scons (a, d), succ k
+    | None -> [], s.data, 0
+
+
+let npeek_data n s =
+  let (al, d, len) = nget_data n s in
+  s.count <- (s.count - len);
+  s.data <- d;
+  al
+
+
+let npeek n = function
+  | None -> []
+  | Some d -> npeek_data n d
+
+let next s =
+  match peek s with
+    Some a -> junk s; a
+  | None -> raise Failure
+
+
+let empty s =
+  match peek s with
+    Some _ -> raise Failure
+  | None -> ()
+
+
+let iter f strm =
+  let rec do_rec () =
+    match peek strm with
+      Some a -> junk strm; ignore(f a); do_rec ()
+    | None -> ()
+  in
+  do_rec ()
+
+
+(* Stream building functions *)
+
+let from f = Some {count = 0; data = Sgen {curr = None; func = f}}
+
+let of_list l =
+  Some {count = 0; data = List.fold_right (fun x l -> Scons (x, l)) l Sempty}
+
+
+let of_string s =
+  let count = ref 0 in
+  from (fun _ ->
+    (* We cannot use the index passed by the [from] function directly
+       because it returns the current stream count, with absolutely no
+       guarantee that it will start from 0. For example, in the case
+       of [Stream.icons 'c' (Stream.from_string "ab")], the first
+       access to the string will be made with count [1] already.
+    *)
+    let c = !count in
+    if c < String.length s
+    then (incr count; Some s.[c])
+    else None)
+
+
+let of_bytes s =
+  let count = ref 0 in
+  from (fun _ ->
+    let c = !count in
+    if c < Bytes.length s
+    then (incr count; Some (Bytes.get s c))
+    else None)
+
+
+let of_channel ic =
+  Some {count = 0;
+        data = Sbuffio {ic = ic; buff = Bytes.create 4096; len = 0; ind = 0}}
+
+
+(* Stream expressions builders *)
+
+let iapp i s = Some {count = 0; data = Sapp (data i, data s)}
+let icons i s = Some {count = 0; data = Scons (i, data s)}
+let ising i = Some {count = 0; data = Scons (i, Sempty)}
+
+let lapp f s =
+  Some {count = 0; data = Slazy (lazy(Sapp (data (f ()), data s)))}
+
+let lcons f s = Some {count = 0; data = Slazy (lazy(Scons (f (), data s)))}
+let lsing f = Some {count = 0; data = Slazy (lazy(Scons (f (), Sempty)))}
+
+let sempty = None
+let slazy f = Some {count = 0; data = Slazy (lazy(data (f ())))}
+
+(* For debugging use *)
+
+let rec dump : type v. (v -> unit) -> v t -> unit = fun f s ->
+  print_string "{count = ";
+  print_int (count s);
+  print_string "; data = ";
+  dump_data f (data s);
+  print_string "}";
+  print_newline ()
+and dump_data : type v. (v -> unit) -> v data -> unit = fun f ->
+  function
+    Sempty -> print_string "Sempty"
+  | Scons (a, d) ->
+      print_string "Scons (";
+      f a;
+      print_string ", ";
+      dump_data f d;
+      print_string ")"
+  | Sapp (d1, d2) ->
+      print_string "Sapp (";
+      dump_data f d1;
+      print_string ", ";
+      dump_data f d2;
+      print_string ")"
+  | Slazy _ -> print_string "Slazy"
+  | Sgen _ -> print_string "Sgen"
+  | Sbuffio _ -> print_string "Sbuffio"
diff --git a/lablgtk3/lablgen/myStream.mli b/lablgtk3/lablgen/myStream.mli
new file mode 100644
index 0000000..ea7d293
--- /dev/null
+++ b/lablgtk3/lablgen/myStream.mli
@@ -0,0 +1,111 @@
+(**************************************************************************)
+(*                                                                        *)
+(*                                 OCaml                                  *)
+(*                                                                        *)
+(*         Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt       *)
+(*                                                                        *)
+(*   Copyright 1997 Institut National de Recherche en Informatique et     *)
+(*     en Automatique.                                                    *)
+(*                                                                        *)
+(*   All rights reserved.  This file is distributed under the terms of    *)
+(*   the GNU Lesser General Public License version 2.1, with the          *)
+(*   special exception on linking described in the file LICENSE.          *)
+(*                                                                        *)
+(**************************************************************************)
+
+(** Streams and parsers. *)
+
+type !'a t
+(** The type of streams holding values of type ['a]. *)
+
+exception Failure
+(** Raised by parsers when none of the first components of the stream
+   patterns is accepted. *)
+
+exception Error of string
+(** Raised by parsers when the first component of a stream pattern is
+   accepted, but one of the following components is rejected. *)
+
+
+(** {1 Stream builders} *)
+
+val from : (int -> 'a option) -> 'a t
+(** [Stream.from f] returns a stream built from the function [f].
+   To create a new stream element, the function [f] is called with
+   the current stream count. The user function [f] must return either
+   [Some <value>] for a value or [None] to specify the end of the
+   stream.
+
+   Do note that the indices passed to [f] may not start at [0] in the
+   general case. For example, [[< '0; '1; Stream.from f >]] would call
+   [f] the first time with count [2].
+*)
+
+val of_list : 'a list -> 'a t
+(** Return the stream holding the elements of the list in the same
+   order. *)
+
+val of_string : string -> char t
+(** Return the stream of the characters of the string parameter. *)
+
+val of_bytes : bytes -> char t
+(** Return the stream of the characters of the bytes parameter.
+    @since 4.02.0 *)
+
+val of_channel : in_channel -> char t
+(** Return the stream of the characters read from the input channel. *)
+
+
+(** {1 Stream iterator} *)
+
+val iter : ('a -> unit) -> 'a t -> unit
+(** [Stream.iter f s] scans the whole stream s, applying function [f]
+   in turn to each stream element encountered. *)
+
+
+(** {1 Predefined parsers} *)
+
+val next : 'a t -> 'a
+(** Return the first element of the stream and remove it from the
+   stream.
+   @raise Stream.Failure if the stream is empty. *)
+
+val empty : 'a t -> unit
+(** Return [()] if the stream is empty, else raise {!Stream.Failure}. *)
+
+
+(** {1 Useful functions} *)
+
+val peek : 'a t -> 'a option
+(** Return [Some] of "the first element" of the stream, or [None] if
+   the stream is empty. *)
+
+val junk : 'a t -> unit
+(** Remove the first element of the stream, possibly unfreezing
+   it before. *)
+
+val count : 'a t -> int
+(** Return the current count of the stream elements, i.e. the number
+   of the stream elements discarded. *)
+
+val npeek : int -> 'a t -> 'a list
+(** [npeek n] returns the list of the [n] first elements of
+   the stream, or all its remaining elements if less than [n]
+   elements are available. *)
+
+(**/**)
+
+(* The following is for system use only. Do not call directly. *)
+
+val iapp : 'a t -> 'a t -> 'a t
+val icons : 'a -> 'a t -> 'a t
+val ising : 'a -> 'a t
+
+val lapp : (unit -> 'a t) -> 'a t -> 'a t
+val lcons : (unit -> 'a) -> 'a t -> 'a t
+val lsing : (unit -> 'a) -> 'a t
+
+val sempty : 'a t
+val slazy : (unit -> 'a t) -> 'a t
+
+val dump : ('a -> unit) -> 'a t -> unit
diff --git a/lablgtk3/lablgen/propcc.ml b/lablgtk3/lablgen/propcc.ml
new file mode 100644
index 0000000..f371446
--- /dev/null
+++ b/lablgtk3/lablgen/propcc.ml
@@ -0,0 +1,968 @@
+(* -*- caml -*- *)
+(* $Id$ *)
+
+module Stream = MyStream
+module Genlex = MyGenlex
+
+open StdLabels
+open MoreLabels
+
+let caml_keywords = ["type", "kind"; "class", "classe"; "list", "liste"]
+let caml_modules = ["List", "Liste"]
+
+let is_not_uppercase =
+  function
+    'A'..'Z' -> false
+  | _ -> true
+let camlize id =
+  let b = Buffer.create (String.length id + 4) in
+  for i = 0 to String.length id - 1 do
+    match id.[i] with
+      'A'..'Z' as c ->
+        if i > 0 &&
+           (is_not_uppercase id.[i-1] ||
+            i < String.length id - 1 && is_not_uppercase id.[i+1])
+        then
+          Buffer.add_char b '_';
+        Buffer.add_char b (Char.lowercase_ascii c)
+    | '-' -> Buffer.add_char b '_'
+    | c -> Buffer.add_char b c
+  done;
+  let s = Buffer.contents b in
+  try List.assoc s caml_keywords with Not_found -> s
+
+let camlizeM s = try List.assoc s caml_modules with Not_found -> s
+
+let check_suffix s suff =
+  let len1 = String.length s
+  and len2 = String.length suff in
+  len1 > len2 && String.sub s ~pos:(len1 - len2) ~len:len2 = suff
+
+(* Arity of a caml type. Doesn't handle object types... *)
+let arity s =
+  let parens = ref 0
+  and arity = ref 0 in
+  for i = 0 to String.length s - 1 do
+    if s.[i] = '(' || s.[i] = '[' then incr parens
+    else if s.[i] = ')' || s.[i] = ']' then decr parens
+    else if !parens = 0 && s.[i] = '-' && s.[i+1] = '>' then incr arity
+  done;
+  if !parens <> 0 then failwith ("bad type : " ^ s);
+  !arity
+
+let rec min_labelled =
+  function
+    [] -> []
+  | a :: l ->
+      let l = min_labelled l in if l = [] && a = "" then [] else a :: l
+
+
+(* The real data *)
+let conversions = Hashtbl.create 17
+
+let enums =
+  ["Gtk", "GtkEnums",
+   ["Justification"; "Align"; "ArrowType"; "ShadowType"; "ResizeMode";
+    "ReliefStyle"; "ImageType"; "WindowType"; "WindowPosition"; "ButtonsType";
+    "MessageType"; "ButtonBoxStyle"; "PositionType"; "Orientation";
+    "ToolbarStyle"; "IconSize"; "PolicyType"; "CornerType"; "SelectionMode";
+    "SortType"; "WrapMode"; "SpinButtonUpdatePolicy"; "UpdateType";
+    "ProgressBarStyle"; "ProgressBarOrientation"; "CellRendererMode";
+    "CellRendererAccelMode"; "TreeViewColumnSizing"; "SortType";
+    "TextDirection"; "SizeGroupMode"; "StackTransitionType";
+    (* in signals *)
+    "MovementStep";
+    "ScrollStep"; "ScrollType"; "MenuDirectionType"; "DeleteType";
+    "StateType"; (* for canvas *)                 "AnchorType";
+    "DirectionType"; "SensitivityType"; "InputHints"; "InputPurpose";
+    "EntryIconPosition"; "PackDirection"; "TreeViewGridLines";
+    "FileChooserAction"; "FileChooserConfirmation"; "Response"];
+   "Gdk", "GdkEnums",
+   ["ExtensionMode"; "WindowTypeHint"; "EventMask"; "Gravity";
+    (* for canvas *)    "CapStyle"; "JoinStyle"; "LineStyle"];
+   "Pango", "PangoEnums",
+   ["Stretch"; "Style"; "Underline"; "Variant"; "EllipsizeMode"];
+   (* GtkSourceView *)
+   "Gtk", "SourceView2Enums",
+   ["SourceSmartHomeEndType"; "SourceDrawSpacesFlags"];
+   "Gtk3", "SourceView3Enums",
+   ["SourceSmartHomeEndType"; "SourceDrawSpacesFlags"]]
+
+(* These types must be registered with g_boxed_register! *)
+let boxeds =
+  ["Gdk", ["Color"; "Font"; "RGBA"; "Cairo"]; "Pango", ["FontDescription"];
+   "Gtk", ["IconSet"; "SelectionData"; "TextIter"; "TreePath"; "TreeIter"]]
+
+let classes =
+  ["Gdk", ["Image"; "Pixmap"; "Bitmap"; "Screen"; "DragContext"];
+   "Gtk", ["Style"; "TreeStore"; "TreeModel"; "TreeModelFilter"; "Tooltip"]]
+
+let specials =
+  ["GtkWidget", "GObj.conv_widget";
+   "GtkWidget_opt", "GObj.conv_widget_option";
+   "GtkAdjustment", "GData.conv_adjustment";
+   "GtkAdjustment_opt", "GData.conv_adjustment_option"]
+
+let add_pointer conv gtk name =
+  Hashtbl.add conversions ~key:gtk
+    ~data:(Printf.sprintf "(%s : %s data_conv)" conv name);
+  Hashtbl.add conversions ~key:(gtk ^ "_opt")
+    ~data:(Printf.sprintf "(%s_option : %s option data_conv)" conv name)
+
+let add_object = add_pointer "gobject"
+let add_boxed = add_pointer "unsafe_pointer" (* the type is not used *)
+
+let () =
+  List.iter ~f:(fun t -> Hashtbl.add conversions ~key:("g" ^ t) ~data:t)
+    ["boolean"; "char"; "uchar"; "int"; "uint"; "long"; "ulong"; "int32";
+     "uint32"; "int64"; "uint64"; "float"; "double"];
+  List.iter
+    ~f:(fun (gtype, conv) -> Hashtbl.add conversions ~key:gtype ~data:conv)
+    ["gchararray", "string"; "gchararray_opt", "string_option";
+     "string", "string"; "bool", "boolean"; "int", "int"; "int32", "int32";
+     "float", "float"];
+  List.iter enums
+    ~f:(fun (pre, modu, l) ->
+       List.iter l
+         ~f:(fun name ->
+            Hashtbl.add conversions ~key:(pre ^ name)
+              ~data:(Printf.sprintf "%s.Conv.%s" modu (camlize name))));
+  List.iter boxeds
+    ~f:(fun (pre, l) ->
+       List.iter l
+         ~f:(fun name -> add_boxed (pre ^ name) (pre ^ "." ^ camlize name)));
+  List.iter classes
+    ~f:(fun (pre, l) ->
+       List.iter l
+         ~f:(fun t -> add_object (pre ^ t) (pre ^ "." ^ camlize t)));
+  add_object "GObject" "unit obj";
+  add_object "GtkWidget" "Gtk.widget obj"
+
+open Genlex
+
+let lexer =
+  make_lexer ["{"; "}"; ":"; "/"; "("; ")"; "->"; "method"; "signal"]
+
+let rec star ?(acc = []) p (strm__ : _ Stream.t) =
+  match try Some (p strm__) with Stream.Failure -> None with
+    Some x -> let s = strm__ in star ~acc:(x :: acc) p s
+  | _ -> List.rev acc
+
+let may_token tok s = if Stream.peek s = Some tok then Stream.junk s
+
+let ident (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Ident id) -> Stream.junk strm__; id
+  | _ -> raise Stream.Failure
+
+let string (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (String s) -> Stream.junk strm__; s
+  | _ -> raise Stream.Failure
+
+let may_colon p def (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Kwd ":") -> Stream.junk strm__; let s = strm__ in p s
+  | _ -> def
+
+let may_string def (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (String s) -> Stream.junk strm__; s
+  | _ -> def
+
+let may_name s (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Kwd "(") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (Ident id) ->
+          Stream.junk strm__;
+          begin match Stream.peek strm__ with
+            Some (Kwd ")") -> Stream.junk strm__; id
+          | _ -> raise (Stream.Error "")
+          end
+      | _ -> raise (Stream.Error "")
+      end
+  | _ -> camlize s
+
+let next_attr (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Kwd "/") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (Ident id) ->
+          Stream.junk strm__;
+          let ids =
+            try star ~acc:[id] ident strm__ with
+              Stream.Failure -> raise (Stream.Error "")
+          in
+          String.concat ~sep:"" ids
+      | _ -> raise (Stream.Error "")
+      end
+  | _ -> raise Stream.Failure
+
+let attributes =
+  ["Read"; "Write"; "Construct"; "ConstructOnly"; "NoSet"; "Set"; "NoWrap";
+   "Wrap"; "NoGet"; "VSet"; "NoVSet"]
+
+let label_type2 id (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Kwd ":") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (Ident ty) -> Stream.junk strm__; id, ty
+      | _ -> raise (Stream.Error "")
+      end
+  | _ -> "", id
+let label_type (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Ident id) ->
+      Stream.junk strm__;
+      begin try label_type2 id strm__ with
+        Stream.Failure -> raise (Stream.Error "")
+      end
+  | _ -> raise Stream.Failure
+
+type marshal =
+    Function of string
+  | Types of (string list * string list * string)
+
+let return_type (l, types) (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Kwd "->") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (Ident ret) -> Stream.junk strm__; Types (l, types, ret)
+      | _ -> raise (Stream.Error "")
+      end
+  | _ -> Types (l, types, "")
+
+let marshaller (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (String s) -> Stream.junk strm__; Function s
+  | Some (Kwd ":") ->
+      Stream.junk strm__;
+      let types =
+        try star label_type strm__ with
+          Stream.Failure -> raise (Stream.Error "")
+      in
+      let s = strm__ in return_type (List.split types) s
+  | _ -> Types ([], [], "")
+
+let simple_attr (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Kwd "/") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (Ident s) -> Stream.junk strm__; s
+      | _ -> raise (Stream.Error "")
+      end
+  | _ -> raise Stream.Failure
+
+let field (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (String name) ->
+      Stream.junk strm__;
+      let mlname =
+        try may_name name strm__ with
+          Stream.Failure -> raise (Stream.Error "")
+      in
+      begin match Stream.peek strm__ with
+        Some (Ident gtype) ->
+          Stream.junk strm__;
+          begin match Stream.peek strm__ with
+            Some (Kwd ":") ->
+              Stream.junk strm__;
+              begin match Stream.peek strm__ with
+                Some (Ident attr0) ->
+                  Stream.junk strm__;
+                  let attrs =
+                    try star ~acc:[attr0] next_attr strm__ with
+                      Stream.Failure -> raise (Stream.Error "")
+                  in
+                  if not (List.for_all attrs ~f:(List.mem ~set:attributes))
+                  then
+                    raise (Stream.Error "bad attribute");
+                  `Prop (name, mlname, gtype, attrs)
+              | _ -> raise (Stream.Error "")
+              end
+          | _ -> raise (Stream.Error "")
+          end
+      | _ -> raise (Stream.Error "")
+      end
+  | Some (Kwd "method") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (Ident name) ->
+          Stream.junk strm__;
+          let ty =
+            try may_colon string "unit" strm__ with
+              Stream.Failure -> raise (Stream.Error "")
+          in
+          let attrs =
+            try star simple_attr strm__ with
+              Stream.Failure -> raise (Stream.Error "")
+          in
+          if not (List.for_all attrs ~f:(List.mem ~set:["Wrap"])) then
+            raise (Stream.Error "bad attribute");
+          `Method (name, ty, attrs)
+      | _ -> raise (Stream.Error "")
+      end
+  | Some (Kwd "signal") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (Ident name) ->
+          Stream.junk strm__;
+          let m =
+            try marshaller strm__ with
+              Stream.Failure -> raise (Stream.Error "")
+          in
+          let l =
+            try star simple_attr strm__ with
+              Stream.Failure -> raise (Stream.Error "")
+          in
+          if not (List.for_all l ~f:(List.mem ~set:["Wrap"; "NoWrap"])) then
+            raise (Stream.Error "bad attribute");
+          `Signal (name, m, l)
+      | _ -> raise (Stream.Error "")
+      end
+  | _ -> raise Stream.Failure
+
+let split_fields l =
+  List.fold_right l ~init:([], [], [])
+    ~f:(fun field (props, meths, sigs) ->
+       match field with
+         `Prop p -> p :: props, meths, sigs
+       | `Method m -> props, m :: meths, sigs
+       | `Signal s -> props, meths, s :: sigs)
+
+let verb_braces = ref 0
+
+let rec verbatim buf (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some '}' ->
+      Stream.junk strm__;
+      let s = strm__ in
+      if !verb_braces = 0 then Buffer.contents buf
+      else begin decr verb_braces; Buffer.add_char buf '}'; verbatim buf s end
+  | Some '{' ->
+      Stream.junk strm__;
+      let s = strm__ in
+      Buffer.add_char buf '{'; incr verb_braces; verbatim buf s
+  | Some '\\' ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some c ->
+          Stream.junk strm__;
+          let s = strm__ in
+          if c <> '}' && c <> '{' then Buffer.add_char buf '\\';
+          Buffer.add_char buf c;
+          verbatim buf s
+      | _ -> raise (Stream.Error "")
+      end
+  | Some c ->
+      Stream.junk strm__;
+      let s = strm__ in Buffer.add_char buf c; verbatim buf s
+  | _ -> raise Stream.Failure
+
+let read_pair (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Ident cls) ->
+      Stream.junk strm__;
+      let data =
+        try may_string (camlize cls) strm__ with
+          Stream.Failure -> raise (Stream.Error "")
+      in
+      cls, data
+  | _ -> raise Stream.Failure
+
+let qualifier (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Ident id) ->
+      Stream.junk strm__;
+      let data =
+        try may_string "" strm__ with
+          Stream.Failure -> raise (Stream.Error "")
+      in
+      id, data
+  | _ -> raise Stream.Failure
+
+let prefix = ref ""
+let tagprefix = ref ""
+let decls = ref []
+let headers = ref []
+let oheaders = ref []
+let initializers = ref []
+let checks = ref false
+let class_qualifiers =
+  ["abstract"; "notype"; "hv"; "set"; "wrap"; "wrapset"; "vset"; "tag";
+   "wrapsig"; "type"; "gobject"]
+
+let process_phrase ~chars (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Ident "class") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (Ident name) ->
+          Stream.junk strm__;
+          let gtk_name =
+            try may_string (!prefix ^ name) strm__ with
+              Stream.Failure -> raise (Stream.Error "")
+          in
+          let attrs =
+            try star qualifier strm__ with
+              Stream.Failure -> raise (Stream.Error "")
+          in
+          let parent =
+            try may_colon ident "" strm__ with
+              Stream.Failure -> raise (Stream.Error "")
+          in
+          begin match Stream.peek strm__ with
+            Some (Kwd "{") ->
+              Stream.junk strm__;
+              let fields =
+                try star field strm__ with
+                  Stream.Failure -> raise (Stream.Error "")
+              in
+              begin match Stream.peek strm__ with
+                Some (Kwd "}") ->
+                  Stream.junk strm__;
+                  if List.exists attrs
+                       ~f:(fun (x, _) -> not (List.mem x ~set:class_qualifiers))
+                  then
+                    raise (Stream.Error "bad qualifier");
+                  let attrs = ("parent", parent) :: attrs in
+                  let attrs =
+                    if parent = "GObject" then ("gobject", "") :: attrs
+                    else attrs
+                  in
+                  let (props, meths, sigs) = split_fields fields in
+                  decls :=
+                    (name, gtk_name, attrs, props, meths, sigs) :: !decls
+              | _ -> raise (Stream.Error "")
+              end
+          | _ -> raise (Stream.Error "")
+          end
+      | _ -> raise (Stream.Error "")
+      end
+  | Some (Ident "initializer") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (String func) ->
+          Stream.junk strm__; initializers := !initializers @ [func]
+      | _ -> raise (Stream.Error "")
+      end
+  | Some (Ident "header") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (Kwd "{") ->
+          Stream.junk strm__;
+          let h = verbatim (Buffer.create 1000) chars in
+          headers := !headers @ [h]
+      | _ -> raise (Stream.Error "")
+      end
+  | Some (Ident "oheader") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (Kwd "{") ->
+          Stream.junk strm__;
+          let h = verbatim (Buffer.create 1000) chars in
+          oheaders := !oheaders @ [h]
+      | _ -> raise (Stream.Error "")
+      end
+  | Some (Ident "prefix") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (String id) -> Stream.junk strm__; prefix := id
+      | _ -> raise (Stream.Error "")
+      end
+  | Some (Ident "tagprefix") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (String id) -> Stream.junk strm__; tagprefix := id
+      | _ -> raise (Stream.Error "")
+      end
+  | Some (Ident "conversions") ->
+      Stream.junk strm__;
+      let pre1 =
+        try may_string "" strm__ with
+          Stream.Failure -> raise (Stream.Error "")
+      in
+      let pre2 =
+        try may_string pre1 strm__ with
+          Stream.Failure -> raise (Stream.Error "")
+      in
+      begin match Stream.peek strm__ with
+        Some (Kwd "{") ->
+          Stream.junk strm__;
+          let l =
+            try star read_pair strm__ with
+              Stream.Failure -> raise (Stream.Error "")
+          in
+          begin match Stream.peek strm__ with
+            Some (Kwd "}") ->
+              Stream.junk strm__;
+              List.iter l
+                ~f:(fun (k, d) ->
+                   Hashtbl.add conversions ~key:(pre1 ^ k)
+                     ~data:(if pre2 = "" then d else pre2 ^ "." ^ d))
+          | _ -> raise (Stream.Error "")
+          end
+      | _ -> raise (Stream.Error "")
+      end
+  | Some (Ident "classes") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (Kwd "{") ->
+          Stream.junk strm__;
+          let l =
+            try star read_pair strm__ with
+              Stream.Failure -> raise (Stream.Error "")
+          in
+          begin match Stream.peek strm__ with
+            Some (Kwd "}") ->
+              Stream.junk strm__;
+              List.iter l ~f:(fun (k, d) -> add_object k d)
+          | _ -> raise (Stream.Error "")
+          end
+      | _ -> raise (Stream.Error "")
+      end
+  | Some (Ident "boxed") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (Kwd "{") ->
+          Stream.junk strm__;
+          let l =
+            try star read_pair strm__ with
+              Stream.Failure -> raise (Stream.Error "")
+          in
+          begin match Stream.peek strm__ with
+            Some (Kwd "}") ->
+              Stream.junk strm__; List.iter l ~f:(fun (k, d) -> add_boxed k d)
+          | _ -> raise (Stream.Error "")
+          end
+      | _ -> raise (Stream.Error "")
+      end
+  | Some _ -> Stream.junk strm__; raise (Stream.Error "")
+  | _ -> raise End_of_file
+
+let all_props = Hashtbl.create 137
+let all_pnames = Hashtbl.create 137
+let outfile = ref ""
+let ooutfile = ref ""
+
+let process_file f =
+  let base = Filename.chop_extension f in
+  let baseM = String.capitalize_ascii base in
+  prefix := baseM;
+  (* Input *)
+  (* Redefining saves space in bytecode! *)
+  headers := ["open Gobject"; "open Data"; "module Object = GtkObject"];
+  oheaders :=
+    ["open GtkSignal"; "open Gobject"; "open Data"; "let set = set";
+     "let get = get"; "let param = param"];
+  let ic = open_in f in
+  let chars = Stream.of_channel ic in
+  let s = lexer chars in
+  begin try while true do process_phrase ~chars s done with
+    End_of_file -> ()
+  | Stream.Error _ | Stream.Failure ->
+      Printf.eprintf "Parse error in file `%s' before char %d\n" f
+        (Stream.count chars);
+      exit 2
+  | exn ->
+      Printf.eprintf "Exception %s in file `%s' before char %d\n"
+        (Printexc.to_string exn) f (Stream.count chars);
+      exit 2
+  end;
+  (* Preproccess *)
+  let type_name name ~attrs =
+    try List.assoc "type" attrs with
+      Not_found ->
+        if List.mem_assoc "gobject" ~map:attrs then camlize name
+        else if !prefix <> "" then !prefix ^ "." ^ camlize name ^ " obj"
+        else camlize name ^ " obj"
+  in
+  let decls = List.rev !decls in
+  let decls =
+    List.filter decls
+      ~f:(fun (_, _, attrs, _, _, _) -> not (List.mem_assoc "notype" ~map:attrs))
+  in
+  List.iter decls
+    ~f:(fun (name, gtk_name, attrs, _, _, _) ->
+       add_object gtk_name (type_name name ~attrs));
+  (* Output modules *)
+  if !outfile = "" then outfile := base ^ "Props.ml";
+  let oc = open_out !outfile in
+  let ppf = Format.formatter_of_out_channel oc in
+  let out fmt = Format.fprintf ppf fmt in
+  List.iter !headers ~f:(fun s -> out "%s@." s);
+  List.iter !initializers
+    ~f:(fun s ->
+       out "external %s : unit -> unit = \"%s\"@." s s;
+       out "let () = %s ()@." s);
+  let decls =
+    List.map decls
+      ~f:(fun (name, gtk_name, attrs, props, meths, sigs) ->
+         name, gtk_name, attrs,
+         List.filter props
+           ~f:(fun (name, _, gtype, _) ->
+              try
+                ignore (Hashtbl.find conversions gtype);
+                try
+                  let (count, _) = Hashtbl.find all_props (name, gtype) in
+                  incr count; true
+                with Not_found ->
+                  Hashtbl.add all_props ~key:(name, gtype)
+                    ~data:(ref 1, ref "");
+                  true
+              with Not_found ->
+                prerr_endline
+                  ("Warning: no conversion for type " ^ gtype ^ " in class " ^
+                   gtk_name);
+                false),
+         meths,
+         List.filter sigs
+           ~f:(function
+              _, Function _, _ -> true
+            | _, Types (_, l, ret), _ ->
+                List.for_all (if ret = "" then l else ret :: l)
+                  ~f:(fun ty ->
+                     if Hashtbl.mem conversions ty then true
+                     else
+                       begin
+                         prerr_endline
+                           ("Warning: no conversion for type " ^ ty ^
+                            " in class " ^ gtk_name);
+                         false
+                       end)))
+  in
+  let defprop ~name ~mlname ~gtype ~tag =
+    let conv = Hashtbl.find conversions gtype in
+    out "@ @[<hv2>let %s " mlname;
+    if tag <> "gtk" then out ": ([>`%s],_) property " tag;
+    out "=@ @[<hov1>{name=\"%s\";@ conv=%s}@]@]" name conv
+  in
+  let shared_props =
+    Hashtbl.fold all_props ~init:[]
+      ~f:(fun ~key:(name, gtype) ~data:(count, rpname) acc ->
+         if !count <= 1 then acc
+         else
+           let pname = camlize name in
+           let pname =
+             if Hashtbl.mem all_pnames pname then pname ^ "_" ^ gtype
+             else begin Hashtbl.add all_pnames ~key:pname ~data:(); pname end
+           in
+           rpname := "PrivateProps." ^ pname; (pname, name, gtype) :: acc)
+  in
+  if shared_props <> [] then
+    begin
+      out "@[<hv2>module PrivateProps = struct";
+      List.iter (List.sort ~cmp:compare shared_props)
+        ~f:(fun (pname, name, gtype) -> defprop ~name ~mlname:pname ~gtype ~tag:"gtk");
+      out "@]\nend\n@."
+    end;
+  (* Redefining saves space in bytecode! *)
+  out "let may_cons = Property.may_cons\n";
+  out "let may_cons_opt = Property.may_cons_opt\n@.";
+  let may_cons_props props =
+    if props <> [] then
+      begin
+        out "@ @[<hv2>let pl = ";
+        List.iter props
+          ~f:(fun (name, mlname, gtype, _) ->
+             let op =
+               if check_suffix gtype "_opt" then "may_cons_opt"
+               else "may_cons"
+             in
+             out "(@;<0>%s P.%s %s " op (camlize name) mlname);
+        out "pl";
+        for _k = 1 to List.length props do out ")" done;
+        out " in@]"
+      end
+  in
+  let omarshaller ~gtk_class ~name ppf (l, tyl, ret) =
+    let out fmt = Format.fprintf ppf fmt in
+    out "fun f ->@ @[<hov2>marshal%d" (List.length l);
+    if ret <> "" then out "_ret@ ~ret:%s" (Hashtbl.find conversions ret);
+    List.iter tyl ~f:(fun ty -> out "@ %s" ty);
+    out "@ \"%s::%s\"" gtk_class name;
+    if List.for_all l ~f:((=) "") then out " f"
+    else
+      begin let l = min_labelled l in
+        out "@ @[<hov2>(fun ";
+        for i = 1 to List.length l do out "x%d " i done;
+        out "->@ f";
+        let i = ref 0 in
+        List.iter l
+          ~f:(fun p -> incr i; if p = "" then out "@ x%d" !i else out "@ ~%s:x%d" p !i);
+        out ")@]"
+      end;
+    out "@]"
+  in
+  List.iter decls
+    ~f:(fun (name, gtk_class, attrs, props, meths, sigs) ->
+       out "@[<hv2>module %s = struct" (camlizeM name);
+       out "@ @[<hv2>let cast w : %s =@ try_cast w \"%s\"@]"
+         (type_name name ~attrs) gtk_class;
+       let tag =
+         try List.assoc "tag" attrs with
+           Not_found -> !tagprefix ^ String.lowercase_ascii name
+       in
+       if props <> [] then
+         begin
+           out "@ @[<hv2>module P = struct";
+           List.iter props
+             ~f:(fun (name, _, gtype, _attrs) ->
+                let (count, rpname) = Hashtbl.find all_props (name, gtype) in
+                if !count > 1 then
+                  out "@ let %s : ([>`%s],_) property = %s" (camlize name) tag
+                    !rpname
+                else defprop ~name ~mlname:(camlize name) ~gtype ~tag);
+           out "@]@ end"
+         end;
+       if sigs <> [] then
+         begin
+           out "@ @[<hv2>module S = struct@ open GtkSignal";
+           List.iter sigs
+             ~f:(fun (name, marshaller, _) ->
+                out "@ @[<hv2>let %s =" (camlize name);
+                out "@ @[<hov1>{name=\"%s\";@ classe=`%s;@ marshaller=" name
+                  tag;
+                begin match marshaller with
+                  Function s -> out "%s" s
+                | Types ([], [], "") -> out "marshal_unit"
+                | Types ([], [], ret) ->
+                    out "fun f -> marshal0_ret ~ret:%s f"
+                      (Hashtbl.find conversions ret)
+                | Types (l, tyl, ret) ->
+                    omarshaller ~gtk_class ~name ppf
+                      (l, List.map ~f:(Hashtbl.find conversions) tyl, ret)
+                end;
+                out "}@]@]");
+           out "@]@ end"
+         end;
+       if not (List.mem_assoc "abstract" ~map:attrs) then
+         begin let cprops =
+           List.filter props
+             ~f:(fun (_, _, _, a) ->
+                List.mem "ConstructOnly" ~set:a &&
+                not (List.mem "NoSet" ~set:a))
+         in
+           out "@ @[<hv2>let create";
+           List.iter cprops ~f:(fun (_, name, _, _) -> out " ?%s" name);
+           if List.mem_assoc "hv" ~map:attrs then
+             begin
+               out " (dir : Gtk.Tags.orientation) pl : %s ="
+                 (type_name name ~attrs);
+               may_cons_props cprops;
+               out "@ @[<hov2>Object.make";
+               out
+                 "@ (if dir = `HORIZONTAL then \"%sH%s\" else \"%sV%s\")@  pl"
+                 !prefix name !prefix name;
+               out "@]@]"
+             end
+           else
+             begin
+               out " pl : %s =" (type_name name ~attrs);
+               may_cons_props cprops;
+               if List.mem_assoc "gobject" ~map:attrs then
+                 out "@ Gobject.unsafe_create"
+               else out "@ Object.make";
+               out " \"%s\" pl@]" gtk_class
+             end
+         end;
+       List.iter meths
+         ~f:(fun (name, typ, _attrs) ->
+            out "@ @[<hov2>external %s :" name;
+            out "@ @[<hv>[>`%s] obj ->@ %s@]" tag typ;
+            let cname = camlize ("ml" ^ gtk_class) ^ "_" ^ name in
+            out "@ = \"";
+            if arity typ > 4 then out "%s_bc\" \"" cname;
+            out "%s\"@]" cname);
+       let set_props =
+         let set = List.mem_assoc "set" ~map:attrs in
+         List.filter props
+           ~f:(fun (_, _, _, a) ->
+              (set || List.mem "Set" ~set:a) && List.mem "Write" ~set:a &&
+              not
+                (List.mem "ConstructOnly" ~set:a || List.mem "NoSet" ~set:a))
+       in
+       if set_props <> [] then
+         begin let props = set_props in
+           out "@ @[<hv2>@[<hov4>let make_params ~cont pl";
+           List.iter props ~f:(fun (_, name, _, _) -> out "@ ?%s" name);
+           out " =@]";
+           may_cons_props props;
+           out "@ cont pl@]"
+         end;
+       if !checks && (props <> [] || sigs <> []) then
+         begin
+           if List.mem_assoc "abstract" ~map:attrs then
+             out "@ @[<hv2>let check w ="
+           else
+             begin
+               out "@ @[<hv2>let check () =";
+               out "@ let w = create%s [] in"
+                 (if List.mem_assoc "hv" ~map:attrs then " `HORIZONTAL"
+                  else "")
+             end;
+           if props <> [] then out "@ let c p = Property.check w p in";
+           if sigs <> [] then
+             begin
+               out "@ let closure = Closure.create ignore in";
+               out "@ let s name = GtkSignal.connect_by_name";
+               out " w ~name ~closure ~after:false in"
+             end;
+           out "@ @[<hov>";
+           List.iter props
+             ~f:(fun (name, _, _gtype, attrs) ->
+                if List.mem "Read" ~set:attrs then
+                  out "c P.%s;@ " (camlize name));
+           List.iter sigs ~f:(fun (name, _, _) -> out "s %s;@ " name);
+           out "()@]"
+         end;
+       out "@]@.end\n@.");
+  close_out oc;
+  (* Output classes *)
+  if !ooutfile = "" then ooutfile := "o" ^ !outfile;
+  let oc = open_out !ooutfile in
+  let ppf = Format.formatter_of_out_channel oc in
+  let out fmt = Format.fprintf ppf fmt in
+  List.iter !oheaders ~f:(fun s -> out "%s@." s);
+  out "open %s@."
+    (String.capitalize_ascii (Filename.chop_extension !outfile));
+  out "@[<hv>";
+  let oprop ~name ~gtype ppf pname =
+    try
+      let conv = List.assoc gtype specials in
+      Format.fprintf ppf "{%s.P.%s with conv=%s}" (camlizeM name)
+        (camlize pname) conv
+    with Not_found ->
+      Format.fprintf ppf "%s.P.%s" (camlizeM name) (camlize pname)
+  in
+  List.iter decls
+    ~f:(fun (name, gtk_class, attrs, props, meths, sigs) ->
+       let wrap = List.mem_assoc "wrap" ~map:attrs in
+       let wrapset = wrap || List.mem_assoc "wrapset" ~map:attrs in
+       let wr_props =
+         List.filter props
+           ~f:(fun (_, _, _, set) ->
+              let has = List.mem ~set in
+              (wrapset || has "Wrap") && has "Write" &&
+              not (has "ConstructOnly" || has "NoWrap"))
+       and rd_props =
+         List.filter props
+           ~f:(fun (_, _, _, set) ->
+              let has = List.mem ~set in
+              (wrap || has "Wrap") && has "Read" &&
+              not (has "NoWrap" || has "NoGet"))
+       and wr_meths =
+         List.filter meths
+           ~f:(fun (_, _, attrs) -> List.mem "Wrap" ~set:attrs)
+       in
+       if wr_props <> [] || rd_props <> [] || wr_meths <> [] then
+         begin
+           (* pre 3.10
+           out "@ @[<hv2>class virtual %s_props = object (self)" (camlize name);
+           out "@ method private virtual obj : _ obj";
+           List.iter wr_props ~f:(fun (pname,mlname,gtype,_) ->
+             out "@ @[<hv2>method set_%s =@ set %a self#obj@]"
+               mlname (oprop ~name ~gtype) pname);
+           List.iter rd_props ~f:(fun (pname,mlname,gtype,_) ->
+             out "@ @[<hv2>method %s =@ get %a self#obj@]"
+               mlname (oprop ~name ~gtype) pname);
+           List.iter wr_meths ~f:(fun (mname,typ,_) ->
+             out "@ @[<hv2>method %s %s=@ %s.%s self#obj@]"
+               mname (if typ = "unit" then "() " else "") (camlizeM name) mname);
+           *)
+           (* post 3.10 *)
+           out "@ @[<hv2>class virtual %s_props = object" (camlize name);
+           out "@ val virtual obj : _ obj";
+           List.iter wr_props
+             ~f:(fun (pname, mlname, gtype, _) ->
+                out "@ @[<hv2>method set_%s =@ set %a obj@]" mlname
+                  (oprop ~name ~gtype) pname);
+           List.iter rd_props
+             ~f:(fun (pname, mlname, gtype, _) ->
+                out "@ @[<hv2>method %s =@ get %a obj@]" mlname
+                  (oprop ~name ~gtype) pname);
+           List.iter wr_meths
+             ~f:(fun (mname, typ, _) ->
+                out "@ @[<hv2>method %s %s=@ %s.%s obj@]" mname
+                  (if typ = "unit" then "() " else "") (camlizeM name) mname);
+           out "@]@ end@ "
+         end;
+       let vset = List.mem_assoc "vset" ~map:attrs in
+       let vprops =
+         List.filter props
+           ~f:(fun (_, _, _, set) ->
+              let has = List.mem ~set in
+              (vset || has "VSet") && has "Write" &&
+              not (has "ConstructOnly" || has "NoVSet"))
+       in
+       if vprops <> [] then
+         begin
+           out "@ @[<hv2>let %s_param = function" (camlize name);
+           List.iter vprops
+             ~f:(fun (pname, mlname, gtype, _) ->
+                out "@ @[<hv4>| `%s p ->@ param %a p@]"
+                  (String.uppercase_ascii mlname) (oprop ~name ~gtype) pname);
+           out "@]@ "
+         end;
+       let wsig = List.mem_assoc "wrapsig" ~map:attrs in
+       let wsigs =
+         List.filter sigs
+           ~f:(fun (_, _, attrs) ->
+              List.mem "Wrap" ~set:attrs ||
+              wsig && not (List.mem "NoWrap" ~set:attrs))
+       in
+       if wsigs <> [] then
+         begin
+           out "@ @[<hv2>class virtual %s_sigs = object (self)"
+             (camlize name);
+           out "@ @[<hv2>method private virtual connect :";
+           out "@ 'b. ('a,'b) GtkSignal.t -> callback:'b -> GtkSignal.id@]";
+           out "@ @[<hv2>method private virtual notify :";
+           out
+             "@ 'b. ('a,'b) property -> callback:('b -> unit) -> GtkSignal.id@]";
+           List.iter wsigs
+             ~f:(fun (sname, types, _) ->
+                match types with
+                  Types (l, tyl, ret)
+                  when List.exists tyl ~f:(List.mem_assoc ~map:specials) ->
+                    let convs =
+                      List.map tyl
+                        ~f:(fun ty ->
+                           try List.assoc ty specials with
+                             Not_found -> Hashtbl.find conversions ty)
+                    in
+                    out "@ @[<hov2>method %s =@ self#connect" sname;
+                    out "@ @[<hov1>{%s.S.%s with@ marshaller = %a}@]@]"
+                      (camlizeM name) sname
+                      (omarshaller ~gtk_class ~name:sname) (l, convs, ret)
+                | _ ->
+                    out "@ @[<hv2>method %s =@ self#connect %s.S.%s@]" sname
+                      (camlizeM name) sname);
+           (* notify: easy connection to "foo::notify" signals for "foo"
+            * properties. *)
+           List.iter rd_props
+             ~f:(fun (pname, mlname, gtype, _) ->
+                out "@ @[<hov2>method notify_%s ~callback =" mlname;
+                out "@ @[<hov1>self#notify %a ~callback@]@]"
+                  (oprop ~name ~gtype) pname);
+           out "@]@ end@ "
+         end);
+  out "@.";
+  close_out oc;
+  outfile := "";
+  ooutfile := ""
+
+let main () =
+  Arg.parse
+    ["-checks", Arg.Set checks, "generate code for checks";
+     "-o", Arg.String (fun s -> outfile := s), "basic output file name";
+     "-oo", Arg.String (fun s -> ooutfile := s), "wrappers output file name"]
+    process_file "usage: propcc <options> file.props ..."
+
+let () = Printexc.print main ()
diff --git a/lablgtk3/lablgen/propcc.ml4 b/lablgtk3/lablgen/propcc.ml4
new file mode 100644
index 0000000..98cc0d7
--- /dev/null
+++ b/lablgtk3/lablgen/propcc.ml4
@@ -0,0 +1,688 @@
+(* -*- caml -*- *)
+(* $Id$ *)
+
+open StdLabels
+open MoreLabels
+
+let caml_keywords = ["type","kind"; "class","classe"; "list", "liste"]
+let caml_modules = ["List", "Liste"]
+
+let is_not_uppercase = function
+  | 'A' .. 'Z' -> false
+  | _ -> true
+let camlize id =
+  let b = Buffer.create (String.length id + 4) in
+  for i = 0 to String.length id - 1 do
+    match id.[i] with
+    | 'A' .. 'Z' as c ->
+	if i > 0 && 
+	  (is_not_uppercase id.[i-1] || 
+	  (i < String.length id - 1 && is_not_uppercase id.[i+1]))
+	then Buffer.add_char b '_' ;
+	Buffer.add_char b (Char.lowercase_ascii c)
+    | '-' ->
+	Buffer.add_char b '_'
+    | c ->
+	Buffer.add_char b c
+  done;
+  let s = Buffer.contents b in
+  try List.assoc s caml_keywords with Not_found -> s
+
+let camlizeM s =
+  try List.assoc s caml_modules with Not_found -> s
+
+let check_suffix s suff =
+  let len1 = String.length s and len2 = String.length suff in
+  len1 > len2 && String.sub s ~pos:(len1-len2) ~len:len2 = suff
+
+(* Arity of a caml type. Doesn't handle object types... *)
+let arity s =
+  let parens = ref 0 and arity = ref 0 in
+  for i = 0 to String.length s - 1 do
+    if s.[i] = '(' || s.[i] = '[' then incr parens else
+    if s.[i] = ')' || s.[i] = ']' then decr parens else
+    if !parens = 0 && s.[i] = '-' && s.[i+1] = '>' then incr arity
+  done;
+  if !parens <> 0 then failwith ("bad type : " ^ s);
+  !arity
+
+let rec min_labelled = function
+  | [] -> []
+  | a :: l ->
+      let l = min_labelled l in
+      if l = [] && a = "" then [] else a::l
+
+
+(* The real data *)
+let conversions = Hashtbl.create 17
+
+let enums = [
+  "Gtk", "GtkEnums",
+  [ "Justification"; "Align"; "ArrowType"; "ShadowType"; "ResizeMode";
+    "ReliefStyle"; "ImageType"; "WindowType"; "WindowPosition";
+    "ButtonsType"; "MessageType"; "ButtonBoxStyle"; "PositionType";
+    "Orientation"; "ToolbarStyle"; "IconSize"; "PolicyType"; "CornerType";
+    "SelectionMode"; "SortType"; "WrapMode"; "SpinButtonUpdatePolicy";
+    "UpdateType"; "ProgressBarStyle"; "ProgressBarOrientation";
+    "CellRendererMode"; "CellRendererAccelMode"; "TreeViewColumnSizing";
+    "SortType"; "TextDirection"; "SizeGroupMode"; "StackTransitionType"; (* in signals *)
+    "MovementStep"; "ScrollStep"; "ScrollType"; "MenuDirectionType";
+    "DeleteType"; "StateType"; (* for canvas *) "AnchorType";
+    "DirectionType"; "SensitivityType"; "InputHints"; "InputPurpose";
+    "EntryIconPosition"; "PackDirection"; "TreeViewGridLines";
+    "FileChooserAction"; "FileChooserConfirmation"; "Response"
+  ];
+  "Gdk", "GdkEnums",
+  [ "ExtensionMode"; "WindowTypeHint"; "EventMask"; "Gravity";
+    (* for canvas *) "CapStyle"; "JoinStyle"; "LineStyle" ];
+  "Pango", "PangoEnums",
+  [ "Stretch"; "Style"; "Underline"; "Variant"; "EllipsizeMode" ];
+  (* GtkSourceView *)
+  "Gtk", "SourceView2Enums",
+  [ "SourceSmartHomeEndType"; "SourceDrawSpacesFlags" ];
+  "Gtk3", "SourceView3Enums",
+  [ "SourceSmartHomeEndType"; "SourceDrawSpacesFlags" ]
+
+]
+
+(* These types must be registered with g_boxed_register! *)
+let boxeds = [
+  "Gdk", ["Color"; "Font"; "RGBA"; "Cairo"];
+  "Pango", ["FontDescription";];
+  "Gtk", ["IconSet";"SelectionData";"TextIter";"TreePath"; "TreeIter";];
+]
+
+let classes = [
+  "Gdk", [ "Image"; "Pixmap"; "Bitmap"; "Screen"; "DragContext";];
+  "Gtk", [ "Style"; "TreeStore"; "TreeModel"; "TreeModelFilter"; "Tooltip" ]
+]
+
+let specials = [
+  "GtkWidget", "GObj.conv_widget";
+  "GtkWidget_opt", "GObj.conv_widget_option";
+  "GtkAdjustment", "GData.conv_adjustment";
+  "GtkAdjustment_opt", "GData.conv_adjustment_option";
+]
+
+let add_pointer conv gtk name =
+  Hashtbl.add conversions ~key:gtk
+    ~data:(Printf.sprintf "(%s : %s data_conv)" conv name);
+  Hashtbl.add conversions ~key:(gtk ^ "_opt")
+    ~data:(Printf.sprintf "(%s_option : %s option data_conv)" conv name)
+
+let add_object = add_pointer "gobject"
+let add_boxed = add_pointer "unsafe_pointer" (* the type is not used *)
+
+let () =
+  List.iter ~f:(fun t -> Hashtbl.add conversions ~key:("g"^t) ~data:t)
+    [ "boolean"; "char"; "uchar"; "int"; "uint"; "long"; "ulong";
+      "int32"; "uint32"; "int64"; "uint64"; "float"; "double" ];
+  List.iter ~f:(fun (gtype,conv) -> Hashtbl.add conversions ~key:gtype ~data:conv)
+    [ "gchararray", "string";
+      "gchararray_opt", "string_option";
+      "string", "string"; "bool", "boolean"; "int", "int";
+      "int32", "int32"; "float", "float";
+    ];
+  List.iter enums ~f:(fun (pre, modu, l) ->
+    List.iter l ~f:
+      begin fun name ->
+        Hashtbl.add conversions ~key:(pre ^ name)
+          ~data:(Printf.sprintf "%s.Conv.%s" modu (camlize name))
+      end);
+  List.iter boxeds ~f:(fun (pre, l) ->
+    List.iter l ~f:(fun name -> add_boxed (pre^name) (pre^"."^camlize name)));
+  List.iter classes ~f:(fun (pre,l) ->
+    List.iter l ~f:(fun t -> add_object (pre^t) (pre^"."^camlize t)));
+  add_object "GObject" "unit obj";
+  add_object "GtkWidget" "Gtk.widget obj"
+
+open Genlex
+
+let lexer = make_lexer ["{"; "}"; ":"; "/"; "("; ")";"->";"method";"signal"]
+
+let rec star ?(acc=[]) p = parser
+    [< x = p ; s >] -> star ~acc:(x::acc) p s
+  | [< >] -> List.rev acc
+
+let may_token tok s =
+  if Stream.peek s = Some tok then Stream.junk s
+
+let ident = parser [< ' Ident id >] -> id
+
+let string = parser [< ' String s >] -> s
+
+let may_colon p def = parser
+  | [< ' Kwd":"; s >] -> p s
+  | [< >] -> def
+
+let may_string def = parser
+    [< ' String s >] -> s
+  | [< >] -> def
+
+let may_name s = parser
+    [< ' Kwd"("; ' Ident id; ' Kwd")" >] -> id
+  | [< >] -> (camlize s)
+
+let next_attr = parser
+    [< ' Kwd"/"; ' Ident id; ids = star ~acc:[id] ident >] ->
+      String.concat ~sep:"" ids
+
+let attributes =
+  ["Read";"Write";"Construct";"ConstructOnly";"NoSet";"Set";
+   "NoWrap";"Wrap";"NoGet";"VSet";"NoVSet"]
+
+let label_type2 id = parser
+  | [< ' Kwd":"; ' Ident ty >] -> (id,ty)
+  | [< >] -> ("",id)
+let label_type = parser
+    [< ' Ident id ; lty = label_type2 id >] -> lty
+
+type marshal =
+    Function of string | Types of (string list * string list * string)
+
+let return_type (l,types) = parser
+    [< ' Kwd"->"; ' Ident ret >] -> Types (l, types, ret)
+  | [< >] -> Types (l, types, "")
+
+let marshaller = parser
+  | [< ' String s >] -> Function s
+  | [< ' Kwd":"; types = star label_type; s >] ->
+      return_type (List.split types) s
+  | [< >] -> Types ([], [], "")
+
+let simple_attr = parser [< ' Kwd"/"; ' Ident s >] -> s
+
+let field = parser
+    [< ' String name; mlname = may_name name; ' Ident gtype; ' Kwd":";
+       ' Ident attr0; attrs = star ~acc:[attr0] next_attr >] ->
+         if not (List.for_all attrs ~f:(List.mem ~set:attributes)) then
+           raise (Stream.Error "bad attribute");
+         `Prop (name, mlname, gtype, attrs)
+  | [< ' Kwd"method"; ' Ident name; ty = may_colon string "unit";
+       attrs = star simple_attr >] ->
+         if not (List.for_all attrs ~f:(List.mem ~set:["Wrap"])) then
+           raise (Stream.Error "bad attribute");
+         `Method (name, ty, attrs)
+  | [< ' Kwd"signal"; ' Ident name; m = marshaller; l = star simple_attr >] ->
+      if not (List.for_all l ~f:(List.mem ~set:["Wrap";"NoWrap"])) then
+        raise (Stream.Error "bad attribute");
+      `Signal (name, m, l)
+
+let split_fields l =
+  List.fold_right l ~init:([],[],[]) ~f:
+    (fun field (props,meths,sigs) -> match field with
+      `Prop p   -> (p::props,meths,sigs)
+    | `Method m -> (props,m::meths,sigs)
+    | `Signal s -> (props,meths,s::sigs))
+
+let verb_braces = ref 0
+
+let rec verbatim buf = parser
+  | [< ''}' ; s >] ->
+      if !verb_braces = 0 then Buffer.contents buf else begin
+        decr verb_braces; Buffer.add_char buf '}'; verbatim buf s;
+      end
+  | [< ''{'; s >] ->
+      Buffer.add_char buf '{'; incr verb_braces; verbatim buf s
+  | [< ''\\' ; 'c ; s >] ->
+      if c <> '}' && c <> '{' then Buffer.add_char buf '\\';
+      Buffer.add_char buf c; verbatim buf s
+  | [< 'c ; s >] -> Buffer.add_char buf c; verbatim buf s
+
+let read_pair = parser
+  | [< ' Ident cls ; data = may_string (camlize cls) >] -> (cls,data)
+
+let qualifier = parser
+  | [< ' Ident id ; data = may_string "" >] -> (id,data)
+
+let prefix = ref ""
+let tagprefix = ref ""
+let decls = ref []
+let headers = ref []
+let oheaders = ref []
+let initializers = ref []
+let checks = ref false
+let class_qualifiers =
+  ["abstract";"notype";"hv";"set";"wrap";"wrapset";"vset";"tag";"wrapsig";
+   "type";"gobject";]
+
+let process_phrase ~chars = parser
+    [< ' Ident"class"; ' Ident name; gtk_name = may_string (!prefix ^ name);
+       attrs = star qualifier; parent = may_colon ident "";
+       ' Kwd"{"; fields = star field; ' Kwd"}" >] ->
+         if List.exists attrs ~f:
+             (fun (x,_) -> not (List.mem x ~set:class_qualifiers))
+         then raise (Stream.Error "bad qualifier");
+         let attrs = ("parent",parent) :: attrs in
+         let attrs =
+           if parent = "GObject" then ("gobject","")::attrs else attrs in
+         let props, meths, sigs = split_fields fields in
+         decls := (name, gtk_name, attrs, props, meths, sigs) :: !decls
+  | [< ' Ident"initializer"; ' String func >] ->
+      initializers := !initializers @ [func]
+  | [< ' Ident"header"; ' Kwd"{" >] ->
+      let h = verbatim (Buffer.create 1000) chars in
+      headers := !headers @ [h]
+  | [< ' Ident"oheader"; ' Kwd"{" >] ->
+      let h = verbatim (Buffer.create 1000) chars in
+      oheaders := !oheaders @ [h]
+  | [< ' Ident"prefix"; ' String id >] ->
+      prefix := id
+  | [< ' Ident"tagprefix"; ' String id >] ->
+      tagprefix := id
+  | [< ' Ident"conversions"; pre1 = may_string ""; pre2 = may_string pre1;
+       ' Kwd"{"; l = star read_pair; ' Kwd"}" >] ->
+      List.iter l ~f:(fun (k,d) ->
+        Hashtbl.add conversions ~key:(pre1^k) ~data:(if pre2="" then d else pre2^"."^d))
+  | [< ' Ident"classes"; ' Kwd"{"; l = star read_pair; ' Kwd"}" >] ->
+      List.iter l ~f:(fun (k,d) -> add_object k d)
+  | [< ' Ident"boxed"; ' Kwd"{"; l = star read_pair; ' Kwd"}" >] ->
+      List.iter l ~f:(fun (k,d) -> add_boxed k d)
+  | [< ' _ >] ->
+      raise (Stream.Error "")
+  | [< >] ->
+      raise End_of_file
+
+let all_props = Hashtbl.create 137
+let all_pnames = Hashtbl.create 137
+let outfile = ref ""
+let ooutfile = ref ""
+
+let process_file f =
+  let base = Filename.chop_extension f in
+  let baseM = String.capitalize_ascii base in
+  prefix := baseM;
+  (* Input *)
+  (* Redefining saves space in bytecode! *)
+  headers  := ["open Gobject"; "open Data";
+               "module Object = GtkObject"];
+  oheaders := ["open GtkSignal"; "open Gobject"; "open Data";
+               "let set = set"; "let get = get"; "let param = param"];
+  let ic = open_in f in
+  let chars = Stream.of_channel ic in
+  let s = lexer chars in
+  begin try while true do process_phrase ~chars s done with
+    End_of_file -> ()
+  | Stream.Error _ | Stream.Failure ->
+      Printf.eprintf "Parse error in file `%s' before char %d\n"
+        f (Stream.count chars);
+      exit 2
+  | exn ->
+      Printf.eprintf "Exception %s in file `%s' before char %d\n"
+        (Printexc.to_string exn) f (Stream.count chars);
+      exit 2
+  end;
+  (* Preproccess *)
+  let type_name name ~attrs =
+    try List.assoc "type" attrs with Not_found ->
+      if List.mem_assoc "gobject" ~map:attrs then camlize name
+      else if !prefix <> ""
+      then !prefix ^ "." ^ camlize name ^ " obj"
+      else camlize name ^ " obj"
+  in
+  let decls = List.rev !decls in
+  let decls = List.filter decls
+      ~f:(fun (_,_,attrs,_,_,_) -> not (List.mem_assoc "notype" ~map:attrs)) in
+  List.iter decls ~f:
+    (fun (name, gtk_name, attrs, _, _, _) ->
+      add_object gtk_name (type_name name ~attrs));
+  (* Output modules *)
+  if !outfile = "" then outfile := base ^ "Props.ml";
+  let oc = open_out !outfile in
+  let ppf = Format.formatter_of_out_channel oc in
+  let out fmt = Format.fprintf ppf fmt in
+  List.iter !headers ~f:(fun s -> out "%s@." s);
+  List.iter !initializers ~f:
+    (fun s ->
+      out "external %s : unit -> unit = \"%s\"@." s s;
+      out "let () = %s ()@." s);
+  let decls =
+    List.map decls ~f:
+      begin fun (name, gtk_name, attrs, props, meths, sigs) ->
+        (name, gtk_name, attrs,
+         List.filter props ~f:
+           begin fun (name,_,gtype,_) ->
+             try ignore (Hashtbl.find conversions gtype);
+               try
+                 let count, _ = Hashtbl.find all_props (name,gtype) in
+                 incr count;
+                 true
+               with Not_found ->
+                 Hashtbl.add all_props ~key:(name,gtype) ~data:(ref 1, ref ""); true
+             with Not_found ->
+               prerr_endline ("Warning: no conversion for type " ^ gtype ^
+                              " in class " ^ gtk_name);
+               false
+           end,
+         meths,
+         List.filter sigs ~f:
+           begin function
+           | _, Function _, _ -> true
+           | _, Types(_, l, ret), _ ->
+               List.for_all (if ret = "" then l else ret::l) ~f:
+                 (fun ty ->
+                   if Hashtbl.mem conversions ty then true else
+                   (prerr_endline ("Warning: no conversion for type " ^ ty ^
+                                   " in class " ^ gtk_name);
+                    false))
+           end)
+      end in
+  let defprop ~name ~mlname ~gtype ~tag =
+    let conv = Hashtbl.find conversions gtype in
+    out "@ @[<hv2>let %s " mlname;
+    if tag <> "gtk" then out ": ([>`%s],_) property " tag;
+    out "=@ @[<hov1>{name=\"%s\";@ conv=%s}@]@]" name conv
+  in
+  let shared_props =
+    Hashtbl.fold all_props ~init:[] ~f:
+      begin fun ~key:(name,gtype) ~data:(count,rpname) acc ->
+        if !count <= 1 then acc else
+        let pname = camlize name in
+        let pname =
+          if Hashtbl.mem all_pnames pname then pname ^ "_" ^ gtype
+          else (Hashtbl.add all_pnames ~key:pname ~data:(); pname) in
+        rpname := "PrivateProps." ^ pname;
+        (pname,name,gtype) :: acc
+      end
+  in
+  if shared_props <> [] then begin
+    out "@[<hv2>module PrivateProps = struct";
+    List.iter (List.sort ~cmp:compare shared_props) ~f:
+      (fun (pname,name,gtype) ->
+        defprop ~name ~mlname:pname ~gtype ~tag:"gtk");
+    out "@]\nend\n@.";
+  end;
+  (* Redefining saves space in bytecode! *)
+  out "let may_cons = Property.may_cons\n";
+  out "let may_cons_opt = Property.may_cons_opt\n@.";
+  let may_cons_props props =
+    if props <> [] then begin
+      out "@ @[<hv2>let pl = ";
+      List.iter props ~f:
+        begin fun (name,mlname,gtype,_) ->
+          let op =
+            if check_suffix gtype "_opt" then "may_cons_opt" else "may_cons"
+          in
+          out "(@;<0>%s P.%s %s " op (camlize name) mlname;
+        end;
+      out "pl";
+      for _k = 1 to List.length props do out ")" done;
+      out " in@]"
+    end
+  in
+  let omarshaller ~gtk_class ~name ppf (l,tyl,ret) =
+    let out fmt = Format.fprintf ppf fmt in
+    out "fun f ->@ @[<hov2>marshal%d" (List.length l);
+    if ret <> "" then
+      out "_ret@ ~ret:%s" (Hashtbl.find conversions ret);
+    List.iter tyl ~f:(fun ty -> out "@ %s" ty);
+    out "@ \"%s::%s\"" gtk_class name;
+    if List.for_all l ~f:((=) "") then out " f" else begin
+      let l = min_labelled l in
+      out "@ @[<hov2>(fun ";
+      for i = 1 to List.length l do out "x%d " i done;
+      out "->@ f";
+      let i = ref 0 in
+      List.iter l ~f:
+        (fun p ->
+          incr i; if p="" then out "@ x%d" !i else out "@ ~%s:x%d" p !i);
+      out ")@]";
+    end;
+    out "@]"
+  in
+  List.iter decls ~f:
+    begin fun (name, gtk_class, attrs, props, meths, sigs) ->
+      out "@[<hv2>module %s = struct" (camlizeM name);
+      out "@ @[<hv2>let cast w : %s =@ try_cast w \"%s\"@]"
+        (type_name name ~attrs) gtk_class;
+      let tag =
+        try List.assoc "tag" attrs
+        with Not_found -> !tagprefix ^ String.lowercase_ascii name
+      in
+      if props <> [] then begin
+        out "@ @[<hv2>module P = struct";
+        List.iter props ~f:
+          begin fun (name, _, gtype, _attrs) ->
+            let count, rpname = Hashtbl.find all_props (name,gtype) in
+            if !count > 1 then begin
+              out "@ let %s : ([>`%s],_) property = %s"
+                (camlize name) tag !rpname
+            end else
+              defprop ~name ~mlname:(camlize name) ~gtype ~tag
+          end;
+        out "@]@ end"
+      end;
+      if sigs <> [] then begin
+        out "@ @[<hv2>module S = struct@ open GtkSignal";
+        List.iter sigs ~f:
+          begin fun (name,marshaller,_) ->
+            out "@ @[<hv2>let %s =" (camlize name);
+            out "@ @[<hov1>{name=\"%s\";@ classe=`%s;@ marshaller="
+              name tag;
+            begin match marshaller with
+            | Function s -> out "%s" s
+            | Types ([], [], "") -> out "marshal_unit" 
+            | Types ([], [], ret) ->
+                out "fun f -> marshal0_ret ~ret:%s f"
+                  (Hashtbl.find conversions ret)
+            | Types (l, tyl, ret) ->
+                omarshaller ~gtk_class ~name ppf
+                  (l, List.map ~f:(Hashtbl.find conversions) tyl, ret)
+            end;
+            out "}@]@]";
+          end;
+        out "@]@ end";
+      end;
+      if not (List.mem_assoc "abstract" ~map:attrs) then begin
+        let cprops = List.filter props ~f:(fun (_,_,_,a) ->
+          List.mem "ConstructOnly" ~set:a && not (List.mem "NoSet" ~set:a)) in
+        out "@ @[<hv2>let create";
+        List.iter cprops ~f:(fun (_,name,_,_) -> out " ?%s" name);
+        if List.mem_assoc "hv" ~map:attrs then begin
+          out " (dir : Gtk.Tags.orientation) pl : %s ="
+            (type_name name ~attrs);
+          may_cons_props cprops;
+          out "@ @[<hov2>Object.make";
+          out "@ (if dir = `HORIZONTAL then \"%sH%s\" else \"%sV%s\")@  pl"
+            !prefix name !prefix name;
+          out "@]@]";
+        end else begin
+          out " pl : %s =" (type_name name ~attrs);
+          may_cons_props cprops;
+          if List.mem_assoc "gobject" ~map:attrs then
+            out "@ Gobject.unsafe_create"
+          else out "@ Object.make";
+           out " \"%s\" pl@]" gtk_class;
+        end
+      end;
+      List.iter meths ~f:
+        begin fun (name, typ, _attrs) ->
+          out "@ @[<hov2>external %s :" name;
+          out "@ @[<hv>[>`%s] obj ->@ %s@]" tag typ;
+          let cname = camlize ("ml" ^ gtk_class) ^ "_" ^ name in
+          out "@ = \"";
+          if arity typ > 4 then out "%s_bc\" \"" cname;
+          out "%s\"@]" cname;
+        end;
+      let set_props =
+        let set = List.mem_assoc "set" ~map:attrs in
+        List.filter props ~f:
+          (fun (_,_,_,a) ->
+            (set || List.mem "Set" ~set:a) && List.mem "Write" ~set:a &&
+            not (List.mem "ConstructOnly" ~set:a || List.mem "NoSet" ~set:a))
+      in
+      if set_props <> [] then begin
+        let props = set_props in
+        out "@ @[<hv2>@[<hov4>let make_params ~cont pl";
+        List.iter props ~f:(fun (_,name,_,_) -> out "@ ?%s" name);
+        out " =@]";
+        may_cons_props props;
+        out "@ cont pl@]";
+      end;
+      if !checks && (props <> [] || sigs <> []) then begin
+        if List.mem_assoc "abstract" ~map:attrs then 
+          out "@ @[<hv2>let check w ="
+        else begin
+          out "@ @[<hv2>let check () =";
+          out "@ let w = create%s [] in"
+            (if List.mem_assoc "hv" ~map:attrs then " `HORIZONTAL" else "");
+        end;
+        if props <> [] then out "@ let c p = Property.check w p in";
+        if sigs <> [] then begin
+          out "@ let closure = Closure.create ignore in";
+          out "@ let s name = GtkSignal.connect_by_name";
+          out " w ~name ~closure ~after:false in";
+        end;
+        out "@ @[<hov>";
+        List.iter props ~f:
+          (fun (name,_,_gtype,attrs) ->
+            if List.mem "Read" ~set:attrs then out "c P.%s;@ " (camlize name));
+        List.iter sigs ~f:(fun (name,_,_) -> out "s %s;@ " name);
+        out "()@]";
+      end;
+      out "@]@.end\n@."
+    end;
+  close_out oc;
+  (* Output classes *)
+  if !ooutfile = "" then ooutfile := "o" ^ !outfile;
+  let oc = open_out !ooutfile in
+  let ppf = Format.formatter_of_out_channel oc in
+  let out fmt = Format.fprintf ppf fmt in
+  List.iter !oheaders ~f:(fun s -> out "%s@." s);
+  out "open %s@." (String.capitalize_ascii (Filename.chop_extension !outfile));
+  out "@[<hv>";
+  let oprop ~name ~gtype ppf pname =
+    try
+      let conv = List.assoc gtype specials in
+      Format.fprintf ppf "{%s.P.%s with conv=%s}"
+        (camlizeM name) (camlize pname) conv
+    with Not_found ->
+      Format.fprintf ppf "%s.P.%s" (camlizeM name) (camlize pname)
+  in
+  List.iter decls ~f:
+    begin fun (name, gtk_class, attrs, props, meths, sigs) ->
+      let wrap = List.mem_assoc "wrap" ~map:attrs in
+      let wrapset = wrap || List.mem_assoc "wrapset" ~map:attrs in
+      let wr_props =
+        List.filter props ~f:
+          (fun (_,_,_,set) ->
+            let has = List.mem ~set in
+            (wrapset || has "Wrap") && has "Write" &&
+            not (has "ConstructOnly" || has "NoWrap"))
+      and rd_props =
+        List.filter props ~f:
+          (fun (_,_,_,set) ->
+            let has = List.mem ~set in
+            (wrap || has "Wrap") && has "Read" &&
+            not (has "NoWrap" || has "NoGet"))
+      and wr_meths =
+        List.filter meths ~f:(fun (_,_,attrs) -> List.mem "Wrap" ~set:attrs)
+      in
+      if wr_props <> [] || rd_props <> [] || wr_meths <> [] then begin
+        (* pre 3.10
+        out "@ @[<hv2>class virtual %s_props = object (self)" (camlize name);
+        out "@ method private virtual obj : _ obj";
+        List.iter wr_props ~f:(fun (pname,mlname,gtype,_) ->
+          out "@ @[<hv2>method set_%s =@ set %a self#obj@]"
+            mlname (oprop ~name ~gtype) pname);
+        List.iter rd_props ~f:(fun (pname,mlname,gtype,_) ->
+          out "@ @[<hv2>method %s =@ get %a self#obj@]"
+            mlname (oprop ~name ~gtype) pname);
+        List.iter wr_meths ~f:(fun (mname,typ,_) ->
+          out "@ @[<hv2>method %s %s=@ %s.%s self#obj@]"
+            mname (if typ = "unit" then "() " else "") (camlizeM name) mname);
+        *)
+        (* post 3.10 *)
+        out "@ @[<hv2>class virtual %s_props = object" (camlize name);
+        out "@ val virtual obj : _ obj";
+        List.iter wr_props ~f:(fun (pname,mlname,gtype,_) ->
+          out "@ @[<hv2>method set_%s =@ set %a obj@]"
+            mlname (oprop ~name ~gtype) pname);
+        List.iter rd_props ~f:(fun (pname,mlname,gtype,_) ->
+          out "@ @[<hv2>method %s =@ get %a obj@]"
+            mlname (oprop ~name ~gtype) pname);
+        List.iter wr_meths ~f:(fun (mname,typ,_) ->
+          out "@ @[<hv2>method %s %s=@ %s.%s obj@]"
+            mname (if typ = "unit" then "() " else "") (camlizeM name) mname);
+        out "@]@ end@ ";
+        (* #notify: easy connection to the "foo::notify" signal for the "foo"
+         * properties. *)
+        (*
+        out "@ @[<hv2>class virtual %s_notify obj = object (self)" (camlize name);
+        out "@ val obj : 'a obj = obj";
+        out "@ method private notify : 'b. ('a, 'b) property ->";
+        out "@   callback:('b -> unit) -> _ =";
+        out "@ fun prop ~callback -> GtkSignal.connect_property obj";
+        out "@   ~prop ~callback";
+        List.iter rd_props ~f:(fun (pname, mlname, gtype, _) ->
+          out "@ @[<hv2>method %s =@ self#notify %a@]"
+          mlname (oprop ~name ~gtype) pname);
+        out "@]@ end@ ";
+        *)
+      end;
+      let vset = List.mem_assoc "vset" ~map:attrs in
+      let vprops =
+        List.filter props ~f:
+          (fun (_,_,_,set) ->
+            let has = List.mem ~set in
+            (vset || has "VSet") && has "Write" &&
+            not (has "ConstructOnly" || has "NoVSet"))
+      in
+      if vprops <> [] then begin
+        out "@ @[<hv2>let %s_param = function" (camlize name);
+        List.iter vprops ~f:(fun (pname,mlname,gtype,_) ->
+          out "@ @[<hv4>| `%s p ->@ param %a p@]"
+            (String.uppercase_ascii mlname) (oprop ~name ~gtype) pname);
+        out "@]@ ";
+      end;
+      let wsig = List.mem_assoc "wrapsig" ~map:attrs in
+      let wsigs =
+        List.filter sigs ~f:
+          (fun (_,_,attrs) ->
+            List.mem "Wrap" ~set:attrs || wsig && not (List.mem "NoWrap" ~set:attrs))
+      in
+      if wsigs <> [] then begin
+        out "@ @[<hv2>class virtual %s_sigs = object (self)" (camlize name);
+        out "@ @[<hv2>method private virtual connect :";
+        out "@ 'b. ('a,'b) GtkSignal.t -> callback:'b -> GtkSignal.id@]";
+        out "@ @[<hv2>method private virtual notify :";
+        out "@ 'b. ('a,'b) property -> callback:('b -> unit) -> GtkSignal.id@]";
+        List.iter wsigs ~f:
+          begin fun (sname, types,_) ->
+            match types with Types(l, tyl,ret)
+              when List.exists tyl ~f:(List.mem_assoc ~map:specials) ->
+                let convs =
+                  List.map tyl ~f:
+                    (fun ty -> try List.assoc ty specials
+                      with Not_found -> Hashtbl.find conversions ty)
+                in
+                out "@ @[<hov2>method %s =@ self#connect" sname;
+                out "@ @[<hov1>{%s.S.%s with@ marshaller = %a}@]@]"
+                  (camlizeM name) sname
+                  (omarshaller ~gtk_class ~name:sname) (l, convs,ret)
+            | _ ->
+                out "@ @[<hv2>method %s =@ self#connect %s.S.%s@]"
+                  sname (camlizeM name) sname
+          end;
+        (* notify: easy connection to "foo::notify" signals for "foo"
+         * properties. *)
+        List.iter rd_props ~f:(fun (pname, mlname, gtype, _) ->
+          out "@ @[<hov2>method notify_%s ~callback =" mlname;
+          out "@ @[<hov1>self#notify %a ~callback@]@]"
+          (oprop ~name ~gtype) pname);
+        out "@]@ end@ ";
+      end
+    end;
+  out "@.";
+  close_out oc;
+  outfile := "";
+  ooutfile := ""
+
+let main () =
+  Arg.parse
+    [ "-checks", Arg.Set checks, "generate code for checks";
+      "-o", Arg.String (fun s -> outfile := s), "basic output file name";
+      "-oo", Arg.String (fun s -> ooutfile := s), "wrappers output file name" ]
+    process_file "usage: propcc <options> file.props ..."
+
+let () = Printexc.print main ()
diff --git a/lablgtk3/lablgen/varcc.ml b/lablgtk3/lablgen/varcc.ml
new file mode 100644
index 0000000..d9ff2bf
--- /dev/null
+++ b/lablgtk3/lablgen/varcc.ml
@@ -0,0 +1,347 @@
+(* -*- caml -*- *)
+(* $Id$ *)
+
+module Stream = MyStream
+module Genlex = MyGenlex
+
+(* Compile a list of variant tags into CPP defines *) 
+
+open StdLabels
+
+(* hash_variant, from ctype.ml *)
+
+let hash_variant s =
+  let accu = ref 0 in
+  for i = 0 to String.length s - 1 do
+    accu := 223 * !accu + Char.code s.[i]
+  done;
+  (* reduce to 31 bits *)
+  accu := !accu land (1 lsl 31 - 1);
+  (* make it signed for 64 bits architectures *)
+  if !accu > 0x3FFFFFFF then !accu - 1 lsl 31 else !accu
+
+let camlize id =
+  let b = Buffer.create (String.length id + 4) in
+  for i = 0 to String.length id - 1 do
+    if id.[i] >= 'A' && id.[i] <= 'Z' then
+      begin
+        if i > 0 then Buffer.add_char b '_';
+        Buffer.add_char b (Char.lowercase_ascii id.[i])
+      end
+    else Buffer.add_char b id.[i]
+  done;
+  Buffer.contents b
+
+open Genlex
+
+let lexer = make_lexer ["type"; "="; "["; "]"; "`"; "|"]
+
+let may_string (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (String s) -> Stream.junk strm__; s
+  | _ -> ""
+
+let may_bar (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Kwd "|") -> Stream.junk strm__; ()
+  | _ -> ()
+
+let rec ident_list (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Kwd "`") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (Ident x) ->
+          Stream.junk strm__;
+          let trans =
+            try may_string strm__ with
+              Stream.Failure -> raise (Stream.Error "")
+          in
+          let _ =
+            try may_bar strm__ with Stream.Failure -> raise (Stream.Error "")
+          in
+          let s = strm__ in (x, trans) :: ident_list s
+      | _ -> raise (Stream.Error "")
+      end
+  | _ -> []
+
+let static = ref false
+
+let rec star ?(acc = []) p (strm__ : _ Stream.t) =
+  match try Some (p strm__) with Stream.Failure -> None with
+    Some x -> let s = strm__ in star ~acc:(x :: acc) p s
+  | _ -> List.rev acc
+
+let flag (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Ident ("public" | "private" | "noconv" | "flags" as s)) ->
+      Stream.junk strm__; s
+  | _ -> raise Stream.Failure
+
+let protect (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Ident "protect") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (Ident m) -> Stream.junk strm__; Some m
+      | _ -> raise (Stream.Error "")
+      end
+  | _ -> None
+
+let may o f =
+  match o with
+    Some v -> f v
+  | None -> ()
+
+open Printf
+
+let hashes = Hashtbl.create 57
+
+let all_convs = ref []
+let package = ref ""
+let pkgprefix = ref ""
+
+let declaration ~hc ~cc (strm__ : _ Stream.t) =
+  match Stream.peek strm__ with
+    Some (Kwd "type") ->
+      Stream.junk strm__;
+      let flags =
+        try star flag strm__ with Stream.Failure -> raise (Stream.Error "")
+      in
+      let guard =
+        try protect strm__ with Stream.Failure -> raise (Stream.Error "")
+      in
+      begin match Stream.peek strm__ with
+        Some (Ident mlname) ->
+          Stream.junk strm__;
+          let name =
+            try may_string strm__ with
+              Stream.Failure -> raise (Stream.Error "")
+          in
+          begin match Stream.peek strm__ with
+            Some (Kwd "=") ->
+              Stream.junk strm__;
+              let prefix =
+                try may_string strm__ with
+                  Stream.Failure -> raise (Stream.Error "")
+              in
+              begin match Stream.peek strm__ with
+                Some (Kwd "[") ->
+                  Stream.junk strm__;
+                  let _ =
+                    try may_bar strm__ with
+                      Stream.Failure -> raise (Stream.Error "")
+                  in
+                  let tags =
+                    try ident_list strm__ with
+                      Stream.Failure -> raise (Stream.Error "")
+                  in
+                  begin match Stream.peek strm__ with
+                    Some (Kwd "]") ->
+                      Stream.junk strm__;
+                      let suffix =
+                        try may_string strm__ with
+                          Stream.Failure -> raise (Stream.Error "")
+                      in
+                      let oh x = fprintf hc x
+                      and oc x = fprintf cc x in
+                      let name =
+                        if name = "" then !pkgprefix ^ mlname else name
+                      in
+                      (* Output tag values to headers *)
+                      let first = ref true in
+                      List.iter tags
+                        ~f:(fun (tag, _) ->
+                           let hash = hash_variant tag in
+                           try
+                             let tag' = Hashtbl.find hashes hash in
+                             if tag <> tag' then
+                               failwith
+                                 (String.concat ~sep:" "
+                                    ["Doublon tag:"; tag; "and"; tag'])
+                           with Not_found ->
+                             Hashtbl.add hashes hash tag;
+                             if !first then
+                               begin
+                                 oh "/* %s : tags and macros */\n" name;
+                                 first := false
+                               end;
+                             oh "#define MLTAG_%s\t((value)(%d*2+1))\n" tag
+                               hash);
+                      if List.mem "noconv" ~set:flags then ()
+                      else
+                        let ctag tag trans =
+                          if trans <> "" then trans
+                          else
+                            let tag =
+                              if tag.[0] = '_' then
+                                String.sub tag ~pos:1
+                                  ~len:(String.length tag - 1)
+                              else tag
+                            in
+                            match
+                              if prefix = "" then None, ""
+                              else
+                                Some prefix.[String.length prefix - 1],
+                                String.sub prefix ~pos:0
+                                  ~len:(String.length prefix - 1)
+                            with
+                              Some '#', prefix ->
+                                prefix ^ String.uncapitalize_ascii tag ^
+                                suffix
+                            | Some '^', prefix ->
+                                prefix ^ String.uppercase_ascii tag ^ suffix
+                            | _ -> prefix ^ tag ^ suffix
+                        and cname = String.capitalize_ascii name in
+                        all_convs :=
+                          (name, mlname, tags, flags) :: !all_convs;
+                        let tags =
+                          List.sort tags
+                            ~cmp:(fun (tag1, _) (tag2, _) -> compare (hash_variant tag1) (hash_variant tag2))
+                        in
+                        (* Output table to code file *)
+                        oc "/* %s : conversion table */\n" name;
+                        let static =
+                          if !static && not (List.mem "public" ~set:flags) ||
+                             List.mem "private" ~set:flags
+                          then
+                            "static "
+                          else ""
+                        in
+                        oc "%sconst lookup_info ml_table_%s[] = {\n" static
+                          name;
+                        may guard (fun m -> oc "#ifdef %s\n" m);
+                        oc "  { 0, %d },\n" (List.length tags);
+                        List.iter tags
+                          ~f:(fun (tag, trans) -> oc "  { MLTAG_%s, %s },\n" tag (ctag tag trans));
+                        may guard
+                          (fun m ->
+                             oc "#else\n  {0, 0 }\n#endif /* %s */\n" m);
+                        oc "};\n\n";
+                        (* Output macros to headers *)
+                        if not !first then oh "\n";
+                        if static = "" then
+                          oh "extern const lookup_info ml_table_%s[];\n" name;
+                        oh
+                          "#define Val_%s(data) ml_lookup_from_c (ml_table_%s, data)\n"
+                          name name;
+                        oh
+                          "#define %s_val(key) ml_lookup_to_c (ml_table_%s, key)\n\n"
+                          cname name
+                  | _ -> raise (Stream.Error "")
+                  end
+              | _ -> raise (Stream.Error "")
+              end
+          | _ -> raise (Stream.Error "")
+          end
+      | _ -> raise (Stream.Error "")
+      end
+  | Some (Ident "package") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (String s) -> Stream.junk strm__; package := s
+      | _ -> raise (Stream.Error "")
+      end
+  | Some (Ident "prefix") ->
+      Stream.junk strm__;
+      begin match Stream.peek strm__ with
+        Some (String s) -> Stream.junk strm__; pkgprefix := s
+      | _ -> raise (Stream.Error "")
+      end
+  | _ -> raise End_of_file
+
+
+let process ic ~hc ~cc =
+  all_convs := [];
+  let chars = Stream.of_channel ic in
+  let s = lexer chars in
+  try while true do declaration s ~hc ~cc done with
+    End_of_file ->
+      if !all_convs <> [] && !package <> "" then
+        let oc x = fprintf cc x in
+        oc "CAMLprim value ml_%s_get_tables ()\n{\n" (camlize !package);
+        oc "  static const lookup_info *ml_lookup_tables[] = {\n";
+        let convs = List.rev !all_convs in
+        List.iter convs ~f:(fun (s, _, _, _) -> oc "    ml_table_%s,\n" s);
+        oc "  };\n";
+        (* When he have only one conversion, we must return it directly instead of       * an array that would be converted to a tuple *)
+        if List.length convs = 1 then
+          oc "  return (value)ml_lookup_tables[0];"
+        else oc "  return (value)ml_lookup_tables;";
+        oc "}\n";
+        let mlc = open_out (!package ^ "Enums.ml") in
+        let ppf = Format.formatter_of_out_channel mlc in
+        let out fmt = Format.fprintf ppf fmt in
+        out "(** %s enums *)\n@." !package;
+        out "@[";
+        List.iter convs
+          ~f:(fun (_, name, tags, _) ->
+             out "@[<hv 2>type %s =@ @[<hov>[ `%s" name (fst (List.hd tags));
+             List.iter (List.tl tags) ~f:(fun (s, _) -> out "@ | `%s" s);
+             out " ]@]@]@ ");
+        out "@]@.\n(**/**)\n@.";
+        out "@[<v2>module Conv = struct@ ";
+        out "open Gpointer\n@ ";
+        out "external _get_tables : unit ->@ ";
+        let (_, name0, _, _) = List.hd convs in
+        out "    %s variant_table@ " name0;
+        List.iter (List.tl convs)
+          ~f:(fun (_, s, _, _) -> out "  * %s variant_table@ " s);
+        out "  = \"ml_%s_get_tables\"\n@ " (camlize !package);
+        out "@[<hov 4>let %s_tbl" name0;
+        List.iter (List.tl convs) ~f:(fun (_, s, _, _) -> out ",@ %s_tbl" s);
+        out " = _get_tables ()@]\n";
+        let enum =
+          if List.length convs > 10 then
+            begin out "@ let _make_enum = Gobject.Data.enum"; "_make_enum" end
+          else "Gobject.Data.enum"
+        in
+        List.iter convs
+          ~f:(fun (_, s, _, flags) ->
+             let conv =
+               if List.mem "flags" ~set:flags then "Gobject.Data.flags"
+               else enum
+             in
+             out "@ let %s = %s %s_tbl" s conv s);
+        out "@]@.end@.";
+        close_out mlc
+  | Stream.Error err ->
+      failwith
+        (Printf.sprintf "Parsing error \"%s\" at character %d on input stream"
+           err (Stream.count chars))
+
+let main () =
+  let inputs = ref [] in
+  let header = ref "" in
+  let code = ref "" in
+  Arg.parse
+    ["-h", Arg.String ((:=) header), "file to output macros (file.h)";
+     "-c", Arg.String ((:=) code),
+     "file to output conversion tables (file.c)";
+     "-static", Arg.Set static, "do not export conversion tables"]
+    (fun s -> inputs := s :: !inputs) "usage: varcc [options] file.var";
+  let inputs = List.rev !inputs in
+  begin match inputs with
+    [] ->
+      if !header = "" then header := "a.h"; if !code = "" then code := "a.c"
+  | ip :: _ ->
+      let rad =
+        if Filename.check_suffix ip ".var" then Filename.chop_extension ip
+        else ip
+      in
+      if !header = "" then header := rad ^ ".h";
+      if !code = "" then code := rad ^ ".c"
+  end;
+  let hc = open_out !header
+  and cc = open_out !code in
+  if inputs = [] then process stdin ~hc ~cc
+  else
+    List.iter inputs
+      ~f:(fun file ->
+         let ic = open_in file in
+         try process ic ~hc ~cc; close_in ic with
+           exn -> close_in ic; prerr_endline ("Error in " ^ file); raise exn);
+  close_out hc;
+  close_out cc
+
+let _ = Printexc.print main ()
diff --git a/lablgtk3/lablgen/varcc.ml4 b/lablgtk3/lablgen/varcc.ml4
new file mode 100644
index 0000000..03b07d8
--- /dev/null
+++ b/lablgtk3/lablgen/varcc.ml4
@@ -0,0 +1,254 @@
+(* -*- caml -*- *)
+(* $Id$ *)
+
+(* Compile a list of variant tags into CPP defines *) 
+
+open StdLabels
+
+(* hash_variant, from ctype.ml *)
+
+let hash_variant s =
+  let accu = ref 0 in
+  for i = 0 to String.length s - 1 do
+    accu := 223 * !accu + Char.code s.[i]
+  done;
+  (* reduce to 31 bits *)
+  accu := !accu land (1 lsl 31 - 1);
+  (* make it signed for 64 bits architectures *)
+  if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu
+
+let camlize id =
+  let b = Buffer.create (String.length id + 4) in
+  for i = 0 to String.length id - 1 do
+    if id.[i] >= 'A' && id.[i] <= 'Z' then begin
+      if i > 0 then Buffer.add_char b '_';
+      Buffer.add_char b (Char.lowercase_ascii id.[i])
+    end
+    else Buffer.add_char b id.[i]
+  done;
+  Buffer.contents b
+
+open Genlex
+
+let lexer = make_lexer ["type"; "="; "["; "]"; "`"; "|"]
+
+let may_string = parser
+    [< ' String s >] -> s
+  | [< >] -> ""
+
+let may_bar = parser
+    [< ' Kwd "|" >] -> ()
+  | [< >] -> ()
+
+let rec ident_list = parser
+    [< ' Kwd "`"; ' Ident x; trans = may_string; _ = may_bar; s >] ->
+      (x, trans) :: ident_list s
+  | [< >] -> []
+
+let static = ref false
+
+let rec star ?(acc=[]) p = parser
+    [< x = p ; s >] -> star ~acc:(x::acc) p s
+  | [< >] -> List.rev acc
+
+let flag = parser
+    [< ' Ident ("public"|"private"|"noconv"|"flags" as s) >] -> s
+
+let protect = parser
+    [< ' Ident "protect" ; ' Ident m >] -> Some m
+  | [<>] -> None
+
+let may o f = 
+  match o with
+  | Some v -> f v
+  | None -> ()
+
+open Printf
+
+let hashes = Hashtbl.create 57
+
+let all_convs = ref []
+let package = ref ""
+let pkgprefix = ref ""
+
+let declaration ~hc ~cc = parser
+    [< ' Kwd "type"; flags = star flag; guard = protect;
+       ' Ident mlname; name = may_string; ' Kwd "="; prefix = may_string;
+       ' Kwd "["; _ = may_bar; tags = ident_list; ' Kwd "]";
+       suffix = may_string >] ->
+    let oh x = fprintf hc x and oc x = fprintf cc x in
+    let name = if name = "" then !pkgprefix ^ mlname else name in
+    (* Output tag values to headers *)
+    let first = ref true in
+    List.iter tags ~f:
+      begin fun (tag, _) ->
+        let hash = hash_variant tag in
+        try
+	  let tag' = Hashtbl.find hashes hash in
+	  if tag <> tag' then
+	    failwith (String.concat ~sep:" " ["Doublon tag:";tag;"and";tag'])
+        with Not_found ->
+	  Hashtbl.add hashes hash tag;
+          if !first then begin
+            oh "/* %s : tags and macros */\n" name; first := false
+          end;
+	  oh "#define MLTAG_%s\t((value)(%d*2+1))\n" tag hash;
+      end;
+    if List.mem "noconv" ~set:flags then () else
+    (* compute C name *)
+    let ctag tag trans =
+      if trans <> "" then trans else
+      let tag =
+	if tag.[0] = '_' then
+	  String.sub tag ~pos:1 ~len:(String.length tag -1)
+	else tag
+      in
+      match
+	if prefix = "" then None, ""
+	else
+	  Some (prefix.[String.length prefix - 1]), 
+	  String.sub prefix ~pos:0 ~len:(String.length prefix - 1)
+      with
+	Some '#', prefix ->
+	  prefix ^ String.uncapitalize_ascii tag ^ suffix
+      |	Some '^', prefix ->
+	  prefix ^ String.uppercase_ascii tag ^ suffix
+      |	_ ->
+	  prefix ^ tag ^ suffix
+    and cname =
+      String.capitalize_ascii name
+    in
+    all_convs := (name, mlname, tags, flags) :: !all_convs;
+    let tags =
+      List.sort tags ~cmp:
+        (fun (tag1,_) (tag2,_) ->
+          compare (hash_variant tag1) (hash_variant tag2))
+    in
+    (* Output table to code file *)
+    oc "/* %s : conversion table */\n" name;
+    let static =
+      if !static && not (List.mem "public" ~set:flags) || List.mem "private" ~set:flags
+      then "static " else "" in
+    oc "%sconst lookup_info ml_table_%s[] = {\n" static name;
+    may guard
+      (fun m -> oc "#ifdef %s\n" m) ;
+    oc "  { 0, %d },\n" (List.length tags);
+    List.iter tags ~f:
+      begin fun (tag,trans) ->
+	oc "  { MLTAG_%s, %s },\n" tag (ctag tag trans)
+      end;
+    may guard (fun m -> oc "#else\n  {0, 0 }\n#endif /* %s */\n" m) ;
+    oc "};\n\n";
+    (* Output macros to headers *)
+    if not !first then oh "\n";
+    if static = "" then oh "extern const lookup_info ml_table_%s[];\n" name;
+    oh "#define Val_%s(data) ml_lookup_from_c (ml_table_%s, data)\n"
+      name name;
+    oh "#define %s_val(key) ml_lookup_to_c (ml_table_%s, key)\n\n"
+      cname name;
+  | [< ' Ident "package"; ' String s >] ->
+      package := s
+  | [< ' Ident "prefix"; ' String s >] ->
+      pkgprefix := s
+  | [< >] -> raise End_of_file
+
+
+let process ic ~hc ~cc =  
+  all_convs := [];
+  let chars = Stream.of_channel ic in
+  let s = lexer chars in
+  try
+    while true do declaration s ~hc ~cc done
+  with End_of_file ->
+    if !all_convs <> [] && !package <> "" then begin
+      let oc x = fprintf cc x in
+      oc "CAMLprim value ml_%s_get_tables ()\n{\n" (camlize !package);
+      oc "  static const lookup_info *ml_lookup_tables[] = {\n";
+      let convs = List.rev !all_convs in
+      List.iter convs ~f:(fun (s,_,_,_) -> oc "    ml_table_%s,\n" s);
+      oc "  };\n";
+      (* When he have only one conversion, we must return it directly instead of       * an array that would be converted to a tuple *)
+      if List.length convs = 1 then
+        oc "  return (value)ml_lookup_tables[0];"
+      else
+        oc "  return (value)ml_lookup_tables;";
+      oc "}\n";
+      let mlc = open_out (!package ^ "Enums.ml") in
+      let ppf = Format.formatter_of_out_channel mlc in
+      let out fmt = Format.fprintf ppf fmt in
+      out "(** %s enums *)\n@." !package ;
+      out "@[";
+      List.iter convs ~f:
+        begin fun (_,name,tags,_) ->
+          out "@[<hv 2>type %s =@ @[<hov>[ `%s" name (fst (List.hd tags));
+          List.iter (List.tl tags) ~f:
+            (fun (s,_) -> out "@ | `%s" s);
+          out " ]@]@]@ "
+        end;
+      out "@]@.\n(**/**)\n@." ;
+      out "@[<v2>module Conv = struct@ ";
+      out "open Gpointer\n@ ";
+      out "external _get_tables : unit ->@ ";
+      let (_,name0,_,_) = List.hd convs in
+      out "    %s variant_table@ " name0;
+      List.iter (List.tl convs) ~f:
+        (fun (_,s,_,_) -> out "  * %s variant_table@ " s);
+      out "  = \"ml_%s_get_tables\"\n@ " (camlize !package);
+      out "@[<hov 4>let %s_tbl" name0;
+      List.iter (List.tl convs) ~f:(fun (_,s,_,_) -> out ",@ %s_tbl" s);
+      out " = _get_tables ()@]\n";
+      let enum =
+        if List.length convs > 10 then begin
+          out "@ let _make_enum = Gobject.Data.enum";
+          "_make_enum"
+        end else "Gobject.Data.enum"
+      in
+      List.iter convs ~f:
+        begin fun (_,s,_,flags) ->
+          let conv =
+            if List.mem "flags" ~set:flags then "Gobject.Data.flags" else enum in
+          out "@ let %s = %s %s_tbl" s conv s
+        end;
+      out "@]@.end@.";
+      close_out mlc
+    end
+  | Stream.Error err ->
+      failwith
+        (Printf.sprintf "Parsing error \"%s\" at character %d on input stream"
+           err (Stream.count chars))
+
+let main () =
+  let inputs = ref [] in
+  let header = ref "" in
+  let code = ref "" in
+  Arg.parse
+    [ "-h", Arg.String ((:=) header), "file to output macros (file.h)";
+      "-c", Arg.String ((:=) code),
+      "file to output conversion tables (file.c)";
+      "-static", Arg.Set static, "do not export conversion tables" ]
+    (fun s -> inputs := s :: !inputs)
+    "usage: varcc [options] file.var";
+  let inputs = List.rev !inputs in
+  begin match inputs with
+  | [] ->
+      if !header = "" then header := "a.h";
+      if !code = "" then code := "a.c"
+  | ip :: _ ->
+      let rad =
+        if Filename.check_suffix ip ".var" then Filename.chop_extension ip
+        else ip in
+      if !header = "" then header := rad ^ ".h";
+      if !code = "" then code := rad ^ ".c"
+  end;
+  let hc = open_out !header and cc = open_out !code in
+  if inputs = [] then process stdin ~hc ~cc else begin
+    List.iter inputs ~f:
+      begin fun file ->
+        let ic = open_in file in
+        try process ic ~hc ~cc; close_in ic
+        with exn -> close_in ic; prerr_endline ("Error in " ^ file); raise exn
+      end
+  end;
+  close_out hc; close_out cc
+
+let _ = Printexc.print main ()
diff --git a/lablgtk3/ml_gdk.c b/lablgtk3/ml_gdk.c
index 2718a18..cb4a5f0 100644
--- a/lablgtk3/ml_gdk.c
+++ b/lablgtk3/ml_gdk.c
@@ -55,7 +55,7 @@ CAMLprim void ml_raise_gdk (const char *errmsg)
   static const value * exn = NULL;
   if (exn == NULL)
       exn = caml_named_value ("gdkerror");
-  raise_with_string (*exn, (char*)errmsg);
+  caml_raise_with_string (*exn, (char*)errmsg);
 }
 
 CAMLprim value ml_gdk_init(value unit)
@@ -263,7 +263,7 @@ CAMLprim value ml_gdk_window_get_position (value window)
 
   gdk_window_get_position (GdkWindow_val(window), &x, &y);
   
-  ret = alloc_small (2,0);
+  ret = caml_alloc_small (2,0);
   Field(ret,0) = Val_int(x);
   Field(ret,1) = Val_int(y);
   return ret;
@@ -276,7 +276,7 @@ CAMLprim value ml_gdk_window_get_origin (value window)
 
   gdk_window_get_origin (GdkWindow_val(window), &x, &y);
 
-  ret = alloc_small (2,0);
+  ret = caml_alloc_small (2,0);
   Field(ret,0) = Val_int(x);
   Field(ret,1) = Val_int(y);
   return ret;
@@ -288,7 +288,7 @@ CAMLprim value ml_gdk_window_get_pointer_location (value window)
   int y = 0;
   value ret;
   gdk_window_get_pointer (GdkWindow_val(window), &x, &y, NULL);
-  ret = alloc_small (2, 0);
+  ret = caml_alloc_small (2, 0);
   Field(ret, 0) = Val_int(x);
   Field(ret, 1) = Val_int(y);
   return ret;
@@ -328,7 +328,7 @@ CAMLprim value ml_gdk_display_get_window_at_pointer (value display)
     CAMLparam0 ();
     CAMLlocal1(tup);
 
-    tup = alloc_tuple(3);
+    tup = caml_alloc_tuple(3);
     Store_field(tup,0,Val_GdkWindow(gwin));
     Store_field(tup,1,Val_int(x));
     Store_field(tup,2,Val_int(y));
@@ -357,7 +357,7 @@ CAMLprim value ml_gdk_property_change (value window, value property, value type,
 {
     int format = Xdata_val (Field(xdata,0));
     value data = Field(xdata,1);
-    int nelems = (format == 8 ? string_length (data) : Wosize_val(data));
+    int nelems = (format == 8 ? caml_string_length (data) : Wosize_val(data));
     guchar *sdata;
     int i;
     switch (format) {
@@ -391,27 +391,27 @@ CAMLprim value copy_xdata (gint format, void *xdata, gulong nitems)
     unsigned int i;
     switch (format) {
     case 8:
-        data = alloc_string (nitems);
+        data = caml_alloc_string (nitems);
         memcpy (Bytes_val(data), xdata, sizeof(char) * nitems);
         tag = MLTAG_BYTES;
         break;
     case 16:
-        data = alloc (nitems,0);
+        data = caml_alloc (nitems,0);
         for (i = 0; i < nitems; i++)
             Field(data,i) = Val_int(((short*)xdata)[i]);
         tag = MLTAG_SHORTS;
         break;
     case 32:
-        data = alloc (nitems,0);
+        data = caml_alloc (nitems,0);
         for (i = 0; i < nitems; i++)
-            Store_field(data, i, copy_int32 (((long*)xdata)[i]));
+            Store_field(data, i, caml_copy_int32 (((long*)xdata)[i]));
         tag = MLTAG_INT32S;
         break;
     default:
         tag = MLTAG_NONE;
     }
     if (tag != MLTAG_NONE) {
-        ret = alloc_small (2,0);
+        ret = caml_alloc_small (2,0);
         Field(ret,0) = tag;
         Field(ret,1) = data;
     }
@@ -442,7 +442,7 @@ CAMLprim value ml_gdk_property_get (value window, value property,
         }
         mldata = copy_xdata (aformat, data, nitems);
         mltype = Val_GdkAtom (atype);
-        pair = alloc_small(2,0);
+        pair = caml_alloc_small(2,0);
         Field(pair,0) = mltype;
         Field(pair,1) = mldata;
         CAMLreturn(ml_some (pair));
@@ -487,7 +487,7 @@ CAMLprim value ml_gdk_event_new (value event_type)
 }
 #endif
 
-ML_1 (gdk_event_get_time, GdkEvent_val, copy_int32)
+ML_1 (gdk_event_get_time, GdkEvent_val, caml_copy_int32)
 
 #define GdkEvent_arg(type) (GdkEvent##type*)GdkEvent_val
 
@@ -505,17 +505,17 @@ Make_Extractor (GdkEventExpose, GdkEvent_arg(Expose), count, Val_int)
 Make_Extractor (GdkEventVisibility, GdkEvent_arg(Visibility), state,
                 Val_gdkVisibilityState)
 
-Make_Extractor (GdkEventMotion, GdkEvent_arg(Motion), x, copy_double)
-Make_Extractor (GdkEventMotion, GdkEvent_arg(Motion), y, copy_double)
+Make_Extractor (GdkEventMotion, GdkEvent_arg(Motion), x, caml_copy_double)
+Make_Extractor (GdkEventMotion, GdkEvent_arg(Motion), y, caml_copy_double)
 static value copy_axes(double *axes)
 {
     CAMLparam0();
     CAMLlocal2(x,y);
     value ret;
     if (axes) {
-        x = copy_double(axes[0]);
-        y = copy_double(axes[0]);
-        ret = alloc_small(2, 0);
+        x = caml_copy_double(axes[0]);
+        y = caml_copy_double(axes[0]);
+        ret = caml_alloc_small(2, 0);
         Field(ret,0) = x;
         Field(ret,1) = y;
         ret = ml_some(ret);
@@ -527,27 +527,27 @@ Make_Extractor (GdkEventMotion, GdkEvent_arg(Motion), axes, copy_axes)
 Make_Extractor (GdkEventMotion, GdkEvent_arg(Motion), state, Val_int)
 Make_Extractor (GdkEventMotion, GdkEvent_arg(Motion), is_hint, Val_int)
 Make_Extractor (GdkEventMotion, GdkEvent_arg(Motion), device, Val_GdkDevice)
-Make_Extractor (GdkEventMotion, GdkEvent_arg(Motion), x_root, copy_double)
-Make_Extractor (GdkEventMotion, GdkEvent_arg(Motion), y_root, copy_double)
+Make_Extractor (GdkEventMotion, GdkEvent_arg(Motion), x_root, caml_copy_double)
+Make_Extractor (GdkEventMotion, GdkEvent_arg(Motion), y_root, caml_copy_double)
 
-Make_Extractor (GdkEventButton, GdkEvent_arg(Button), x, copy_double)
-Make_Extractor (GdkEventButton, GdkEvent_arg(Button), y, copy_double)
+Make_Extractor (GdkEventButton, GdkEvent_arg(Button), x, caml_copy_double)
+Make_Extractor (GdkEventButton, GdkEvent_arg(Button), y, caml_copy_double)
 Make_Extractor (GdkEventButton, GdkEvent_arg(Button), axes, copy_axes)
 Make_Extractor (GdkEventButton, GdkEvent_arg(Button), state, Val_int)
 Make_Extractor (GdkEventButton, GdkEvent_arg(Button), button, Val_int)
 Make_Extractor (GdkEventButton, GdkEvent_arg(Button), device, Val_GdkDevice)
-Make_Extractor (GdkEventButton, GdkEvent_arg(Button), x_root, copy_double)
-Make_Extractor (GdkEventButton, GdkEvent_arg(Button), y_root, copy_double)
+Make_Extractor (GdkEventButton, GdkEvent_arg(Button), x_root, caml_copy_double)
+Make_Extractor (GdkEventButton, GdkEvent_arg(Button), y_root, caml_copy_double)
 Make_Setter (gdk_event_button_set, GdkEvent_arg(Button), Int_val, button)
 
-Make_Extractor (GdkEventScroll, GdkEvent_arg(Scroll), x, copy_double)
-Make_Extractor (GdkEventScroll, GdkEvent_arg(Scroll), y, copy_double)
+Make_Extractor (GdkEventScroll, GdkEvent_arg(Scroll), x, caml_copy_double)
+Make_Extractor (GdkEventScroll, GdkEvent_arg(Scroll), y, caml_copy_double)
 Make_Extractor (GdkEventScroll, GdkEvent_arg(Scroll), state, Val_int)
 Make_Extractor (GdkEventScroll, GdkEvent_arg(Scroll),
                 direction, Val_gdkScrollDirection)
 Make_Extractor (GdkEventScroll, GdkEvent_arg(Scroll), device, Val_GdkDevice)
-Make_Extractor (GdkEventScroll, GdkEvent_arg(Scroll), x_root, copy_double)
-Make_Extractor (GdkEventScroll, GdkEvent_arg(Scroll), y_root, copy_double)
+Make_Extractor (GdkEventScroll, GdkEvent_arg(Scroll), x_root, caml_copy_double)
+Make_Extractor (GdkEventScroll, GdkEvent_arg(Scroll), y_root, caml_copy_double)
 
 Make_Extractor (GdkEventKey, GdkEvent_arg(Key), state, Val_int)
 Make_Extractor (GdkEventKey, GdkEvent_arg(Key), keyval, Val_int)
@@ -557,10 +557,10 @@ Make_Extractor (GdkEventKey, GdkEvent_arg(Key), group, Val_int)
 
 Make_Extractor (GdkEventCrossing, GdkEvent_arg(Crossing),
                 subwindow, Val_GdkWindow)
-Make_Extractor (GdkEventCrossing, GdkEvent_arg(Crossing), x, copy_double)
-Make_Extractor (GdkEventCrossing, GdkEvent_arg(Crossing), y, copy_double)
-Make_Extractor (GdkEventCrossing, GdkEvent_arg(Crossing), x_root, copy_double)
-Make_Extractor (GdkEventCrossing, GdkEvent_arg(Crossing), y_root, copy_double)
+Make_Extractor (GdkEventCrossing, GdkEvent_arg(Crossing), x, caml_copy_double)
+Make_Extractor (GdkEventCrossing, GdkEvent_arg(Crossing), y, caml_copy_double)
+Make_Extractor (GdkEventCrossing, GdkEvent_arg(Crossing), x_root, caml_copy_double)
+Make_Extractor (GdkEventCrossing, GdkEvent_arg(Crossing), y_root, caml_copy_double)
 Make_Extractor (GdkEventCrossing, GdkEvent_arg(Crossing),
                 mode, Val_gdkCrossingMode)
 Make_Extractor (GdkEventCrossing, GdkEvent_arg(Crossing),
@@ -592,7 +592,7 @@ Make_Extractor (GdkEventProximity, GdkEvent_arg(Proximity),
 
 Make_Extractor (GdkEventSetting, GdkEvent_arg(Setting),
                 action, Val_gdkSettingAction)
-Make_Extractor (GdkEventSetting, GdkEvent_arg(Setting), name, copy_string)
+Make_Extractor (GdkEventSetting, GdkEvent_arg(Setting), name, caml_copy_string)
 
 Make_Extractor (GdkEventWindowState, GdkEvent_arg(WindowState),
                 changed_mask, Val_int)
diff --git a/lablgtk3/ml_gdk.h b/lablgtk3/ml_gdk.h
index f2172f9..31cb488 100644
--- a/lablgtk3/ml_gdk.h
+++ b/lablgtk3/ml_gdk.h
@@ -71,14 +71,14 @@ CAMLexport value Val_GdkEvent (GdkEvent *);
 #define GdkNativeWindow_val Pointer_val
 #define Val_GdkNativeWindow Val_pointer
 #else
-#define Val_GdkNativeWindow copy_int32
+#define Val_GdkNativeWindow caml_copy_int32
 #define GdkNativeWindow_val Int32_val
 #endif
 
 #ifdef _WIN32
-#define Val_XID(id) copy_int32((long) id)
+#define Val_XID(id) caml_copy_int32((long) id)
 #else
-#define Val_XID copy_int32
+#define Val_XID caml_copy_int32
 #endif
 #define XID_val Int32_val
 
diff --git a/lablgtk3/ml_gdkpixbuf.c b/lablgtk3/ml_gdkpixbuf.c
index 02e4d59..c146d62 100644
--- a/lablgtk3/ml_gdkpixbuf.c
+++ b/lablgtk3/ml_gdkpixbuf.c
@@ -32,6 +32,7 @@
 #include <caml/callback.h>
 #include <caml/fail.h>
 #include <caml/intext.h>
+#include <caml/printexc.h>
 
 #include "wrappers.h"
 #include "ml_glib.h"
@@ -66,8 +67,8 @@ static void ml_GdkPixbuf_serialize (value v, unsigned long *wsize_32, unsigned l
   guint len;
   pixels = gdk_pixdata_from_pixbuf (&pixdata, pb, pixbuf_marshal_use_rle);
   stream = gdk_pixdata_serialize (&pixdata, &len);
-  serialize_int_4 (len);
-  serialize_block_1 (stream, len);
+  caml_serialize_int_4 (len);
+  caml_serialize_block_1 (stream, len);
   g_free (stream);
   g_free (pixels);
   *wsize_32 = 4;
@@ -82,9 +83,9 @@ static unsigned long ml_GdkPixbuf_deserialize (void *dst)
   guint8 *stream;
   guint len;
 
-  len = deserialize_uint_4();
-  stream = stat_alloc (len);
-  deserialize_block_1 (stream, len);
+  len = caml_deserialize_uint_4();
+  stream = caml_stat_alloc (len);
+  caml_deserialize_block_1 (stream, len);
   gdk_pixdata_deserialize (&pixdata, len, stream, &error);
   if (error) goto out;
   pb = gdk_pixbuf_from_pixdata (&pixdata, TRUE, &error);
@@ -92,7 +93,7 @@ static unsigned long ml_GdkPixbuf_deserialize (void *dst)
   *(GdkPixbuf **)dst = pb;
 
  out:
-  stat_free (stream);
+  caml_stat_free (stream);
   if (error != NULL)
     {
       char *msg;
@@ -100,7 +101,7 @@ static unsigned long ml_GdkPixbuf_deserialize (void *dst)
       GEnumValue *val   = g_enum_get_value (class, error->code);
       msg = val ? (char*)val->value_name : "";
       g_error_free (error);
-      deserialize_error (msg);
+      caml_deserialize_error (msg);
     }
   return sizeof pb;
 }
@@ -130,7 +131,7 @@ Make_Val_option(GdkPixbuf)
 CAMLprim value ml_gdkpixbuf_init(value unit)
 {
   ml_register_exn_map (GDK_PIXBUF_ERROR, "gdk_pixbuf_error");
-  register_custom_operations (&ml_custom_GdkPixbuf);
+  caml_register_custom_operations (&ml_custom_GdkPixbuf);
   return Val_unit;
 }
 
@@ -146,7 +147,7 @@ CAMLprim value ml_gdk_pixbuf_get_pixels (value pixbuf)
 {
     long pixels = (long)gdk_pixbuf_get_pixels (GdkPixbuf_val(pixbuf));
     unsigned int ofs = pixels & (sizeof(value)-1);
-    value ret = alloc_small(2,0);
+    value ret = caml_alloc_small(2,0);
     Field(ret,0) = (value)(pixels - ofs);
     Field(ret,1) = Val_int(ofs);
     return ret;
@@ -182,8 +183,8 @@ CAMLprim value ml_gdk_pixbuf_get_file_info(value f)
   gint w, h;
   GdkPixbufFormat *fmt;
   fmt = gdk_pixbuf_get_file_info (String_val (f), &w, &h);
-  v = alloc_tuple(3);
-  Store_field(v, 0, copy_string(gdk_pixbuf_format_get_name(fmt)));
+  v = caml_alloc_tuple(3);
+  Store_field(v, 0, caml_copy_string(gdk_pixbuf_format_get_name(fmt)));
   Store_field(v, 1, Val_int(w));
   Store_field(v, 2, Val_int(h));
   CAMLreturn(v);
@@ -256,8 +257,8 @@ convert_gdk_pixbuf_options (value options, char ***opt_k, char ***opt_v, gboolea
     {
       value cell = Field(options, 0);
       unsigned int i, len = list_length(cell);
-      *opt_k = stat_alloc(sizeof (char *) * (len + 1));
-      *opt_v = stat_alloc(sizeof (char *) * (len + 1));
+      *opt_k = caml_stat_alloc(sizeof (char *) * (len + 1));
+      *opt_v = caml_stat_alloc(sizeof (char *) * (len + 1));
       for (i=0; i<len; i++)
 	{
 	  const gchar *s;
@@ -285,8 +286,8 @@ CAMLprim value ml_gdk_pixbuf_save(value fname, value type, value options, value
   char **opt_v;
   convert_gdk_pixbuf_options (options, &opt_k, &opt_v, FALSE);
   gdk_pixbuf_savev(GdkPixbuf_val(pixbuf), String_val(fname), String_val(type), opt_k, opt_v, &err);
-  stat_free(opt_k);
-  stat_free(opt_v);
+  caml_stat_free(opt_k);
+  caml_stat_free(opt_v);
   if(err) ml_raise_gerror(err);
   return Val_unit;
 }
@@ -302,13 +303,13 @@ ml_gdkpixbuf_savefunc (const gchar *buf, gsize count, GError **error, gpointer d
 {
   value *cb = data;
   value res, s;
-  s = alloc_string (count);
+  s = caml_alloc_string (count);
   memcpy (Bytes_val(s), buf, count);
-  res = callback_exn (*cb, s);
+  res = caml_callback_exn (*cb, s);
   if (Is_exception_result (res))
     {
       g_set_error (error, GDK_PIXBUF_ERROR, GDK_PIXBUF_ERROR_FAILED,
-		   "%s", format_caml_exception(Extract_exception(res)));
+		   "%s", caml_format_exception(Extract_exception(res)));
       return FALSE;
     }
   else
diff --git a/lablgtk3/ml_glib.c b/lablgtk3/ml_glib.c
index 4d8d9c3..19d46df 100644
--- a/lablgtk3/ml_glib.c
+++ b/lablgtk3/ml_glib.c
@@ -64,8 +64,8 @@ value copy_string_v (const gchar * const *v)
   h = p = Val_emptylist;
   while (*v != NULL)
     {
-      s = copy_string (*v);
-      c = alloc_small (2, 0);
+      s = caml_copy_string (*v);
+      c = caml_alloc_small (2, 0);
       Field (c, 0) = s;
       Field (c, 1) = Val_emptylist;
       if (p == Val_emptylist)
@@ -90,7 +90,7 @@ static void ml_raise_glib (const char *errmsg)
   static const value * exn = NULL;
   if (exn == NULL)
       exn = caml_named_value ("gerror");
-  raise_with_string (*exn, (char*)errmsg);
+  caml_raise_with_string (*exn, (char*)errmsg);
 }
 
 CAMLprim value Val_GList (GList *list, value (*func)(gpointer))
@@ -101,7 +101,7 @@ CAMLprim value Val_GList (GList *list, value (*func)(gpointer))
   last_cell = cell = Val_unit;
   while (list != NULL) {
     result = func(list->data);
-    new_cell = alloc_small(2,0);
+    new_cell = caml_alloc_small(2,0);
     Field(new_cell,0) = result;
     Field(new_cell,1) = Val_unit;
     if (last_cell == Val_unit) cell = new_cell;
@@ -138,7 +138,7 @@ struct exn_data {
 
 CAMLprim void ml_register_exn_map (GQuark domain, char *caml_name)
 {
-  struct exn_data *exn_data = stat_alloc (sizeof *exn_data);
+  struct exn_data *exn_data = caml_stat_alloc (sizeof *exn_data);
   exn_data->domain = domain;
   exn_data->caml_exn_name = caml_name;
   exn_data->caml_exn = NULL;
@@ -166,13 +166,13 @@ static void ml_raise_gerror_exn(GError *err, const value *exn)
   CAMLparam0();
   CAMLlocal2(b, msg);
   g_assert (err && exn);
-  msg = copy_string(err->message);
-  b = alloc_small (3, 0);
+  msg = caml_copy_string(err->message);
+  b = caml_alloc_small (3, 0);
   Field (b, 0) = *exn;
   Field (b, 1) = Val_int(err->code);
   Field (b, 2) = msg;
   g_error_free (err);
-  mlraise(b);
+  caml_raise(b);
 }
 
 static void ml_raise_generic_gerror (GError *) Noreturn;
@@ -183,11 +183,11 @@ static void ml_raise_generic_gerror (GError *err)
   if (exn == NULL) {
     exn = caml_named_value ("gerror");
     if (exn == NULL)
-      failwith ("gerror");
+      caml_failwith ("gerror");
   }
-  msg = copy_string (err->message);
+  msg = caml_copy_string (err->message);
   g_error_free (err);
-  raise_with_arg (*exn, msg);
+  caml_raise_with_arg (*exn, msg);
 }
 
 CAMLprim void ml_raise_gerror(GError *err)
@@ -209,8 +209,8 @@ ml_g_log_func(const gchar *log_domain,
 	      gpointer data)
 {
     value msg, *clos_p = data;
-    msg = copy_string (message);
-    callback2_exn(*clos_p, Val_int(log_level), msg);
+    msg = caml_copy_string (message);
+    caml_callback2_exn(*clos_p, Val_int(log_level), msg);
 }
 
 ML_1 (Log_level_val, ID, Val_int)
@@ -222,7 +222,7 @@ CAMLprim value ml_g_log_set_handler (value domain, value levels, value clos)
 				Int_val(levels),
                                 ml_g_log_func, clos_p);
     CAMLparam1(domain);
-    value ret = alloc_small(3,0);
+    value ret = caml_alloc_small(3,0);
     Field(ret,0) = domain;
     Field(ret,1) = Val_int(id);
     Field(ret,2) = (value)clos_p;
@@ -272,7 +272,7 @@ ML_1 (g_main_loop_unref, GMainLoop_val, Unit)
 static gboolean ml_g_source_func (gpointer data)
 {
   value res, *clos = data;
-  res = callback_exn (*clos, Val_unit);
+  res = caml_callback_exn (*clos, Val_unit);
   if (Is_exception_result(res))
     {
       CAML_EXN_LOG ("GSourceFunc");
@@ -345,7 +345,7 @@ static gboolean ml_g_io_channel_watch(GIOChannel *s, GIOCondition c,
 {
     value res, cond, *clos_p = data;
     cond = ml_lookup_flags_getter (ml_table_io_condition, c);
-    res = callback_exn (*clos_p, cond);
+    res = caml_callback_exn (*clos_p, cond);
     if (Is_exception_result (res))
       {
 	CAML_EXN_LOG("GIOChannel watch");
@@ -427,7 +427,7 @@ CAMLprim value Val_GSList (GSList *list, value (*func)(gpointer))
   last_cell = cell = Val_unit;
   while (list != NULL) {
     result = func(list->data);
-    new_cell = alloc_small(2,0);
+    new_cell = caml_alloc_small(2,0);
     Field(new_cell,0) = result;
     Field(new_cell,1) = Val_unit;
     if (last_cell == Val_unit) cell = new_cell;
@@ -466,7 +466,7 @@ caml_copy_string_len_and_free (char *str, size_t len)
 {
   value v;
   g_assert (str != NULL);
-  v = alloc_string (len);
+  v = caml_alloc_string (len);
   memcpy (Bytes_val(v), str, len);
   g_free (str);
   return v;
@@ -477,7 +477,7 @@ CAMLprim value ml_g_convert(value str, value to, value from)
   gsize bw=0;
   gchar* c_res;
   GError *error=NULL;
-  c_res = g_convert(String_val(str),string_length(str),
+  c_res = g_convert(String_val(str),caml_string_length(str),
                     String_val(to),String_val(from),
                     NULL,&bw,&error);
   if (error != NULL) ml_raise_gerror(error);
@@ -489,7 +489,7 @@ CAMLprim value ml_g_convert_with_fallback(value fallback, value to, value from,
   gsize bw=0;
   gchar* c_res;
   GError *error=NULL;
-  c_res = g_convert_with_fallback(String_val(str),string_length(str),
+  c_res = g_convert_with_fallback(String_val(str),caml_string_length(str),
 				  String_val(to),String_val(from),
 				  String_option_val(fallback),
 				  NULL,&bw,&error);
@@ -502,7 +502,7 @@ CAMLprim value ml_##cname(value str) { \
   gsize bw=0; \
   gchar* c_res; \
   GError *error=NULL; \
-  c_res = cname(String_val(str),string_length(str),NULL,&bw,&error); \
+  c_res = cname(String_val(str),caml_string_length(str),NULL,&bw,&error); \
   if (error != NULL) ml_raise_gerror(error); \
   return caml_copy_string_len_and_free (c_res, bw); \
 }
@@ -523,7 +523,7 @@ CAMLprim value ml_g_filename_from_uri (value uri)
     CAMLlocal3(v_h, v_f, v_p);
     v_h = Val_option(hostname, copy_string_g_free);
     v_f = copy_string_g_free (result);
-    v_p = alloc_small(2, 0);
+    v_p = caml_alloc_small(2, 0);
     Field(v_p, 0) = v_h;
     Field(v_p, 1) = v_f;
     CAMLreturn(v_p);
@@ -546,7 +546,7 @@ CAMLprim value ml_g_get_charset()
   gboolean r;
   const char *c;
   r = g_get_charset(&c);
-  couple = alloc_tuple(2);
+  couple = caml_alloc_tuple(2);
   Store_field(couple,0,Val_bool(r));
   Store_field(couple,1,Val_string(c));
   CAMLreturn(couple);
@@ -607,20 +607,20 @@ Unsupported(g_get_application_name)
 Unsupported(g_set_application_name)
 #endif
 
-ML_0 (g_get_user_name, copy_string)
-ML_0 (g_get_real_name, copy_string)
+ML_0 (g_get_user_name, caml_copy_string)
+ML_0 (g_get_real_name, caml_copy_string)
 CAMLprim value ml_g_get_home_dir (value unit)
 {
   const char *s = g_get_home_dir();
-  return s ? ml_some (copy_string (s)) : Val_unit;
+  return s ? ml_some (caml_copy_string (s)) : Val_unit;
 }
-ML_0 (g_get_tmp_dir, copy_string)
+ML_0 (g_get_tmp_dir, caml_copy_string)
 CAMLprim value ml_g_find_program_in_path (value p)
 {
   value v;
   char *s = g_find_program_in_path (String_val(p));
-  if (s == NULL) raise_not_found();
-  v = copy_string(s);
+  if (s == NULL) caml_raise_not_found();
+  v = caml_copy_string(s);
   g_free(s);
   return v;
 }
@@ -628,15 +628,15 @@ CAMLprim value ml_g_find_program_in_path (value p)
 CAMLprim value ml_g_getenv (value v)
 {
   const gchar *s = g_getenv(String_val(v));
-  if (s == NULL) raise_not_found();
-  return copy_string(s);
+  if (s == NULL) caml_raise_not_found();
+  return caml_copy_string(s);
 }
 
 #ifdef HASGTK24
 CAMLprim value ml_g_setenv (value v, value s, value o)
 {
   if (! g_setenv(String_val(v), String_val(s), Bool_val(o)))
-    failwith("g_setenv");
+    caml_failwith("g_setenv");
   return Val_unit;
 }
 ML_1 (g_unsetenv, String_val, Unit)
@@ -646,9 +646,9 @@ Unsupported_24(g_unsetenv)
 #endif /* HASGTK24 */
 
 #ifdef HASGTK26
-ML_0 (g_get_user_cache_dir, copy_string)
-ML_0 (g_get_user_data_dir, copy_string)
-ML_0 (g_get_user_config_dir, copy_string)
+ML_0 (g_get_user_cache_dir, caml_copy_string)
+ML_0 (g_get_user_data_dir, caml_copy_string)
+ML_0 (g_get_user_config_dir, caml_copy_string)
 ML_0 (g_get_system_data_dirs, copy_string_v)
 ML_0 (g_get_system_config_dirs, copy_string_v)
 #else
diff --git a/lablgtk3/ml_gobject.c b/lablgtk3/ml_gobject.c
index e81d897..0de9f64 100644
--- a/lablgtk3/ml_gobject.c
+++ b/lablgtk3/ml_gobject.c
@@ -121,7 +121,7 @@ CAMLprim value  ml_g_type_interface_prerequisites(value type)
     GType *intf = g_type_interface_prerequisites(GType_val(type), &n);
     while (n-- > 0) {
         tmp = res;
-        res = alloc_small(2,0);
+        res = caml_alloc_small(2,0);
         Field(res,0) = Val_GType(intf[n]);
         Field(res,1) = tmp;
     }
@@ -139,7 +139,7 @@ CAMLprim value ml_g_type_register_static(value parent_type, value type_name)
   parent = GType_val (parent_type);
   g_type_query (parent, &query);
   if (query.type == G_TYPE_INVALID)
-    failwith ("g_type_register_static: invalid parent g_type");
+    caml_failwith ("g_type_register_static: invalid parent g_type");
 
   {
     const GTypeInfo info =
@@ -177,21 +177,21 @@ Make_Val_final_pointer_ext(GClosure, _sink , g_closure_ref_and_sink,
 static void notify_destroy(gpointer unit, GClosure *c)
 {
     // printf("release %p\n", &c->data);
-    remove_global_root((value*)&c->data);
+    caml_remove_global_root((value*)&c->data);
 }
 
 static void marshal (GClosure *closure, GValue *ret,
                      guint nargs, const GValue *args,
                      gpointer hint, gpointer marshall_data)
 {
-    value vargs = alloc(3,0);
+    value vargs = caml_alloc(3,0);
 
     CAMLparam1 (vargs);
-    Store_field(vargs, 0, (ret ? Val_GValue_wrap(ret) : alloc(2,0)));
+    Store_field(vargs, 0, (ret ? Val_GValue_wrap(ret) : caml_alloc(2,0)));
     Store_field(vargs, 1, Val_int(nargs));
     Store_field(vargs, 2, Val_GValue_wrap((GValue*)args));
 
-    callback_exn ((value)closure->data, vargs);
+    caml_callback_exn ((value)closure->data, vargs);
 
     CAMLreturn0;
 }
@@ -200,7 +200,7 @@ CAMLprim value ml_g_closure_new (value clos)
 {
     GClosure* closure = g_closure_new_simple(sizeof(GClosure), (gpointer)clos);
     // printf("register %p\n", &closure->data);
-    register_global_root((value*)&closure->data);
+    caml_register_global_root((value*)&closure->data);
     g_closure_add_invalidate_notifier(closure, NULL, notify_destroy);
     g_closure_set_marshal(closure, marshal);
     return Val_GClosure_sink(closure);
@@ -220,8 +220,9 @@ static struct custom_operations ml_custom_GValue =
 
 CAMLprim value ml_g_value_new(void)
 {
-    value ret = alloc_custom(&ml_custom_GValue, sizeof(value)+sizeof(GValue),
-                             20, 1000);
+    value ret = caml_alloc_custom(&ml_custom_GValue,
+				  sizeof(value)+sizeof(GValue),
+				  20, 1000);
     /* create an MLPointer */
     Field(ret,1) = (value)2;
     ((GValue*)&Field(ret,2))->g_type = 0;
@@ -244,8 +245,8 @@ CAMLprim value ml_g_value_release(value val)
 
 CAMLprim GValue* GValue_val(value val)
 {
-    void *v = MLPointer_val(val);
-    if (v == NULL) invalid_argument("GValue_val");
+    void *v = (void *) MLPointer_val(val);
+    if (v == NULL) caml_invalid_argument("GValue_val");
     return (GValue*)v;
 }
 
@@ -274,14 +275,14 @@ static struct custom_operations ml_custom_gboxed =
   custom_serialize_default, custom_deserialize_default };
 CAMLprim value Val_gboxed(GType t, gpointer p)
 {
-    value ret = alloc_custom(&ml_custom_gboxed, 2*sizeof(value), 10, 1000);
+    value ret = caml_alloc_custom(&ml_custom_gboxed, 2*sizeof(value), 10, 1000);
     Store_pointer(ret, g_boxed_copy (t,p));
     Field(ret,2) = (value)t;
     return ret;
 }
 CAMLprim value Val_gboxed_new(GType t, gpointer p)
 {
-    value ret = alloc_custom(&ml_custom_gboxed, 2*sizeof(value), 10, 1000);
+    value ret = caml_alloc_custom(&ml_custom_gboxed, 2*sizeof(value), 10, 1000);
     Store_pointer(ret, p);
     Field(ret,2) = (value)t;
     return ret;
@@ -300,7 +301,7 @@ static value g_value_get_mlvariant (GValue *val)
     value tag = (value)0;
 
     if (! G_IS_VALUE(val))
-      invalid_argument("Gobject.Value.get");
+      caml_invalid_argument("Gobject.Value.get");
 
     type = G_VALUE_TYPE(val);
 
@@ -330,15 +331,15 @@ static value g_value_get_mlvariant (GValue *val)
       break;
     case G_TYPE_FLOAT:
       tag = MLTAG_FLOAT;
-      tmp = copy_double ((double)DATA.v_float);
+      tmp = caml_copy_double ((double)DATA.v_float);
       break;
     case G_TYPE_DOUBLE:
       tag = MLTAG_FLOAT;
-      tmp = copy_double (DATA.v_double);
+      tmp = caml_copy_double (DATA.v_double);
       break;
     case G_TYPE_STRING:
       tag = MLTAG_STRING;
-      tmp = Val_option (DATA.v_pointer, copy_string);
+      tmp = Val_option (DATA.v_pointer, caml_copy_string);
       break;
     case G_TYPE_INTERFACE: /* assume interfaces are for objects */
     case G_TYPE_OBJECT:
@@ -366,11 +367,11 @@ static value g_value_get_mlvariant (GValue *val)
     case G_TYPE_INT64:
     case G_TYPE_UINT64:
       tag = MLTAG_INT64;
-      tmp = copy_int64 (DATA.v_int64);
+      tmp = caml_copy_int64 (DATA.v_int64);
       break;
     }
     if ((long)tag != 0) {
-        ret = alloc_small(2,0);
+        ret = caml_alloc_small(2,0);
         Field(ret,0) = tag;
         Field(ret,1) = tmp;
     }
@@ -436,12 +437,12 @@ static void g_value_set_mlvariant (GValue *val, value arg)
         if (tag == MLTAG_CAML && type == G_TYPE_CAML)
 	  g_value_store_caml_value (val, data);
 	else if (tag == MLTAG_POINTER)
-	  g_value_set_boxed(val, Option_val(data,MLPointer_val,NULL));
+	  g_value_set_boxed(val, (void *) Option_val(data,MLPointer_val,NULL));
 	else break;
         return;
     case G_TYPE_POINTER:
         if (tag != MLTAG_POINTER && tag != MLTAG_OBJECT) break;
-        DATA.v_pointer = Option_val(data,MLPointer_val,NULL);
+        DATA.v_pointer = (void *) Option_val(data,MLPointer_val,NULL);
         return;
     case G_TYPE_INT64:
     case G_TYPE_UINT64:
@@ -456,10 +457,10 @@ static void g_value_set_mlvariant (GValue *val, value arg)
         else break;
         return;
     default:
-        failwith ("Gobject.Value.set : cannot set this value");
+        caml_failwith ("Gobject.Value.set : cannot set this value");
     }
     /* fprintf(stderr,"value has type %s\n", g_type_name(type)); */
-    failwith ("GObject.Value.set : argument type mismatch");
+    caml_failwith ("GObject.Value.set : argument type mismatch");
     return;
 }
 
@@ -470,14 +471,14 @@ CAMLprim value ml_g_value_get_nativeint(value arg) {
     switch(G_TYPE_FUNDAMENTAL(G_VALUE_TYPE(val))) {
     case G_TYPE_INT:
     case G_TYPE_UINT:
-        return copy_nativeint (DATA.v_int);
+        return caml_copy_nativeint (DATA.v_int);
     case G_TYPE_LONG:
     case G_TYPE_ULONG:
     case G_TYPE_ENUM:
     case G_TYPE_FLAGS:
-        return copy_nativeint (DATA.v_long);
+        return caml_copy_nativeint (DATA.v_long);
     default:
-        invalid_argument ("Gobject.get_nativeint");
+        caml_invalid_argument ("Gobject.get_nativeint");
     }
     return Val_unit;
 }
@@ -487,12 +488,12 @@ CAMLprim value ml_g_value_get_int32(value arg) {
     switch(G_TYPE_FUNDAMENTAL(G_VALUE_TYPE(val))) {
     case G_TYPE_INT:
     case G_TYPE_UINT:
-        return copy_int32 (DATA.v_int);
+        return caml_copy_int32 (DATA.v_int);
     case G_TYPE_ENUM:
     case G_TYPE_FLAGS:
-        return copy_int32 (DATA.v_long);
+        return caml_copy_int32 (DATA.v_long);
     default:
-        failwith ("Gobject.get_int32");
+        caml_failwith ("Gobject.get_int32");
     }
     return Val_unit;
 }
@@ -507,7 +508,7 @@ CAMLprim value ml_g_value_get_pointer (value arg)
     case G_TYPE_POINTER:
         p = DATA.v_pointer; break;
     default:
-	failwith ("Gobject.get_pointer");
+	caml_failwith ("Gobject.get_pointer");
     }
     return Val_pointer(p);
 }
@@ -532,7 +533,7 @@ CAMLprim value ml_g_object_new (value type, value params)
       for (cell = params; cell != Val_unit; cell = Field(cell,1)) {
         param->name = String_val(Field(Field(cell,0),0));
         pspec = g_object_class_find_property (class, param->name);
-        if (!pspec) failwith ("Gobject.create");
+        if (!pspec) caml_failwith ("Gobject.create");
         g_value_init (&param->value, pspec->value_type);
         g_value_set_mlvariant (&param->value, Field(Field(cell,0),1));
         param++;
@@ -580,7 +581,7 @@ CAMLprim value ml_g_object_set_property_dyn (value vobj, value prop, value arg)
 /* gsignal.h */
 
 #define Copy_GSignalQuery(ml_query, ml_params, query) \
-  ml_query = alloc_small(6, 0); \
+  ml_query = caml_alloc_small(6, 0); \
   ml_params = caml_alloc(query->n_params, 0); \
   Store_field(ml_query, 0, Val_int(query->signal_id)); \
   Store_field(ml_query, 1, caml_copy_string (query->signal_name)); \
@@ -617,7 +618,7 @@ CAMLprim value ml_g_signal_query(value ml_i) {
 
   query = malloc(sizeof(GSignalQuery));
   g_signal_query(i, query);
-  if (query->signal_id == 0) invalid_argument("g_signal_query");
+  if (query->signal_id == 0) caml_invalid_argument("g_signal_query");
 
   Copy_GSignalQuery(ml_query, ml_query_params, query);
   free(query);
@@ -658,12 +659,12 @@ CAMLprim value ml_g_signal_emit_by_name (value obj, value sig, value params)
     GSignalQuery query;
 
     if(!g_signal_parse_name(String_val(sig), itype, &signal_id, &detail, TRUE))
-        failwith("GtkSignal.emit_by_name : bad signal name");
+        caml_failwith("GtkSignal.emit_by_name : bad signal name");
     g_value_init (iparams, itype);
     g_value_set_object (iparams, instance);
     g_signal_query (signal_id, &query);
     if (Wosize_val(params) != query.n_params)
-        failwith("GtkSignal.emit_by_name : bad parameters number");
+        caml_failwith("GtkSignal.emit_by_name : bad parameters number");
     return_type = query.return_type & ~G_SIGNAL_TYPE_STATIC_SCOPE;
     if (return_type != G_TYPE_NONE) {
         ret = ml_g_value_new();
diff --git a/lablgtk3/ml_gpointer.c b/lablgtk3/ml_gpointer.c
index ba57c83..430ea15 100644
--- a/lablgtk3/ml_gpointer.c
+++ b/lablgtk3/ml_gpointer.c
@@ -39,8 +39,8 @@ CAMLprim value ml_stable_copy (value v)
         mlsize_t i, wosize = Wosize_val(v);
         int tag = Tag_val(v);
         value ret;
-        if (tag < No_scan_tag) invalid_argument("ml_stable_copy");
-        ret = alloc_shr (wosize, tag);
+        if (tag < No_scan_tag) caml_invalid_argument("ml_stable_copy");
+        ret = caml_alloc_shr (wosize, tag);
         for (i=0; i < wosize; i++) Field(ret,i) = Field(v,i);
         CAMLreturn(ret);
     }
@@ -50,7 +50,7 @@ CAMLprim value ml_string_at_pointer (value ofs, value len, value ptr)
 {
     char *start = ((char*)Pointer_val(ptr)) + Option_val(ofs, Int_val, 0);
     int length = Option_val(len, Int_val, strlen(start));
-    value ret = alloc_string(length);
+    value ret = caml_alloc_string(length);
     memcpy ((char*)ret, start, length);
     return ret;
 }
@@ -68,7 +68,7 @@ CAMLprim value ml_set_int_at_pointer (value ptr, value n)
 
 CAMLprim value ml_long_at_pointer (value ptr)
 {
-    return copy_nativeint(*(long*)Pointer_val(ptr));
+    return caml_copy_nativeint(*(long*)Pointer_val(ptr));
 }
 
 CAMLprim value ml_set_long_at_pointer (value ptr, value n)
@@ -112,5 +112,5 @@ CAMLprim value ml_gpointer_blit (value region1, value region2)
 
 CAMLprim value ml_gpointer_get_addr (value region)
 {
-    return copy_nativeint ((long)ml_gpointer_base (region));
+    return caml_copy_nativeint ((long)ml_gpointer_base (region));
 }
diff --git a/lablgtk3/ml_gtk.c b/lablgtk3/ml_gtk.c
index c3b7c15..a0f37d9 100644
--- a/lablgtk3/ml_gtk.c
+++ b/lablgtk3/ml_gtk.c
@@ -49,7 +49,7 @@ void ml_raise_gtk (const char *errmsg)
   static const value * exn = NULL;
   if (exn == NULL)
       exn = caml_named_value ("gtkerror");
-  raise_with_string (*exn, (char*)errmsg);
+  caml_raise_with_string (*exn, (char*)errmsg);
 }
 
 /* conversion functions */
@@ -109,7 +109,7 @@ CAMLprim value ml_gtk_accelerator_parse(value acc)
   GdkModifierType mods;
   gtk_accelerator_parse(String_val(acc), &key, &mods);
   vmods = mods ? Val_GdkModifier_flags(mods) : Val_emptylist;
-  tup = alloc_small(2, 0);
+  tup = caml_alloc_small(2, 0);
   Field(tup, 0) = Val_int(key);
   Field(tup, 1) = vmods;
   CAMLreturn(tup);
@@ -312,7 +312,7 @@ CAMLprim value ml_gtk_widget_get_pointer (value w)
     int x,y;
     value ret;
     gtk_widget_get_pointer (GtkWidget_val(w), &x, &y);
-    ret = alloc_small (2,0);
+    ret = caml_alloc_small (2,0);
     Field(ret,0) = Val_int(x);
     Field(ret,1) = Val_int(y);
     return ret;
@@ -349,7 +349,7 @@ ML_1 (gtk_widget_get_window, GtkWidget_val, Val_GdkWindow)
 ML_1 (gtk_widget_get_parent, GtkWidget_val, Val_GtkWidget)
 static value Val_GtkAllocation (GtkAllocation allocation)
 {
-    value ret = alloc_small (4, 0);
+    value ret = caml_alloc_small (4, 0);
     Field(ret,0) = Val_int(allocation.x);
     Field(ret,1) = Val_int(allocation.y);
     Field(ret,2) = Val_int(allocation.width);
@@ -394,7 +394,7 @@ CAMLprim value ml_gtk_widget_style_get_property (value w, value n)
         g_value_init (gv, G_PARAM_SPEC_VALUE_TYPE (pspec));
         gtk_widget_style_get_property (widget, name, gv);
     } else {
-        invalid_argument("Gobject.Widget.style_get_property");
+        caml_invalid_argument("Gobject.Widget.style_get_property");
     }
     CAMLreturn (ret);
 }
@@ -432,7 +432,7 @@ CAMLprim value ml_gtk_drag_dest_set (value w, value f, value t, value a)
   n_targets = Wosize_val(t);
   if (n_targets)
       targets = (GtkTargetEntry *)
-	  alloc (Wosize_asize(n_targets * sizeof(GtkTargetEntry)),
+	  caml_alloc (Wosize_asize(n_targets * sizeof(GtkTargetEntry)),
 		 Abstract_tag);
   for (i=0; i<n_targets; i++) {
     targets[i].target = (gchar*)Bytes_val(Field(Field(t, i), 0));
@@ -471,8 +471,8 @@ CAMLprim value ml_gtk_drag_source_set (value w, value m, value t, value a)
   n_targets = Wosize_val(t);
   if (n_targets)
       targets = (GtkTargetEntry *)
-	  alloc (Wosize_asize(n_targets * sizeof(GtkTargetEntry)),
-		 Abstract_tag);
+	  caml_alloc (Wosize_asize(n_targets * sizeof(GtkTargetEntry)),
+		      Abstract_tag);
   for (i=0; i<n_targets; i++) {
     targets[i].target = (gchar*)Bytes_val(Field(Field(t, i), 0));
     targets[i].flags = Flags_Target_flags_val(Field(Field(t, i), 1));
@@ -504,7 +504,7 @@ CAMLprim value ml_gtk_selection_data_get_data (value val)
     const guchar *data = gtk_selection_data_get_data_with_length(sel, &length);
 
     if (length < 0) ml_raise_null_pointer();
-    ret = alloc_string (length);
+    ret = caml_alloc_string (length);
     if (length) memcpy ((void*)ret, data, length);
     return ret;
 }
@@ -512,7 +512,7 @@ ML_1 (gtk_selection_data_copy, GtkSelectionData_val, Val_GtkSelectionData)
 
 ML_4 (gtk_selection_data_set, GtkSelectionData_val, GdkAtom_val, Int_val,
       Insert((guchar*)String_option_val(arg4))
-      Option_val(arg4, string_length, -1) Ignore,
+      Option_val(arg4, caml_string_length, -1) Ignore,
       Unit)
 
 ML_3 (gtk_selection_owner_set, GtkWidget_val, GdkAtom_val,
@@ -552,7 +552,7 @@ static void clipboard_received_func (GtkClipboard *clipboard,
                                      gpointer data)
 {
   value arg = Val_pointer (selection_data);
-  callback_exn (*(value*)data, arg);
+  caml_callback_exn (*(value*)data, arg);
   ml_global_root_destroy (data);
 }
 CAMLprim value ml_gtk_clipboard_request_contents (value c, value a, value f)
@@ -566,8 +566,8 @@ static void clipboard_text_received_func (GtkClipboard *clipboard,
                                           const gchar *text,
                                           gpointer data)
 {
-  value arg = (text != NULL ? ml_some(copy_string(text)) : Val_unit);
-  callback_exn (*(value*)data, arg);
+  value arg = (text != NULL ? ml_some(caml_copy_string(text)) : Val_unit);
+  caml_callback_exn (*(value*)data, arg);
   ml_global_root_destroy (data);
 }
 CAMLprim value ml_gtk_clipboard_request_text (value c, value f)
@@ -605,7 +605,7 @@ CAMLprim value ml_gtk_clipboard_wait_for_targets (value c)
   if (targets != NULL) {
     while (n_targets > 0) {
       result = Val_GdkAtom(targets[--n_targets]);
-      new_cell = alloc_small(2,0);
+      new_cell = caml_alloc_small(2,0);
       Field(new_cell,0) = result;
       Field(new_cell,1) = last_cell;
       last_cell = new_cell;
@@ -638,7 +638,7 @@ static void ml_gtk_simple_callback (GtkWidget *w, gpointer data)
 {
     value val, *clos = (value*)data;
     val = Val_GtkWidget(w);
-    callback_exn (*clos, val);
+    caml_callback_exn (*clos, val);
 }
 CAMLprim value ml_gtk_container_foreach (value w, value clos)
 {
@@ -820,8 +820,8 @@ ml_activate_link_func (GtkAboutDialog *about, const gchar *link, gpointer data)
 {
   value v_link, *closure;
   closure = data;
-  v_link = copy_string (link);
-  callback_exn (*closure, v_link);
+  v_link = caml_copy_string (link);
+  caml_callback_exn (*closure, v_link);
 }
 
 /* not in 3
@@ -913,13 +913,13 @@ CAMLprim value ml_gtk_init (value argv)
     int argc = Wosize_val(argv), i;
     CAMLlocal1 (copy);
 
-    copy = (argc ? alloc (argc, Abstract_tag) : Atom(0));
+    copy = (argc ? caml_alloc (argc, Abstract_tag) : Atom(0));
     for (i = 0; i < argc; i++) Field(copy,i) = Field(argv,i);
     if( !gtk_init_check (&argc, (char ***)&copy) ){
       ml_raise_gtk ("ml_gtk_init: initialization failed");
     }
 
-    argv = (argc ? alloc (argc, 0) : Atom(0));
+    argv = (argc ? caml_alloc (argc, 0) : Atom(0));
     for (i = 0; i < argc; i++) caml_modify(&Field(argv,i), Field(copy,i));
     CAMLreturn (argv);
 }
@@ -934,14 +934,14 @@ ML_1 (gtk_grab_remove, GtkWidget_val, Unit)
 ML_0 (gtk_grab_get_current, Val_GtkWidget)
 CAMLprim value ml_gtk_get_version (value unit)
 {
-    value ret = alloc_small(3,0);
+    value ret = caml_alloc_small(3,0);
     Field(ret,0) = Val_int(gtk_major_version);
     Field(ret,1) = Val_int(gtk_minor_version);
     Field(ret,2) = Val_int(gtk_micro_version);
     return ret;
 }
 
-ML_0 (gtk_get_current_event_time, copy_int32)
+ML_0 (gtk_get_current_event_time, caml_copy_int32)
 ML_0 (gtk_get_current_event, Val_GdkEvent)
 ML_1 (gtk_get_event_widget, GdkEvent_val, Val_GtkWidget)
 ML_2 (gtk_propagate_event, GtkWidget_val, GdkEvent_val, Unit)
diff --git a/lablgtk3/ml_gtkedit.c b/lablgtk3/ml_gtkedit.c
index b719502..1147b29 100644
--- a/lablgtk3/ml_gtkedit.c
+++ b/lablgtk3/ml_gtkedit.c
@@ -63,10 +63,10 @@ CAMLprim value ml_gtk_editable_get_selection_bounds(value w)
     value res = Val_unit;
 
     if (gtk_editable_get_selection_bounds(GtkEditable_val(w), &start, &end)) {
-        tmp = alloc_small(2,0);
+        tmp = caml_alloc_small(2,0);
         Field(tmp,0) = Val_int(start);
         Field(tmp,1) = Val_int(end);
-        res = alloc_small(1,0);
+        res = caml_alloc_small(1,0);
         Field(res,0) = tmp;
     }
     CAMLreturn(res);
@@ -75,7 +75,7 @@ CAMLprim value ml_gtk_editable_insert_text (value w, value s, value pos)
 {
     int position = Int_val(pos);
     gtk_editable_insert_text (GtkEditable_val(w), String_val(s),
-			      string_length(s), &position);
+			      caml_string_length(s), &position);
     return Val_int(position);
 }
 ML_3 (gtk_editable_delete_text, GtkEditable_val, Int_val, Int_val, Unit)
@@ -189,9 +189,9 @@ static gboolean ml_gtk_entry_completion_match_func (GtkEntryCompletion *completi
   value *closure = user_data;
   CAMLparam0();
   CAMLlocal3(vkey, viter, vret);
-  vkey = copy_string(key);
+  vkey = caml_copy_string(key);
   viter = Val_GtkTreeIter(iter);
-  vret = callback2_exn(*closure, vkey, viter);
+  vret = caml_callback2_exn(*closure, vkey, viter);
   if (Is_exception_result(vret))
     CAMLreturn(FALSE);
   CAMLreturn(Bool_val(vret));
diff --git a/lablgtk3/ml_gtkfile.c b/lablgtk3/ml_gtkfile.c
index 7503f4f..cff3b38 100644
--- a/lablgtk3/ml_gtkfile.c
+++ b/lablgtk3/ml_gtkfile.c
@@ -59,7 +59,7 @@ CAMLprim value ml_gtkfile_init(value unit)
 
 static value some_string_and_free(gchar *s)
 {
-  value v = s ? ml_some(copy_string(s)) : Val_unit;
+  value v = s ? ml_some(caml_copy_string(s)) : Val_unit;
   g_free(s);
   return v;
 }
@@ -103,8 +103,8 @@ static gboolean ml_gtk_file_filter_func (const GtkFileFilterInfo *filter_info,
   l = Val_emptylist;
 #define CONS_MEMBER(memb, flag) \
   if (filter_info->contains & GTK_FILE_FILTER_##flag) {	\
-    s = copy_string (filter_info->memb);	\
-    v = alloc_small(2, 0);			\
+    s = caml_copy_string (filter_info->memb);	\
+    v = caml_alloc_small(2, 0);			\
     Field(v, 0) = MLTAG_##flag;			\
     Field(v, 1) = s;				\
     l = ml_cons (v, l);				\
@@ -114,7 +114,7 @@ static gboolean ml_gtk_file_filter_func (const GtkFileFilterInfo *filter_info,
   CONS_MEMBER (uri, URI)
   CONS_MEMBER (filename, FILENAME)
 #undef CONS_MEMBER
-  r = callback_exn (*cb, l);
+  r = caml_callback_exn (*cb, l);
   if (Is_exception_result (r)) CAMLreturn(TRUE);
   CAMLreturn (Bool_val(r));
 }
diff --git a/lablgtk3/ml_gtkmenu.c b/lablgtk3/ml_gtkmenu.c
index 3b6148c..369ef3d 100644
--- a/lablgtk3/ml_gtkmenu.c
+++ b/lablgtk3/ml_gtkmenu.c
@@ -152,12 +152,12 @@ static void menu_popup_cb(GtkMenu *menu, gint *x, gint *y,
     *y = Int_val(Field(res,1));
     *push_in = Int_val(Field(res,2));
     caml_remove_global_root(clos);
-    stat_free(clos);
+    caml_stat_free(clos);
 }
 CAMLprim value ml_gtk_menu_popup_at (value menu, value button,
                                      value time, value func)
 {
-    value *clos = stat_alloc(sizeof(value));
+    value *clos = caml_stat_alloc(sizeof(value));
     *clos = func;
     caml_register_global_root(clos);
     gtk_menu_popup(GtkMenu_val(menu), NULL, NULL, &menu_popup_cb, clos,
diff --git a/lablgtk3/ml_gtkmisc.c b/lablgtk3/ml_gtkmisc.c
index e603e89..ebc7719 100644
--- a/lablgtk3/ml_gtkmisc.c
+++ b/lablgtk3/ml_gtkmisc.c
@@ -121,7 +121,7 @@ CAMLprim value ml_gtk_calendar_get_date (value w)
     value ret;
 
     gtk_calendar_get_date (GtkCalendar_val(w), &year, &month, &day);
-    ret = alloc_small (3, 0);
+    ret = caml_alloc_small (3, 0);
     Field(ret,0) = Val_int(year);
     Field(ret,1) = Val_int(month);
     Field(ret,2) = Val_int(day);
@@ -161,7 +161,7 @@ CAMLprim value ml_gtk_label_get_selection_bounds (value label)
   gint s, e;
   value r;
   if (gtk_label_get_selection_bounds (GtkLabel_val(label), &s, &e)) {
-    r = alloc_small(2, 0);
+    r = caml_alloc_small(2, 0);
     Field(r, 0) = Val_int(s);
     Field(r, 1) = Val_int(e);
     r = ml_some(r);
diff --git a/lablgtk3/ml_gtkpack.c b/lablgtk3/ml_gtkpack.c
index 3ac7ed5..1e2349b 100644
--- a/lablgtk3/ml_gtkpack.c
+++ b/lablgtk3/ml_gtkpack.c
@@ -78,7 +78,7 @@ CAMLprim value ml_gtk_box_query_child_packing (value box, value child)
     value ret;
     gtk_box_query_child_packing (GtkBox_val(box), GtkWidget_val(child),
 				 &expand, &fill, &padding, &pack_type);
-    ret = alloc_small(4,0);
+    ret = caml_alloc_small(4,0);
     Field(ret,0) = Val_bool(expand);
     Field(ret,1) = Val_bool(fill);
     Field(ret,2) = Val_int(padding);
diff --git a/lablgtk3/ml_gtksourceview3.c b/lablgtk3/ml_gtksourceview3.c
index c2ec874..2762957 100644
--- a/lablgtk3/ml_gtksourceview3.c
+++ b/lablgtk3/ml_gtksourceview3.c
@@ -212,9 +212,9 @@ GType custom_completion_provider_get_type();
 #define IS_CUSTOM_COMPLETION_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CUSTOM_COMPLETION_PROVIDER))
 #define METHOD(obj, n) (Field(*(obj->caml_object), n))
 // #define METHOD(obj, name) (callback(caml_get_public_method(obj->caml_object, hash_variant(name)), obj->caml_object))
-#define METHOD1(obj, n, arg1) (callback(Field(*(obj->caml_object), n), arg1))
-#define METHOD2(obj, n, arg1, arg2) (callback2(Field(*(obj->caml_object), n), arg1, arg2))
-#define METHOD3(obj, n, arg1, arg2, arg3) (callback3(Field(*(obj->caml_object), n), arg1, arg2, arg3))
+#define METHOD1(obj, n, arg1) (caml_callback(Field(*(obj->caml_object), n), arg1))
+#define METHOD2(obj, n, arg1, arg2) (caml_callback2(Field(*(obj->caml_object), n), arg1, arg2))
+#define METHOD3(obj, n, arg1, arg2, arg3) (caml_callback3(Field(*(obj->caml_object), n), arg1, arg2, arg3))
 
 CAMLprim value ml_custom_completion_provider_new (value obj) {
   CAMLparam1(obj);
@@ -561,7 +561,7 @@ CAMLprim value ml_gtk_source_view_get_mark_attributes(
       GtkSourceView_val(obj), String_val(category), &prio);
   if (attributes) {
     attr_opt = Val_copy(attributes);
-    result = alloc_small(1,0);
+    result = caml_alloc_small(1,0);
     Field(result,0) = attr_opt;
   }
   else
diff --git a/lablgtk3/ml_gtkstock.c b/lablgtk3/ml_gtkstock.c
index fc2e885..88bb2cc 100644
--- a/lablgtk3/ml_gtkstock.c
+++ b/lablgtk3/ml_gtkstock.c
@@ -54,7 +54,7 @@ Make_Val_final_pointer_ext(GtkIconSource, _new, Ignore, gtk_icon_source_free, 5)
 ML_0 (gtk_icon_source_new, Val_GtkIconSource_new)
 ML_2 (gtk_icon_source_set_filename, GtkIconSource_val, String_val, Unit)
 ML_2 (gtk_icon_source_set_pixbuf, GtkIconSource_val, GdkPixbuf_val, Unit)
-ML_1 (gtk_icon_source_get_filename, GtkIconSource_val, copy_string)
+ML_1 (gtk_icon_source_get_filename, GtkIconSource_val, caml_copy_string)
 ML_1 (gtk_icon_source_get_pixbuf, GtkIconSource_val, Val_GdkPixbuf)
 
 ML_2 (gtk_icon_source_set_direction_wildcarded, GtkIconSource_val, Bool_val, Unit)
@@ -81,7 +81,7 @@ CAMLprim value ml_gtk_icon_set_get_sizes(value s)
   gtk_icon_set_get_sizes(GtkIconSet_val(s), &arr, &n);
   p = Val_emptylist;
   for(; n>=0; n--){
-    c = alloc_small(2, Tag_cons);
+    c = caml_alloc_small(2, Tag_cons);
     Field(c, 0) = Val_icon_size(arr[n]);
     Field(c, 1) = p;
     p = c;
@@ -126,11 +126,11 @@ CAMLprim value ml_gtk_stock_lookup(value id)
   gboolean b;
   
   b = gtk_stock_lookup(String_val(id),&r);
-  if (!b) raise_not_found();
+  if (!b) caml_raise_not_found();
   p = Val_emptylist;
 #define TESTANDCONS(mod)\
   if (r.modifier & GDK_##mod##_MASK) \
-    { c = alloc_small(2,Tag_cons);\
+    { c = caml_alloc_small(2,Tag_cons);\
       Field(c,0) = Val_gdkModifier(GDK_##mod##_MASK); Field(c,1) = p; p = c;}
   TESTANDCONS(SHIFT);
   TESTANDCONS(LOCK);
@@ -141,7 +141,7 @@ CAMLprim value ml_gtk_stock_lookup(value id)
   TESTANDCONS(BUTTON4); TESTANDCONS(BUTTON5);
   TESTANDCONS(SUPER); TESTANDCONS(HYPER);
   TESTANDCONS(META); TESTANDCONS(RELEASE);
-  stock_result = alloc_tuple(4);
+  stock_result = caml_alloc_tuple(4);
   Store_field(stock_result,0,Val_string(r.stock_id));
   Store_field(stock_result,1,Val_string(r.label));
   Store_field(stock_result,2,p);
diff --git a/lablgtk3/ml_gtktext.c b/lablgtk3/ml_gtktext.c
index 4fbc4db..f82d38f 100644
--- a/lablgtk3/ml_gtktext.c
+++ b/lablgtk3/ml_gtktext.c
@@ -149,7 +149,7 @@ ML_1(gtk_text_tag_table_get_size, GtkTextTagTable_val, Val_int)
 static void tag_foreach_func (GtkTextTag* t, gpointer user_data)
 {
   value arg = Val_GtkTextTag(t);
-  callback_exn (*(value*)user_data, arg);
+  caml_callback_exn (*(value*)user_data, arg);
 }
 
 CAMLprim value ml_gtk_text_tag_table_foreach (value t, value fun)
@@ -407,7 +407,7 @@ CAMLprim value ml_gtk_text_buffer_get_bounds(value tb)
   GtkTextIter res1,res2;
   gtk_text_buffer_get_bounds(GtkTextBuffer_val(tb), &res1, &res2);
 
-  res = alloc_tuple(2);
+  res = caml_alloc_tuple(2);
   Store_field(res,0,Val_GtkTextIter(&res1));
   Store_field(res,1,Val_GtkTextIter(&res2));
 
@@ -427,7 +427,7 @@ CAMLprim value ml_gtk_text_buffer_get_selection_bounds(value tb)
   CAMLlocal1(res);
   GtkTextIter res1,res2;
   gtk_text_buffer_get_selection_bounds(GtkTextBuffer_val(tb), &res1, &res2);
-  res = alloc_tuple(2);
+  res = caml_alloc_tuple(2);
   Store_field(res,0,Val_GtkTextIter(&res1));
   Store_field(res,1,Val_GtkTextIter(&res2));
   CAMLreturn(res);
@@ -528,7 +528,7 @@ CAMLprim value ml_gtk_text_view_get_line_at_y (value tv, value y)
   int res2;
   gtk_text_view_get_line_at_y(GtkTextView_val(tv),&res1,
 				    Int_val(y),&res2);
-  res = alloc_tuple(2);
+  res = caml_alloc_tuple(2);
   Store_field(res,0,Val_GtkTextIter(&res1));
   Store_field(res,1,Val_int(res2));
 
@@ -545,7 +545,7 @@ CAMLprim value ml_gtk_text_view_get_line_yrange (value tv, value ti)
   gtk_text_view_get_line_yrange(GtkTextView_val(tv),
 				GtkTextIter_val(ti),
 				&y,&h);
-  res = alloc_tuple(2);
+  res = caml_alloc_tuple(2);
   Store_field(res,0,Val_int(y));
   Store_field(res,1,Val_int(h));
   CAMLreturn(res);
@@ -576,7 +576,7 @@ CAMLprim value ml_gtk_text_view_buffer_to_window_coords (value tv,
 					Int_val(x),Int_val(y),
 					&bx,&by);
 
-  res = alloc_tuple(2);
+  res = caml_alloc_tuple(2);
   Store_field(res,0,Val_int(bx));
   Store_field(res,1,Val_int(by));
   CAMLreturn(res);
@@ -595,7 +595,7 @@ CAMLprim value ml_gtk_text_view_window_to_buffer_coords (value tv,
 					Int_val(x),Int_val(y),
 					&bx,&by);
 
-  res = alloc_tuple(2);
+  res = caml_alloc_tuple(2);
   Store_field(res,0,Val_int(bx));
   Store_field(res,1,Val_int(by));
   CAMLreturn(res);
@@ -840,8 +840,8 @@ CAMLprim value ml_gtk_text_iter_##dir##_search (value ti_start, \
 				 Option_val(ti_lim,GtkTextIter_val,NULL));\
   if (!b) res = Val_unit;\
   else \
-    { res = alloc(1,0);\
-      coup = alloc_tuple(2);\
+    { res = caml_alloc(1,0);\
+      coup = caml_alloc_tuple(2);\
       Store_field(coup,0,Val_GtkTextIter(ti1));\
       Store_field(coup,1,Val_GtkTextIter(ti2));\
       Store_field(res,0,coup);};\
@@ -853,7 +853,7 @@ Make_search(backward);
 static gboolean ml_gtk_text_char_predicate(gunichar ch, gpointer user_data)
 {
   value res, *clos = user_data;
-  res = callback_exn (*clos, Val_int(ch));
+  res = caml_callback_exn (*clos, Val_int(ch));
   if (Is_exception_result (res)) {
     CAML_EXN_LOG ("ml_gtk_text_char_predicate");
     return FALSE;
diff --git a/lablgtk3/ml_gtktree.c b/lablgtk3/ml_gtktree.c
index 1ad03e7..6beb599 100644
--- a/lablgtk3/ml_gtktree.c
+++ b/lablgtk3/ml_gtktree.c
@@ -106,7 +106,7 @@ CAMLprim value ml_gtk_tree_path_get_indices(value p)
 {
   gint *indices = gtk_tree_path_get_indices(GtkTreePath_val(p));
   gint i, depth = gtk_tree_path_get_depth(GtkTreePath_val(p));
-  value ret = alloc_tuple(depth);
+  value ret = caml_alloc_tuple(depth);
   for (i = 0; i < depth; i++) Field(ret,i) = Val_int(indices[i]);
   return ret;
 }
@@ -154,7 +154,7 @@ static gboolean gtk_tree_model_foreach_func(GtkTreeModel *model,
   CAMLlocal3(vpath, viter, vret);
   vpath = Val_GtkTreePath_copy(path);
   viter = Val_GtkTreeIter(iter);
-  vret = callback2_exn(*closure, vpath, viter);
+  vret = caml_callback2_exn(*closure, vpath, viter);
   if (Is_exception_result(vret)) {
     CAML_EXN_LOG("gtk_tree_model_foreach_func");
     CAMLreturn(FALSE);
@@ -180,7 +180,7 @@ CAMLprim value ml_gtk_tree_store_newv(value arr)
   int n_columns = Wosize_val(arr);
   int i;
   GType *types = (GType*)
-    (n_columns ? alloc (Wosize_asize(n_columns * sizeof(GType)), Abstract_tag)
+    (n_columns ? caml_alloc (Wosize_asize(n_columns * sizeof(GType)), Abstract_tag)
      : 0);
   for (i=0; i<n_columns; i++)
     types[i] = GType_val(Field(arr,i));
@@ -235,7 +235,7 @@ CAMLprim value ml_gtk_list_store_newv(value arr)
   int n_columns = Wosize_val(arr);
   int i;
   GType *types = (GType*)
-    (n_columns ? alloc (Wosize_asize(n_columns * sizeof(GType)), Abstract_tag)
+    (n_columns ? caml_alloc (Wosize_asize(n_columns * sizeof(GType)), Abstract_tag)
      : 0);
   for (i=0; i<n_columns; i++)
     types[i] = GType_val(Field(arr,i));
@@ -287,7 +287,7 @@ static gboolean gtk_tree_selection_func(GtkTreeSelection *s, GtkTreeModel *m,
 					gpointer clos_p)
 {
   value vp = Val_GtkTreePath_copy(p);
-  value ret = callback2_exn(*(value*)clos_p, vp, Val_bool(cs));
+  value ret = caml_callback2_exn(*(value*)clos_p, vp, Val_bool(cs));
   if (Is_exception_result(ret)) {
     CAML_EXN_LOG("gtk_tree_selection_func");
     return TRUE;
@@ -309,7 +309,7 @@ static void gtk_tree_selection_foreach_func(GtkTreeModel      *model,
 					    gpointer           data)
 {
   value p = Val_GtkTreePath_copy(path);
-  value ret = callback_exn(*(value*)data, p);
+  value ret = caml_callback_exn(*(value*)data, p);
   if (Is_exception_result(ret))
     CAML_EXN_LOG("gtk_tree_selection_foreach_func");
 }
@@ -388,7 +388,7 @@ static void gtk_tree_cell_data_func(GtkTreeViewColumn *tree_column,
   CAMLlocal3(vmod,vit,ret);
   vmod  = Val_GAnyObject(tree_model);
   vit   = Val_GtkTreeIter(iter);
-  ret = callback2_exn(*closure, vmod, vit);
+  ret = caml_callback2_exn(*closure, vmod, vit);
   if (Is_exception_result(ret))
     CAML_EXN_LOG_VERBOSE("gtk_tree_cell_data_func",ret);
   CAMLreturn0;
@@ -461,7 +461,7 @@ CAMLprim value ml_gtk_tree_view_get_cursor (value arg)
   GtkTreePath *path;
   GtkTreeViewColumn *col;
   gtk_tree_view_get_cursor(GtkTreeView_val(arg), &path, &col);
-  ret = alloc_tuple(2);
+  ret = caml_alloc_tuple(2);
   Store_field(ret,0,Val_option(path,Val_GtkTreePath));
   Store_field(ret,1,Val_option(col,Val_GtkWidget));
   CAMLreturn(ret);
@@ -485,7 +485,7 @@ CAMLprim value ml_gtk_tree_view_get_path_at_pos(value treeview,
     CAMLparam0 ();
     CAMLlocal1(tup);
 
-    tup = alloc_tuple(4);
+    tup = caml_alloc_tuple(4);
     Store_field(tup,0,Val_GtkTreePath(gpath));
     Store_field(tup,1,Val_GtkAny(gcolumn));
     Store_field(tup,2,Val_int(cell_x));
@@ -517,7 +517,7 @@ ml_gtk_tree_view_enable_model_drag_dest (value tv, value t, value a)
   int i, n_targets = Wosize_val(t);
   
   if (n_targets)
-    targets = (GtkTargetEntry *) alloc
+    targets = (GtkTargetEntry *) caml_alloc
       ( Wosize_asize(n_targets * sizeof(GtkTargetEntry))
       , Abstract_tag );
   for (i=0; i<n_targets; i++)
@@ -543,7 +543,7 @@ ml_gtk_tree_view_enable_model_drag_source (value tv, value m, value t, value a)
   int i, n_targets = Wosize_val(t);
   
   if (n_targets)
-    targets = (GtkTargetEntry *) alloc
+    targets = (GtkTargetEntry *) caml_alloc
       ( Wosize_asize(n_targets * sizeof(GtkTargetEntry))
       , Abstract_tag );
   for (i=0; i<n_targets; i++)
@@ -576,7 +576,7 @@ ml_gtk_tree_view_get_dest_row_at_pos (value treeview, value x, value y)
     CAMLparam0 ();
     CAMLlocal1(tup);
 
-    tup = alloc_tuple(2);
+    tup = caml_alloc_tuple(2);
     Store_field(tup,0,Val_GtkTreePath(path));
     Store_field(tup,1,Val_tree_view_drop_position(pos));
     CAMLreturn(ml_some (tup));
@@ -596,7 +596,7 @@ ml_gtk_row_separator_func (GtkTreeModel *model,
   CAMLlocal3 (arg1, arg2, mlret);
   arg1 = Val_GAnyObject (model);
   arg2 = Val_GtkTreeIter (iter);
-  mlret = callback2_exn (*closure, arg1, arg2);
+  mlret = caml_callback2_exn (*closure, arg1, arg2);
   if (Is_exception_result (ret))
     CAML_EXN_LOG ("gtk_row_separator_func");
   else
@@ -662,12 +662,12 @@ ml_gtk_tree_view_get_tooltip_context (value treeview, value x, value y, value kb
     &_x, &_y, Bool_val(kbd),
     &model, &path, &iter );
   
-  tup = alloc_tuple(3);
+  tup = caml_alloc_tuple(3);
   Store_field(tup, 0, Val_int(_x));
   Store_field(tup, 1, Val_int(_y));
   opt = Val_unit;
   if (boo) {
-    sub = alloc_tuple(3);
+    sub = caml_alloc_tuple(3);
     Store_field(sub, 0, Val_GAnyObject(model));
     Store_field(sub, 1, Val_GtkTreePath(path));
     Store_field(sub, 2, Val_GtkTreeIter(&iter));
@@ -761,7 +761,7 @@ CAMLprim value ml_gtk_tree_sortable_get_sort_column_id(value m)
   {
     value vo, ret;
     vo = Val_sort_type(order);
-    ret = alloc_small(2, 0);
+    ret = caml_alloc_small(2, 0);
     Field(ret, 0) = Val_int(sort_column_id);
     Field(ret, 1) = vo;
     return ml_some(ret);
@@ -780,7 +780,7 @@ static gint gtk_tree_iter_compare_func(GtkTreeModel *model,
   iter_a = Val_GtkTreeIter(a);
   iter_b = Val_GtkTreeIter(b);
   obj = Val_GAnyObject(model);
-  ret = callback3_exn(*clos, obj, iter_a, iter_b);
+  ret = caml_callback3_exn(*clos, obj, iter_a, iter_b);
   if (Is_exception_result(ret)) {
     CAML_EXN_LOG("gtk_tree_iter_compare_func");
     CAMLreturn(0);
@@ -823,7 +823,7 @@ static gboolean gtk_tree_model_filter_visible_func(GtkTreeModel *model,
   CAMLlocal3(ret, obj, it);
   it  = Val_GtkTreeIter(iter);
   obj = Val_GAnyObject(model);
-  ret = callback2_exn(*clos, obj, it);
+  ret = caml_callback2_exn(*clos, obj, it);
   if (Is_exception_result(ret)) {
     CAML_EXN_LOG("gtk_tree_model_filter_visible_func");
     CAMLreturn(FALSE);
@@ -890,7 +890,7 @@ static void ml_iconview_foreach (GtkIconView *icon_view, GtkTreePath *path,
   value *cb = data;
   value p;
   p = Val_GtkTreePath_copy(path);
-  callback_exn(*cb, p);
+  caml_callback_exn(*cb, p);
 }
 CAMLprim value ml_gtk_icon_view_selected_foreach (value i, value cb)
 {
@@ -912,7 +912,7 @@ CAMLprim value ml_gtk_icon_view_get_selected_items (value i)
   while (l) {
     GtkTreePath *p = l->data;
     path = Val_GtkTreePath(p);
-    cell = alloc_small(2, Tag_cons);
+    cell = caml_alloc_small(2, Tag_cons);
     Field(cell, 0) = path;
     Field(cell, 1) = list;
     list = cell;
@@ -965,7 +965,7 @@ value callback4(value closure, value arg1, value arg2, value arg3, value arg4)
   arg[1] = arg2;
   arg[2] = arg3;
   arg[3] = arg4;
-  return callbackN(closure, 4, arg);
+  return caml_callbackN(closure, 4, arg);
 }
 
 #define ACCESS_PUBLIC_METHOD(method,object, name, block)       \
@@ -1141,7 +1141,7 @@ encode_iter(Custom_model *custom_model, GtkTreeIter *iter, value v)
   { value callback_object = custom_model->callback_object;
   ACCESS_PUBLIC_METHOD(method,callback_object,"custom_encode_iter",
 
-  { value triple = callback2(method,callback_object,v);
+  { value triple = caml_callback2(method,callback_object,v);
     value v1 = Field(triple,0);
     value v2 = Field(triple,1);
     value v3 = Field(triple,2);
@@ -1193,7 +1193,7 @@ custom_model_get_flags (GtkTreeModel *tree_model)
 	  value callback_object = custom_model->callback_object;
 
   ACCESS_PUBLIC_METHOD(method, callback_object, "custom_flags",
-  { value flags_list = callback(method, callback_object);
+  { value flags_list = caml_callback(method, callback_object);
     GtkTreeModelFlags flags = (GtkTreeModelFlags) 0;
     static value iter_persist_hash=0;
     static value list_only_hash=0;
@@ -1221,7 +1221,7 @@ custom_model_get_n_columns (GtkTreeModel *tree_model)
   { Custom_model *custom_model = (Custom_model *) tree_model;
     value callback_object = custom_model->callback_object;
     ACCESS_PUBLIC_METHOD(method,callback_object,"custom_n_columns",
-    { value n_columns = callback(method,callback_object);
+    { value n_columns = caml_callback(method,callback_object);
       return Int_val(n_columns);})}
 }
 
@@ -1234,7 +1234,7 @@ custom_model_get_column_type (GtkTreeModel *tree_model, gint index)
     value callback_object = custom_model->callback_object;
 
   ACCESS_PUBLIC_METHOD(method,callback_object,"custom_get_column_type",
-  { value t = callback2(method,callback_object, Val_int(index));
+  { value t = caml_callback2(method,callback_object, Val_int(index));
     return GType_val(t);})}
 }
 
@@ -1256,9 +1256,9 @@ custom_model_get_iter (GtkTreeModel *tree_model,
      avoiding both copy and finalization) means trusting the OCaml
      programmer not to store the path somewhere... */
   { UNWRAP_OPTION(res,
-		  callback2(method,
-			    callback_object,
-			    Val_GtkTreePath(gtk_tree_path_copy(path))),
+		  caml_callback2(method,
+				 callback_object,
+				 Val_GtkTreePath(gtk_tree_path_copy(path))),
 		  if (res) {
 		    encode_iter(custom_model,iter,res);
 		    return TRUE;
@@ -1283,8 +1283,8 @@ custom_model_get_path (GtkTreeModel *tree_model,
    /* This copy is needed because Caml will eventually free the path from
      the callback when that Caml value is finalized; and GTK will eventually
      free the path we return to it. */
-  { value path = callback2(method,callback_object,
-			 decode_iter(custom_model,iter));
+  { value path = caml_callback2(method,callback_object,
+				decode_iter(custom_model,iter));
     return gtk_tree_path_copy(GtkTreePath_val(path));})}}
 }
 
@@ -1319,7 +1319,7 @@ custom_model_iter_next (GtkTreeModel  *tree_model,
   { value callback_object = custom_model->callback_object;
     ACCESS_PUBLIC_METHOD(method,callback_object,"custom_iter_next",
     { value row = decode_iter(custom_model, iter);
-      UNWRAP_OPTION(res,callback2(method,callback_object, row),
+      UNWRAP_OPTION(res,caml_callback2(method,callback_object, row),
 		    if (res) {
 		      encode_iter(custom_model,iter,res);
 		      return TRUE;
@@ -1342,7 +1342,7 @@ custom_model_iter_children (GtkTreeModel *tree_model,
   { value callback_object = custom_model->callback_object;
   ACCESS_PUBLIC_METHOD(method,callback_object,"custom_iter_children",
   { value arg = decode_iter_option(custom_model,parent);
-    UNWRAP_OPTION(res, callback2(method,callback_object,arg),
+    UNWRAP_OPTION(res, caml_callback2(method,callback_object,arg),
 		  if (res) {
 		    encode_iter(custom_model,iter,res);
 		    return TRUE;
@@ -1365,7 +1365,7 @@ custom_model_iter_has_child (GtkTreeModel *tree_model,
   ACCESS_PUBLIC_METHOD(method, callback_object,"custom_iter_has_child",
 
   { value row = decode_iter(custom_model,iter);
-    return Bool_val(callback2(method,callback_object, row));})}}
+    return Bool_val(caml_callback2(method,callback_object, row));})}}
 }
 
 static gint
@@ -1379,7 +1379,7 @@ custom_model_iter_n_children (GtkTreeModel *tree_model,
   { value callback_object = custom_model->callback_object;
   ACCESS_PUBLIC_METHOD(method,callback_object, "custom_iter_n_children",
   { value arg = decode_iter_option(custom_model,iter);
-    return Int_val(callback2(method,callback_object, arg));})}}
+    return Int_val(caml_callback2(method,callback_object, arg));})}}
 }
 
 static gboolean
@@ -1397,7 +1397,7 @@ custom_model_iter_nth_child (GtkTreeModel *tree_model,
   ACCESS_PUBLIC_METHOD(method, callback_object, "custom_iter_nth_child",
 
   { value arg = decode_iter_option(custom_model,parent);
-    UNWRAP_OPTION(res,callback3(method, callback_object, arg, Val_int(n)),
+    UNWRAP_OPTION(res,caml_callback3(method, callback_object, arg, Val_int(n)),
 		  if (res) {
 		    encode_iter(custom_model,iter,res);
 		    return TRUE;
@@ -1421,7 +1421,7 @@ custom_model_iter_parent (GtkTreeModel *tree_model,
     { value callback_object = custom_model->callback_object;
       ACCESS_PUBLIC_METHOD(method,callback_object, "custom_iter_parent",
       { value row = decode_iter(custom_model,child);
-	UNWRAP_OPTION(res,callback2(method,callback_object,row),
+	UNWRAP_OPTION(res,caml_callback2(method,callback_object,row),
 		      if (res) {
 			encode_iter(custom_model,iter,res);
 			return TRUE;
@@ -1442,7 +1442,7 @@ custom_model_ref_node (GtkTreeModel *tree_model, GtkTreeIter *iter)
     { value callback_object = custom_model->callback_object;
       ACCESS_PUBLIC_METHOD(method, callback_object, "custom_ref_node",
       { value row = decode_iter(custom_model,iter);
-	callback2(method, callback_object, row);})}}
+	caml_callback2(method, callback_object, row);})}}
 }
 
 static void
@@ -1456,7 +1456,7 @@ custom_model_unref_node (GtkTreeModel *tree_model, GtkTreeIter *iter)
     { value callback_object = custom_model->callback_object;
       ACCESS_PUBLIC_METHOD(method, callback_object, "custom_unref_node",
       { value row = decode_iter(custom_model,iter);
-	callback2(method, callback_object, row);})}}
+	caml_callback2(method, callback_object, row);})}}
 }
 
 /*****************************************************************************
@@ -1585,7 +1585,7 @@ CAMLprim value ml_gtk_tree_view_get_visible_range(value treeview) {
      if (! gtk_tree_view_get_visible_range(GtkTreeView_val(treeview),
 					   &startp, &endp))
 	  CAMLreturn(Val_unit);
-     result = alloc_tuple(2);
+     result = caml_alloc_tuple(2);
      Store_field(result, 0, Val_GtkTreePath(startp));
      Store_field(result, 1, Val_GtkTreePath(endp));
      CAMLreturn(ml_some(result));
diff --git a/lablgtk3/ml_pango.c b/lablgtk3/ml_pango.c
index b49f64b..e43bd0e 100644
--- a/lablgtk3/ml_pango.c
+++ b/lablgtk3/ml_pango.c
@@ -143,7 +143,7 @@ CAMLprim value ml_Pango_scale_val (value val)
       r=1;
       break;
     }
-  return copy_double(r);
+  return caml_copy_double(r);
 }
 
 /* PangoLanguage */
@@ -198,7 +198,7 @@ ML_1 (pango_layout_context_changed, PangoLayout_val, Unit)
 CAMLprim value ml_pango_layout_get_size(value layout)
 {
   int width, height;
-  value res = alloc_tuple(2);
+  value res = caml_alloc_tuple(2);
   pango_layout_get_size(PangoLayout_val(layout), &width, &height);
   Field(res,0) = Val_int(width);
   Field(res,1) = Val_int(height);
@@ -207,7 +207,7 @@ CAMLprim value ml_pango_layout_get_size(value layout)
 CAMLprim value ml_pango_layout_get_pixel_size(value layout)
 {
   int width, height;
-  value res = alloc_tuple(2);
+  value res = caml_alloc_tuple(2);
   pango_layout_get_pixel_size(PangoLayout_val(layout), &width, &height);
   Field(res,0) = Val_int(width);
   Field(res,1) = Val_int(height);
@@ -215,7 +215,7 @@ CAMLprim value ml_pango_layout_get_pixel_size(value layout)
 }
 CAMLexport value Val_PangoRectangle(PangoRectangle *rect)
 {
-  value res = alloc_tuple(4);
+  value res = caml_alloc_tuple(4);
   Field(res,0) = Val_int(rect->x); Field(res,1) = Val_int(rect->y);
   Field(res,2) = Val_int(rect->width); Field(res,3) = Val_int(rect->height);
   return res;
@@ -233,7 +233,7 @@ CAMLprim value ml_pango_layout_xy_to_index(value layout, value x, value y)
   value res;
   exact = pango_layout_xy_to_index(PangoLayout_val(layout), Int_val(x),
                                    Int_val(y), &index, &trailing);
-  res = alloc_tuple(3);
+  res = caml_alloc_tuple(3);
   Field(res,0) = Val_int(index);
   Field(res,1) = Val_int(trailing);
   Field(res,2) = Val_bool(exact);
diff --git a/lablgtk3/propcc.ml b/lablgtk3/propcc.ml
deleted file mode 100644
index de477a9..0000000
--- a/lablgtk3/propcc.ml
+++ /dev/null
@@ -1,965 +0,0 @@
-(* -*- caml -*- *)
-(* $Id$ *)
-
-open StdLabels
-open MoreLabels
-
-let caml_keywords = ["type", "kind"; "class", "classe"; "list", "liste"]
-let caml_modules = ["List", "Liste"]
-
-let is_not_uppercase =
-  function
-    'A'..'Z' -> false
-  | _ -> true
-let camlize id =
-  let b = Buffer.create (String.length id + 4) in
-  for i = 0 to String.length id - 1 do
-    match id.[i] with
-      'A'..'Z' as c ->
-        if i > 0 &&
-           (is_not_uppercase id.[i-1] ||
-            i < String.length id - 1 && is_not_uppercase id.[i+1])
-        then
-          Buffer.add_char b '_';
-        Buffer.add_char b (Char.lowercase_ascii c)
-    | '-' -> Buffer.add_char b '_'
-    | c -> Buffer.add_char b c
-  done;
-  let s = Buffer.contents b in
-  try List.assoc s caml_keywords with Not_found -> s
-
-let camlizeM s = try List.assoc s caml_modules with Not_found -> s
-
-let check_suffix s suff =
-  let len1 = String.length s
-  and len2 = String.length suff in
-  len1 > len2 && String.sub s ~pos:(len1 - len2) ~len:len2 = suff
-
-(* Arity of a caml type. Doesn't handle object types... *)
-let arity s =
-  let parens = ref 0
-  and arity = ref 0 in
-  for i = 0 to String.length s - 1 do
-    if s.[i] = '(' || s.[i] = '[' then incr parens
-    else if s.[i] = ')' || s.[i] = ']' then decr parens
-    else if !parens = 0 && s.[i] = '-' && s.[i+1] = '>' then incr arity
-  done;
-  if !parens <> 0 then failwith ("bad type : " ^ s);
-  !arity
-
-let rec min_labelled =
-  function
-    [] -> []
-  | a :: l ->
-      let l = min_labelled l in if l = [] && a = "" then [] else a :: l
-
-
-(* The real data *)
-let conversions = Hashtbl.create 17
-
-let enums =
-  ["Gtk", "GtkEnums",
-   ["Justification"; "Align"; "ArrowType"; "ShadowType"; "ResizeMode";
-    "ReliefStyle"; "ImageType"; "WindowType"; "WindowPosition"; "ButtonsType";
-    "MessageType"; "ButtonBoxStyle"; "PositionType"; "Orientation";
-    "ToolbarStyle"; "IconSize"; "PolicyType"; "CornerType"; "SelectionMode";
-    "SortType"; "WrapMode"; "SpinButtonUpdatePolicy"; "UpdateType";
-    "ProgressBarStyle"; "ProgressBarOrientation"; "CellRendererMode";
-    "CellRendererAccelMode"; "TreeViewColumnSizing"; "SortType";
-    "TextDirection"; "SizeGroupMode"; "StackTransitionType";
-    (* in signals *)
-    "MovementStep";
-    "ScrollStep"; "ScrollType"; "MenuDirectionType"; "DeleteType";
-    "StateType"; (* for canvas *)                 "AnchorType";
-    "DirectionType"; "SensitivityType"; "InputHints"; "InputPurpose";
-    "EntryIconPosition"; "PackDirection"; "TreeViewGridLines";
-    "FileChooserAction"; "FileChooserConfirmation"; "Response"];
-   "Gdk", "GdkEnums",
-   ["ExtensionMode"; "WindowTypeHint"; "EventMask"; "Gravity";
-    (* for canvas *)    "CapStyle"; "JoinStyle"; "LineStyle"];
-   "Pango", "PangoEnums",
-   ["Stretch"; "Style"; "Underline"; "Variant"; "EllipsizeMode"];
-   (* GtkSourceView *)
-   "Gtk", "SourceView2Enums",
-   ["SourceSmartHomeEndType"; "SourceDrawSpacesFlags"];
-   "Gtk3", "SourceView3Enums",
-   ["SourceSmartHomeEndType"; "SourceDrawSpacesFlags"]]
-
-(* These types must be registered with g_boxed_register! *)
-let boxeds =
-  ["Gdk", ["Color"; "Font"; "RGBA"; "Cairo"]; "Pango", ["FontDescription"];
-   "Gtk", ["IconSet"; "SelectionData"; "TextIter"; "TreePath"; "TreeIter"]]
-
-let classes =
-  ["Gdk", ["Image"; "Pixmap"; "Bitmap"; "Screen"; "DragContext"];
-   "Gtk", ["Style"; "TreeStore"; "TreeModel"; "TreeModelFilter"; "Tooltip"]]
-
-let specials =
-  ["GtkWidget", "GObj.conv_widget";
-   "GtkWidget_opt", "GObj.conv_widget_option";
-   "GtkAdjustment", "GData.conv_adjustment";
-   "GtkAdjustment_opt", "GData.conv_adjustment_option"]
-
-let add_pointer conv gtk name =
-  Hashtbl.add conversions ~key:gtk
-    ~data:(Printf.sprintf "(%s : %s data_conv)" conv name);
-  Hashtbl.add conversions ~key:(gtk ^ "_opt")
-    ~data:(Printf.sprintf "(%s_option : %s option data_conv)" conv name)
-
-let add_object = add_pointer "gobject"
-let add_boxed = add_pointer "unsafe_pointer" (* the type is not used *)
-
-let () =
-  List.iter ~f:(fun t -> Hashtbl.add conversions ~key:("g" ^ t) ~data:t)
-    ["boolean"; "char"; "uchar"; "int"; "uint"; "long"; "ulong"; "int32";
-     "uint32"; "int64"; "uint64"; "float"; "double"];
-  List.iter
-    ~f:(fun (gtype, conv) -> Hashtbl.add conversions ~key:gtype ~data:conv)
-    ["gchararray", "string"; "gchararray_opt", "string_option";
-     "string", "string"; "bool", "boolean"; "int", "int"; "int32", "int32";
-     "float", "float"];
-  List.iter enums
-    ~f:(fun (pre, modu, l) ->
-       List.iter l
-         ~f:(fun name ->
-            Hashtbl.add conversions ~key:(pre ^ name)
-              ~data:(Printf.sprintf "%s.Conv.%s" modu (camlize name))));
-  List.iter boxeds
-    ~f:(fun (pre, l) ->
-       List.iter l
-         ~f:(fun name -> add_boxed (pre ^ name) (pre ^ "." ^ camlize name)));
-  List.iter classes
-    ~f:(fun (pre, l) ->
-       List.iter l
-         ~f:(fun t -> add_object (pre ^ t) (pre ^ "." ^ camlize t)));
-  add_object "GObject" "unit obj";
-  add_object "GtkWidget" "Gtk.widget obj"
-
-open Genlex
-
-let lexer =
-  make_lexer ["{"; "}"; ":"; "/"; "("; ")"; "->"; "method"; "signal"]
-
-let rec star ?(acc = []) p (strm__ : _ Stream.t) =
-  match try Some (p strm__) with Stream.Failure -> None with
-    Some x -> let s = strm__ in star ~acc:(x :: acc) p s
-  | _ -> List.rev acc
-
-let may_token tok s = if Stream.peek s = Some tok then Stream.junk s
-
-let ident (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Ident id) -> Stream.junk strm__; id
-  | _ -> raise Stream.Failure
-
-let string (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (String s) -> Stream.junk strm__; s
-  | _ -> raise Stream.Failure
-
-let may_colon p def (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Kwd ":") -> Stream.junk strm__; let s = strm__ in p s
-  | _ -> def
-
-let may_string def (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (String s) -> Stream.junk strm__; s
-  | _ -> def
-
-let may_name s (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Kwd "(") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (Ident id) ->
-          Stream.junk strm__;
-          begin match Stream.peek strm__ with
-            Some (Kwd ")") -> Stream.junk strm__; id
-          | _ -> raise (Stream.Error "")
-          end
-      | _ -> raise (Stream.Error "")
-      end
-  | _ -> camlize s
-
-let next_attr (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Kwd "/") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (Ident id) ->
-          Stream.junk strm__;
-          let ids =
-            try star ~acc:[id] ident strm__ with
-              Stream.Failure -> raise (Stream.Error "")
-          in
-          String.concat ~sep:"" ids
-      | _ -> raise (Stream.Error "")
-      end
-  | _ -> raise Stream.Failure
-
-let attributes =
-  ["Read"; "Write"; "Construct"; "ConstructOnly"; "NoSet"; "Set"; "NoWrap";
-   "Wrap"; "NoGet"; "VSet"; "NoVSet"]
-
-let label_type2 id (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Kwd ":") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (Ident ty) -> Stream.junk strm__; id, ty
-      | _ -> raise (Stream.Error "")
-      end
-  | _ -> "", id
-let label_type (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Ident id) ->
-      Stream.junk strm__;
-      begin try label_type2 id strm__ with
-        Stream.Failure -> raise (Stream.Error "")
-      end
-  | _ -> raise Stream.Failure
-
-type marshal =
-    Function of string
-  | Types of (string list * string list * string)
-
-let return_type (l, types) (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Kwd "->") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (Ident ret) -> Stream.junk strm__; Types (l, types, ret)
-      | _ -> raise (Stream.Error "")
-      end
-  | _ -> Types (l, types, "")
-
-let marshaller (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (String s) -> Stream.junk strm__; Function s
-  | Some (Kwd ":") ->
-      Stream.junk strm__;
-      let types =
-        try star label_type strm__ with
-          Stream.Failure -> raise (Stream.Error "")
-      in
-      let s = strm__ in return_type (List.split types) s
-  | _ -> Types ([], [], "")
-
-let simple_attr (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Kwd "/") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (Ident s) -> Stream.junk strm__; s
-      | _ -> raise (Stream.Error "")
-      end
-  | _ -> raise Stream.Failure
-
-let field (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (String name) ->
-      Stream.junk strm__;
-      let mlname =
-        try may_name name strm__ with
-          Stream.Failure -> raise (Stream.Error "")
-      in
-      begin match Stream.peek strm__ with
-        Some (Ident gtype) ->
-          Stream.junk strm__;
-          begin match Stream.peek strm__ with
-            Some (Kwd ":") ->
-              Stream.junk strm__;
-              begin match Stream.peek strm__ with
-                Some (Ident attr0) ->
-                  Stream.junk strm__;
-                  let attrs =
-                    try star ~acc:[attr0] next_attr strm__ with
-                      Stream.Failure -> raise (Stream.Error "")
-                  in
-                  if not (List.for_all attrs ~f:(List.mem ~set:attributes))
-                  then
-                    raise (Stream.Error "bad attribute");
-                  `Prop (name, mlname, gtype, attrs)
-              | _ -> raise (Stream.Error "")
-              end
-          | _ -> raise (Stream.Error "")
-          end
-      | _ -> raise (Stream.Error "")
-      end
-  | Some (Kwd "method") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (Ident name) ->
-          Stream.junk strm__;
-          let ty =
-            try may_colon string "unit" strm__ with
-              Stream.Failure -> raise (Stream.Error "")
-          in
-          let attrs =
-            try star simple_attr strm__ with
-              Stream.Failure -> raise (Stream.Error "")
-          in
-          if not (List.for_all attrs ~f:(List.mem ~set:["Wrap"])) then
-            raise (Stream.Error "bad attribute");
-          `Method (name, ty, attrs)
-      | _ -> raise (Stream.Error "")
-      end
-  | Some (Kwd "signal") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (Ident name) ->
-          Stream.junk strm__;
-          let m =
-            try marshaller strm__ with
-              Stream.Failure -> raise (Stream.Error "")
-          in
-          let l =
-            try star simple_attr strm__ with
-              Stream.Failure -> raise (Stream.Error "")
-          in
-          if not (List.for_all l ~f:(List.mem ~set:["Wrap"; "NoWrap"])) then
-            raise (Stream.Error "bad attribute");
-          `Signal (name, m, l)
-      | _ -> raise (Stream.Error "")
-      end
-  | _ -> raise Stream.Failure
-
-let split_fields l =
-  List.fold_right l ~init:([], [], [])
-    ~f:(fun field (props, meths, sigs) ->
-       match field with
-         `Prop p -> p :: props, meths, sigs
-       | `Method m -> props, m :: meths, sigs
-       | `Signal s -> props, meths, s :: sigs)
-
-let verb_braces = ref 0
-
-let rec verbatim buf (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some '}' ->
-      Stream.junk strm__;
-      let s = strm__ in
-      if !verb_braces = 0 then Buffer.contents buf
-      else begin decr verb_braces; Buffer.add_char buf '}'; verbatim buf s end
-  | Some '{' ->
-      Stream.junk strm__;
-      let s = strm__ in
-      Buffer.add_char buf '{'; incr verb_braces; verbatim buf s
-  | Some '\\' ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some c ->
-          Stream.junk strm__;
-          let s = strm__ in
-          if c <> '}' && c <> '{' then Buffer.add_char buf '\\';
-          Buffer.add_char buf c;
-          verbatim buf s
-      | _ -> raise (Stream.Error "")
-      end
-  | Some c ->
-      Stream.junk strm__;
-      let s = strm__ in Buffer.add_char buf c; verbatim buf s
-  | _ -> raise Stream.Failure
-
-let read_pair (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Ident cls) ->
-      Stream.junk strm__;
-      let data =
-        try may_string (camlize cls) strm__ with
-          Stream.Failure -> raise (Stream.Error "")
-      in
-      cls, data
-  | _ -> raise Stream.Failure
-
-let qualifier (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Ident id) ->
-      Stream.junk strm__;
-      let data =
-        try may_string "" strm__ with
-          Stream.Failure -> raise (Stream.Error "")
-      in
-      id, data
-  | _ -> raise Stream.Failure
-
-let prefix = ref ""
-let tagprefix = ref ""
-let decls = ref []
-let headers = ref []
-let oheaders = ref []
-let initializers = ref []
-let checks = ref false
-let class_qualifiers =
-  ["abstract"; "notype"; "hv"; "set"; "wrap"; "wrapset"; "vset"; "tag";
-   "wrapsig"; "type"; "gobject"]
-
-let process_phrase ~chars (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Ident "class") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (Ident name) ->
-          Stream.junk strm__;
-          let gtk_name =
-            try may_string (!prefix ^ name) strm__ with
-              Stream.Failure -> raise (Stream.Error "")
-          in
-          let attrs =
-            try star qualifier strm__ with
-              Stream.Failure -> raise (Stream.Error "")
-          in
-          let parent =
-            try may_colon ident "" strm__ with
-              Stream.Failure -> raise (Stream.Error "")
-          in
-          begin match Stream.peek strm__ with
-            Some (Kwd "{") ->
-              Stream.junk strm__;
-              let fields =
-                try star field strm__ with
-                  Stream.Failure -> raise (Stream.Error "")
-              in
-              begin match Stream.peek strm__ with
-                Some (Kwd "}") ->
-                  Stream.junk strm__;
-                  if List.exists attrs
-                       ~f:(fun (x, _) -> not (List.mem x ~set:class_qualifiers))
-                  then
-                    raise (Stream.Error "bad qualifier");
-                  let attrs = ("parent", parent) :: attrs in
-                  let attrs =
-                    if parent = "GObject" then ("gobject", "") :: attrs
-                    else attrs
-                  in
-                  let (props, meths, sigs) = split_fields fields in
-                  decls :=
-                    (name, gtk_name, attrs, props, meths, sigs) :: !decls
-              | _ -> raise (Stream.Error "")
-              end
-          | _ -> raise (Stream.Error "")
-          end
-      | _ -> raise (Stream.Error "")
-      end
-  | Some (Ident "initializer") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (String func) ->
-          Stream.junk strm__; initializers := !initializers @ [func]
-      | _ -> raise (Stream.Error "")
-      end
-  | Some (Ident "header") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (Kwd "{") ->
-          Stream.junk strm__;
-          let h = verbatim (Buffer.create 1000) chars in
-          headers := !headers @ [h]
-      | _ -> raise (Stream.Error "")
-      end
-  | Some (Ident "oheader") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (Kwd "{") ->
-          Stream.junk strm__;
-          let h = verbatim (Buffer.create 1000) chars in
-          oheaders := !oheaders @ [h]
-      | _ -> raise (Stream.Error "")
-      end
-  | Some (Ident "prefix") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (String id) -> Stream.junk strm__; prefix := id
-      | _ -> raise (Stream.Error "")
-      end
-  | Some (Ident "tagprefix") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (String id) -> Stream.junk strm__; tagprefix := id
-      | _ -> raise (Stream.Error "")
-      end
-  | Some (Ident "conversions") ->
-      Stream.junk strm__;
-      let pre1 =
-        try may_string "" strm__ with
-          Stream.Failure -> raise (Stream.Error "")
-      in
-      let pre2 =
-        try may_string pre1 strm__ with
-          Stream.Failure -> raise (Stream.Error "")
-      in
-      begin match Stream.peek strm__ with
-        Some (Kwd "{") ->
-          Stream.junk strm__;
-          let l =
-            try star read_pair strm__ with
-              Stream.Failure -> raise (Stream.Error "")
-          in
-          begin match Stream.peek strm__ with
-            Some (Kwd "}") ->
-              Stream.junk strm__;
-              List.iter l
-                ~f:(fun (k, d) ->
-                   Hashtbl.add conversions ~key:(pre1 ^ k)
-                     ~data:(if pre2 = "" then d else pre2 ^ "." ^ d))
-          | _ -> raise (Stream.Error "")
-          end
-      | _ -> raise (Stream.Error "")
-      end
-  | Some (Ident "classes") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (Kwd "{") ->
-          Stream.junk strm__;
-          let l =
-            try star read_pair strm__ with
-              Stream.Failure -> raise (Stream.Error "")
-          in
-          begin match Stream.peek strm__ with
-            Some (Kwd "}") ->
-              Stream.junk strm__;
-              List.iter l ~f:(fun (k, d) -> add_object k d)
-          | _ -> raise (Stream.Error "")
-          end
-      | _ -> raise (Stream.Error "")
-      end
-  | Some (Ident "boxed") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (Kwd "{") ->
-          Stream.junk strm__;
-          let l =
-            try star read_pair strm__ with
-              Stream.Failure -> raise (Stream.Error "")
-          in
-          begin match Stream.peek strm__ with
-            Some (Kwd "}") ->
-              Stream.junk strm__; List.iter l ~f:(fun (k, d) -> add_boxed k d)
-          | _ -> raise (Stream.Error "")
-          end
-      | _ -> raise (Stream.Error "")
-      end
-  | Some _ -> Stream.junk strm__; raise (Stream.Error "")
-  | _ -> raise End_of_file
-
-let all_props = Hashtbl.create 137
-let all_pnames = Hashtbl.create 137
-let outfile = ref ""
-let ooutfile = ref ""
-
-let process_file f =
-  let base = Filename.chop_extension f in
-  let baseM = String.capitalize_ascii base in
-  prefix := baseM;
-  (* Input *)
-  (* Redefining saves space in bytecode! *)
-  headers := ["open Gobject"; "open Data"; "module Object = GtkObject"];
-  oheaders :=
-    ["open GtkSignal"; "open Gobject"; "open Data"; "let set = set";
-     "let get = get"; "let param = param"];
-  let ic = open_in f in
-  let chars = Stream.of_channel ic in
-  let s = lexer chars in
-  begin try while true do process_phrase ~chars s done with
-    End_of_file -> ()
-  | Stream.Error _ | Stream.Failure ->
-      Printf.eprintf "Parse error in file `%s' before char %d\n" f
-        (Stream.count chars);
-      exit 2
-  | exn ->
-      Printf.eprintf "Exception %s in file `%s' before char %d\n"
-        (Printexc.to_string exn) f (Stream.count chars);
-      exit 2
-  end;
-  (* Preproccess *)
-  let type_name name ~attrs =
-    try List.assoc "type" attrs with
-      Not_found ->
-        if List.mem_assoc "gobject" ~map:attrs then camlize name
-        else if !prefix <> "" then !prefix ^ "." ^ camlize name ^ " obj"
-        else camlize name ^ " obj"
-  in
-  let decls = List.rev !decls in
-  let decls =
-    List.filter decls
-      ~f:(fun (_, _, attrs, _, _, _) -> not (List.mem_assoc "notype" ~map:attrs))
-  in
-  List.iter decls
-    ~f:(fun (name, gtk_name, attrs, _, _, _) ->
-       add_object gtk_name (type_name name ~attrs));
-  (* Output modules *)
-  if !outfile = "" then outfile := base ^ "Props.ml";
-  let oc = open_out !outfile in
-  let ppf = Format.formatter_of_out_channel oc in
-  let out fmt = Format.fprintf ppf fmt in
-  List.iter !headers ~f:(fun s -> out "%s@." s);
-  List.iter !initializers
-    ~f:(fun s ->
-       out "external %s : unit -> unit = \"%s\"@." s s;
-       out "let () = %s ()@." s);
-  let decls =
-    List.map decls
-      ~f:(fun (name, gtk_name, attrs, props, meths, sigs) ->
-         name, gtk_name, attrs,
-         List.filter props
-           ~f:(fun (name, _, gtype, _) ->
-              try
-                ignore (Hashtbl.find conversions gtype);
-                try
-                  let (count, _) = Hashtbl.find all_props (name, gtype) in
-                  incr count; true
-                with Not_found ->
-                  Hashtbl.add all_props ~key:(name, gtype)
-                    ~data:(ref 1, ref "");
-                  true
-              with Not_found ->
-                prerr_endline
-                  ("Warning: no conversion for type " ^ gtype ^ " in class " ^
-                   gtk_name);
-                false),
-         meths,
-         List.filter sigs
-           ~f:(function
-              _, Function _, _ -> true
-            | _, Types (_, l, ret), _ ->
-                List.for_all (if ret = "" then l else ret :: l)
-                  ~f:(fun ty ->
-                     if Hashtbl.mem conversions ty then true
-                     else
-                       begin
-                         prerr_endline
-                           ("Warning: no conversion for type " ^ ty ^
-                            " in class " ^ gtk_name);
-                         false
-                       end)))
-  in
-  let defprop ~name ~mlname ~gtype ~tag =
-    let conv = Hashtbl.find conversions gtype in
-    out "@ @[<hv2>let %s " mlname;
-    if tag <> "gtk" then out ": ([>`%s],_) property " tag;
-    out "=@ @[<hov1>{name=\"%s\";@ conv=%s}@]@]" name conv
-  in
-  let shared_props =
-    Hashtbl.fold all_props ~init:[]
-      ~f:(fun ~key:(name, gtype) ~data:(count, rpname) acc ->
-         if !count <= 1 then acc
-         else
-           let pname = camlize name in
-           let pname =
-             if Hashtbl.mem all_pnames pname then pname ^ "_" ^ gtype
-             else begin Hashtbl.add all_pnames ~key:pname ~data:(); pname end
-           in
-           rpname := "PrivateProps." ^ pname; (pname, name, gtype) :: acc)
-  in
-  if shared_props <> [] then
-    begin
-      out "@[<hv2>module PrivateProps = struct";
-      List.iter (List.sort ~cmp:compare shared_props)
-        ~f:(fun (pname, name, gtype) -> defprop ~name ~mlname:pname ~gtype ~tag:"gtk");
-      out "@]\nend\n@."
-    end;
-  (* Redefining saves space in bytecode! *)
-  out "let may_cons = Property.may_cons\n";
-  out "let may_cons_opt = Property.may_cons_opt\n@.";
-  let may_cons_props props =
-    if props <> [] then
-      begin
-        out "@ @[<hv2>let pl = ";
-        List.iter props
-          ~f:(fun (name, mlname, gtype, _) ->
-             let op =
-               if check_suffix gtype "_opt" then "may_cons_opt"
-               else "may_cons"
-             in
-             out "(@;<0>%s P.%s %s " op (camlize name) mlname);
-        out "pl";
-        for _k = 1 to List.length props do out ")" done;
-        out " in@]"
-      end
-  in
-  let omarshaller ~gtk_class ~name ppf (l, tyl, ret) =
-    let out fmt = Format.fprintf ppf fmt in
-    out "fun f ->@ @[<hov2>marshal%d" (List.length l);
-    if ret <> "" then out "_ret@ ~ret:%s" (Hashtbl.find conversions ret);
-    List.iter tyl ~f:(fun ty -> out "@ %s" ty);
-    out "@ \"%s::%s\"" gtk_class name;
-    if List.for_all l ~f:((=) "") then out " f"
-    else
-      begin let l = min_labelled l in
-        out "@ @[<hov2>(fun ";
-        for i = 1 to List.length l do out "x%d " i done;
-        out "->@ f";
-        let i = ref 0 in
-        List.iter l
-          ~f:(fun p -> incr i; if p = "" then out "@ x%d" !i else out "@ ~%s:x%d" p !i);
-        out ")@]"
-      end;
-    out "@]"
-  in
-  List.iter decls
-    ~f:(fun (name, gtk_class, attrs, props, meths, sigs) ->
-       out "@[<hv2>module %s = struct" (camlizeM name);
-       out "@ @[<hv2>let cast w : %s =@ try_cast w \"%s\"@]"
-         (type_name name ~attrs) gtk_class;
-       let tag =
-         try List.assoc "tag" attrs with
-           Not_found -> !tagprefix ^ String.lowercase_ascii name
-       in
-       if props <> [] then
-         begin
-           out "@ @[<hv2>module P = struct";
-           List.iter props
-             ~f:(fun (name, _, gtype, _attrs) ->
-                let (count, rpname) = Hashtbl.find all_props (name, gtype) in
-                if !count > 1 then
-                  out "@ let %s : ([>`%s],_) property = %s" (camlize name) tag
-                    !rpname
-                else defprop ~name ~mlname:(camlize name) ~gtype ~tag);
-           out "@]@ end"
-         end;
-       if sigs <> [] then
-         begin
-           out "@ @[<hv2>module S = struct@ open GtkSignal";
-           List.iter sigs
-             ~f:(fun (name, marshaller, _) ->
-                out "@ @[<hv2>let %s =" (camlize name);
-                out "@ @[<hov1>{name=\"%s\";@ classe=`%s;@ marshaller=" name
-                  tag;
-                begin match marshaller with
-                  Function s -> out "%s" s
-                | Types ([], [], "") -> out "marshal_unit"
-                | Types ([], [], ret) ->
-                    out "fun f -> marshal0_ret ~ret:%s f"
-                      (Hashtbl.find conversions ret)
-                | Types (l, tyl, ret) ->
-                    omarshaller ~gtk_class ~name ppf
-                      (l, List.map ~f:(Hashtbl.find conversions) tyl, ret)
-                end;
-                out "}@]@]");
-           out "@]@ end"
-         end;
-       if not (List.mem_assoc "abstract" ~map:attrs) then
-         begin let cprops =
-           List.filter props
-             ~f:(fun (_, _, _, a) ->
-                List.mem "ConstructOnly" ~set:a &&
-                not (List.mem "NoSet" ~set:a))
-         in
-           out "@ @[<hv2>let create";
-           List.iter cprops ~f:(fun (_, name, _, _) -> out " ?%s" name);
-           if List.mem_assoc "hv" ~map:attrs then
-             begin
-               out " (dir : Gtk.Tags.orientation) pl : %s ="
-                 (type_name name ~attrs);
-               may_cons_props cprops;
-               out "@ @[<hov2>Object.make";
-               out
-                 "@ (if dir = `HORIZONTAL then \"%sH%s\" else \"%sV%s\")@  pl"
-                 !prefix name !prefix name;
-               out "@]@]"
-             end
-           else
-             begin
-               out " pl : %s =" (type_name name ~attrs);
-               may_cons_props cprops;
-               if List.mem_assoc "gobject" ~map:attrs then
-                 out "@ Gobject.unsafe_create"
-               else out "@ Object.make";
-               out " \"%s\" pl@]" gtk_class
-             end
-         end;
-       List.iter meths
-         ~f:(fun (name, typ, _attrs) ->
-            out "@ @[<hov2>external %s :" name;
-            out "@ @[<hv>[>`%s] obj ->@ %s@]" tag typ;
-            let cname = camlize ("ml" ^ gtk_class) ^ "_" ^ name in
-            out "@ = \"";
-            if arity typ > 4 then out "%s_bc\" \"" cname;
-            out "%s\"@]" cname);
-       let set_props =
-         let set = List.mem_assoc "set" ~map:attrs in
-         List.filter props
-           ~f:(fun (_, _, _, a) ->
-              (set || List.mem "Set" ~set:a) && List.mem "Write" ~set:a &&
-              not
-                (List.mem "ConstructOnly" ~set:a || List.mem "NoSet" ~set:a))
-       in
-       if set_props <> [] then
-         begin let props = set_props in
-           out "@ @[<hv2>@[<hov4>let make_params ~cont pl";
-           List.iter props ~f:(fun (_, name, _, _) -> out "@ ?%s" name);
-           out " =@]";
-           may_cons_props props;
-           out "@ cont pl@]"
-         end;
-       if !checks && (props <> [] || sigs <> []) then
-         begin
-           if List.mem_assoc "abstract" ~map:attrs then
-             out "@ @[<hv2>let check w ="
-           else
-             begin
-               out "@ @[<hv2>let check () =";
-               out "@ let w = create%s [] in"
-                 (if List.mem_assoc "hv" ~map:attrs then " `HORIZONTAL"
-                  else "")
-             end;
-           if props <> [] then out "@ let c p = Property.check w p in";
-           if sigs <> [] then
-             begin
-               out "@ let closure = Closure.create ignore in";
-               out "@ let s name = GtkSignal.connect_by_name";
-               out " w ~name ~closure ~after:false in"
-             end;
-           out "@ @[<hov>";
-           List.iter props
-             ~f:(fun (name, _, _gtype, attrs) ->
-                if List.mem "Read" ~set:attrs then
-                  out "c P.%s;@ " (camlize name));
-           List.iter sigs ~f:(fun (name, _, _) -> out "s %s;@ " name);
-           out "()@]"
-         end;
-       out "@]@.end\n@.");
-  close_out oc;
-  (* Output classes *)
-  if !ooutfile = "" then ooutfile := "o" ^ !outfile;
-  let oc = open_out !ooutfile in
-  let ppf = Format.formatter_of_out_channel oc in
-  let out fmt = Format.fprintf ppf fmt in
-  List.iter !oheaders ~f:(fun s -> out "%s@." s);
-  out "open %s@."
-    (String.capitalize_ascii (Filename.chop_extension !outfile));
-  out "@[<hv>";
-  let oprop ~name ~gtype ppf pname =
-    try
-      let conv = List.assoc gtype specials in
-      Format.fprintf ppf "{%s.P.%s with conv=%s}" (camlizeM name)
-        (camlize pname) conv
-    with Not_found ->
-      Format.fprintf ppf "%s.P.%s" (camlizeM name) (camlize pname)
-  in
-  List.iter decls
-    ~f:(fun (name, gtk_class, attrs, props, meths, sigs) ->
-       let wrap = List.mem_assoc "wrap" ~map:attrs in
-       let wrapset = wrap || List.mem_assoc "wrapset" ~map:attrs in
-       let wr_props =
-         List.filter props
-           ~f:(fun (_, _, _, set) ->
-              let has = List.mem ~set in
-              (wrapset || has "Wrap") && has "Write" &&
-              not (has "ConstructOnly" || has "NoWrap"))
-       and rd_props =
-         List.filter props
-           ~f:(fun (_, _, _, set) ->
-              let has = List.mem ~set in
-              (wrap || has "Wrap") && has "Read" &&
-              not (has "NoWrap" || has "NoGet"))
-       and wr_meths =
-         List.filter meths
-           ~f:(fun (_, _, attrs) -> List.mem "Wrap" ~set:attrs)
-       in
-       if wr_props <> [] || rd_props <> [] || wr_meths <> [] then
-         begin
-           (* pre 3.10
-           out "@ @[<hv2>class virtual %s_props = object (self)" (camlize name);
-           out "@ method private virtual obj : _ obj";
-           List.iter wr_props ~f:(fun (pname,mlname,gtype,_) ->
-             out "@ @[<hv2>method set_%s =@ set %a self#obj@]"
-               mlname (oprop ~name ~gtype) pname);
-           List.iter rd_props ~f:(fun (pname,mlname,gtype,_) ->
-             out "@ @[<hv2>method %s =@ get %a self#obj@]"
-               mlname (oprop ~name ~gtype) pname);
-           List.iter wr_meths ~f:(fun (mname,typ,_) ->
-             out "@ @[<hv2>method %s %s=@ %s.%s self#obj@]"
-               mname (if typ = "unit" then "() " else "") (camlizeM name) mname);
-           *)
-           (* post 3.10 *)
-           out "@ @[<hv2>class virtual %s_props = object" (camlize name);
-           out "@ val virtual obj : _ obj";
-           List.iter wr_props
-             ~f:(fun (pname, mlname, gtype, _) ->
-                out "@ @[<hv2>method set_%s =@ set %a obj@]" mlname
-                  (oprop ~name ~gtype) pname);
-           List.iter rd_props
-             ~f:(fun (pname, mlname, gtype, _) ->
-                out "@ @[<hv2>method %s =@ get %a obj@]" mlname
-                  (oprop ~name ~gtype) pname);
-           List.iter wr_meths
-             ~f:(fun (mname, typ, _) ->
-                out "@ @[<hv2>method %s %s=@ %s.%s obj@]" mname
-                  (if typ = "unit" then "() " else "") (camlizeM name) mname);
-           out "@]@ end@ "
-         end;
-       let vset = List.mem_assoc "vset" ~map:attrs in
-       let vprops =
-         List.filter props
-           ~f:(fun (_, _, _, set) ->
-              let has = List.mem ~set in
-              (vset || has "VSet") && has "Write" &&
-              not (has "ConstructOnly" || has "NoVSet"))
-       in
-       if vprops <> [] then
-         begin
-           out "@ @[<hv2>let %s_param = function" (camlize name);
-           List.iter vprops
-             ~f:(fun (pname, mlname, gtype, _) ->
-                out "@ @[<hv4>| `%s p ->@ param %a p@]"
-                  (String.uppercase_ascii mlname) (oprop ~name ~gtype) pname);
-           out "@]@ "
-         end;
-       let wsig = List.mem_assoc "wrapsig" ~map:attrs in
-       let wsigs =
-         List.filter sigs
-           ~f:(fun (_, _, attrs) ->
-              List.mem "Wrap" ~set:attrs ||
-              wsig && not (List.mem "NoWrap" ~set:attrs))
-       in
-       if wsigs <> [] then
-         begin
-           out "@ @[<hv2>class virtual %s_sigs = object (self)"
-             (camlize name);
-           out "@ @[<hv2>method private virtual connect :";
-           out "@ 'b. ('a,'b) GtkSignal.t -> callback:'b -> GtkSignal.id@]";
-           out "@ @[<hv2>method private virtual notify :";
-           out
-             "@ 'b. ('a,'b) property -> callback:('b -> unit) -> GtkSignal.id@]";
-           List.iter wsigs
-             ~f:(fun (sname, types, _) ->
-                match types with
-                  Types (l, tyl, ret)
-                  when List.exists tyl ~f:(List.mem_assoc ~map:specials) ->
-                    let convs =
-                      List.map tyl
-                        ~f:(fun ty ->
-                           try List.assoc ty specials with
-                             Not_found -> Hashtbl.find conversions ty)
-                    in
-                    out "@ @[<hov2>method %s =@ self#connect" sname;
-                    out "@ @[<hov1>{%s.S.%s with@ marshaller = %a}@]@]"
-                      (camlizeM name) sname
-                      (omarshaller ~gtk_class ~name:sname) (l, convs, ret)
-                | _ ->
-                    out "@ @[<hv2>method %s =@ self#connect %s.S.%s@]" sname
-                      (camlizeM name) sname);
-           (* notify: easy connection to "foo::notify" signals for "foo"
-            * properties. *)
-           List.iter rd_props
-             ~f:(fun (pname, mlname, gtype, _) ->
-                out "@ @[<hov2>method notify_%s ~callback =" mlname;
-                out "@ @[<hov1>self#notify %a ~callback@]@]"
-                  (oprop ~name ~gtype) pname);
-           out "@]@ end@ "
-         end);
-  out "@.";
-  close_out oc;
-  outfile := "";
-  ooutfile := ""
-
-let main () =
-  Arg.parse
-    ["-checks", Arg.Set checks, "generate code for checks";
-     "-o", Arg.String (fun s -> outfile := s), "basic output file name";
-     "-oo", Arg.String (fun s -> ooutfile := s), "wrappers output file name"]
-    process_file "usage: propcc <options> file.props ..."
-
-let () = Printexc.print main ()
diff --git a/lablgtk3/propcc.ml4 b/lablgtk3/propcc.ml4
deleted file mode 100644
index 98cc0d7..0000000
--- a/lablgtk3/propcc.ml4
+++ /dev/null
@@ -1,688 +0,0 @@
-(* -*- caml -*- *)
-(* $Id$ *)
-
-open StdLabels
-open MoreLabels
-
-let caml_keywords = ["type","kind"; "class","classe"; "list", "liste"]
-let caml_modules = ["List", "Liste"]
-
-let is_not_uppercase = function
-  | 'A' .. 'Z' -> false
-  | _ -> true
-let camlize id =
-  let b = Buffer.create (String.length id + 4) in
-  for i = 0 to String.length id - 1 do
-    match id.[i] with
-    | 'A' .. 'Z' as c ->
-	if i > 0 && 
-	  (is_not_uppercase id.[i-1] || 
-	  (i < String.length id - 1 && is_not_uppercase id.[i+1]))
-	then Buffer.add_char b '_' ;
-	Buffer.add_char b (Char.lowercase_ascii c)
-    | '-' ->
-	Buffer.add_char b '_'
-    | c ->
-	Buffer.add_char b c
-  done;
-  let s = Buffer.contents b in
-  try List.assoc s caml_keywords with Not_found -> s
-
-let camlizeM s =
-  try List.assoc s caml_modules with Not_found -> s
-
-let check_suffix s suff =
-  let len1 = String.length s and len2 = String.length suff in
-  len1 > len2 && String.sub s ~pos:(len1-len2) ~len:len2 = suff
-
-(* Arity of a caml type. Doesn't handle object types... *)
-let arity s =
-  let parens = ref 0 and arity = ref 0 in
-  for i = 0 to String.length s - 1 do
-    if s.[i] = '(' || s.[i] = '[' then incr parens else
-    if s.[i] = ')' || s.[i] = ']' then decr parens else
-    if !parens = 0 && s.[i] = '-' && s.[i+1] = '>' then incr arity
-  done;
-  if !parens <> 0 then failwith ("bad type : " ^ s);
-  !arity
-
-let rec min_labelled = function
-  | [] -> []
-  | a :: l ->
-      let l = min_labelled l in
-      if l = [] && a = "" then [] else a::l
-
-
-(* The real data *)
-let conversions = Hashtbl.create 17
-
-let enums = [
-  "Gtk", "GtkEnums",
-  [ "Justification"; "Align"; "ArrowType"; "ShadowType"; "ResizeMode";
-    "ReliefStyle"; "ImageType"; "WindowType"; "WindowPosition";
-    "ButtonsType"; "MessageType"; "ButtonBoxStyle"; "PositionType";
-    "Orientation"; "ToolbarStyle"; "IconSize"; "PolicyType"; "CornerType";
-    "SelectionMode"; "SortType"; "WrapMode"; "SpinButtonUpdatePolicy";
-    "UpdateType"; "ProgressBarStyle"; "ProgressBarOrientation";
-    "CellRendererMode"; "CellRendererAccelMode"; "TreeViewColumnSizing";
-    "SortType"; "TextDirection"; "SizeGroupMode"; "StackTransitionType"; (* in signals *)
-    "MovementStep"; "ScrollStep"; "ScrollType"; "MenuDirectionType";
-    "DeleteType"; "StateType"; (* for canvas *) "AnchorType";
-    "DirectionType"; "SensitivityType"; "InputHints"; "InputPurpose";
-    "EntryIconPosition"; "PackDirection"; "TreeViewGridLines";
-    "FileChooserAction"; "FileChooserConfirmation"; "Response"
-  ];
-  "Gdk", "GdkEnums",
-  [ "ExtensionMode"; "WindowTypeHint"; "EventMask"; "Gravity";
-    (* for canvas *) "CapStyle"; "JoinStyle"; "LineStyle" ];
-  "Pango", "PangoEnums",
-  [ "Stretch"; "Style"; "Underline"; "Variant"; "EllipsizeMode" ];
-  (* GtkSourceView *)
-  "Gtk", "SourceView2Enums",
-  [ "SourceSmartHomeEndType"; "SourceDrawSpacesFlags" ];
-  "Gtk3", "SourceView3Enums",
-  [ "SourceSmartHomeEndType"; "SourceDrawSpacesFlags" ]
-
-]
-
-(* These types must be registered with g_boxed_register! *)
-let boxeds = [
-  "Gdk", ["Color"; "Font"; "RGBA"; "Cairo"];
-  "Pango", ["FontDescription";];
-  "Gtk", ["IconSet";"SelectionData";"TextIter";"TreePath"; "TreeIter";];
-]
-
-let classes = [
-  "Gdk", [ "Image"; "Pixmap"; "Bitmap"; "Screen"; "DragContext";];
-  "Gtk", [ "Style"; "TreeStore"; "TreeModel"; "TreeModelFilter"; "Tooltip" ]
-]
-
-let specials = [
-  "GtkWidget", "GObj.conv_widget";
-  "GtkWidget_opt", "GObj.conv_widget_option";
-  "GtkAdjustment", "GData.conv_adjustment";
-  "GtkAdjustment_opt", "GData.conv_adjustment_option";
-]
-
-let add_pointer conv gtk name =
-  Hashtbl.add conversions ~key:gtk
-    ~data:(Printf.sprintf "(%s : %s data_conv)" conv name);
-  Hashtbl.add conversions ~key:(gtk ^ "_opt")
-    ~data:(Printf.sprintf "(%s_option : %s option data_conv)" conv name)
-
-let add_object = add_pointer "gobject"
-let add_boxed = add_pointer "unsafe_pointer" (* the type is not used *)
-
-let () =
-  List.iter ~f:(fun t -> Hashtbl.add conversions ~key:("g"^t) ~data:t)
-    [ "boolean"; "char"; "uchar"; "int"; "uint"; "long"; "ulong";
-      "int32"; "uint32"; "int64"; "uint64"; "float"; "double" ];
-  List.iter ~f:(fun (gtype,conv) -> Hashtbl.add conversions ~key:gtype ~data:conv)
-    [ "gchararray", "string";
-      "gchararray_opt", "string_option";
-      "string", "string"; "bool", "boolean"; "int", "int";
-      "int32", "int32"; "float", "float";
-    ];
-  List.iter enums ~f:(fun (pre, modu, l) ->
-    List.iter l ~f:
-      begin fun name ->
-        Hashtbl.add conversions ~key:(pre ^ name)
-          ~data:(Printf.sprintf "%s.Conv.%s" modu (camlize name))
-      end);
-  List.iter boxeds ~f:(fun (pre, l) ->
-    List.iter l ~f:(fun name -> add_boxed (pre^name) (pre^"."^camlize name)));
-  List.iter classes ~f:(fun (pre,l) ->
-    List.iter l ~f:(fun t -> add_object (pre^t) (pre^"."^camlize t)));
-  add_object "GObject" "unit obj";
-  add_object "GtkWidget" "Gtk.widget obj"
-
-open Genlex
-
-let lexer = make_lexer ["{"; "}"; ":"; "/"; "("; ")";"->";"method";"signal"]
-
-let rec star ?(acc=[]) p = parser
-    [< x = p ; s >] -> star ~acc:(x::acc) p s
-  | [< >] -> List.rev acc
-
-let may_token tok s =
-  if Stream.peek s = Some tok then Stream.junk s
-
-let ident = parser [< ' Ident id >] -> id
-
-let string = parser [< ' String s >] -> s
-
-let may_colon p def = parser
-  | [< ' Kwd":"; s >] -> p s
-  | [< >] -> def
-
-let may_string def = parser
-    [< ' String s >] -> s
-  | [< >] -> def
-
-let may_name s = parser
-    [< ' Kwd"("; ' Ident id; ' Kwd")" >] -> id
-  | [< >] -> (camlize s)
-
-let next_attr = parser
-    [< ' Kwd"/"; ' Ident id; ids = star ~acc:[id] ident >] ->
-      String.concat ~sep:"" ids
-
-let attributes =
-  ["Read";"Write";"Construct";"ConstructOnly";"NoSet";"Set";
-   "NoWrap";"Wrap";"NoGet";"VSet";"NoVSet"]
-
-let label_type2 id = parser
-  | [< ' Kwd":"; ' Ident ty >] -> (id,ty)
-  | [< >] -> ("",id)
-let label_type = parser
-    [< ' Ident id ; lty = label_type2 id >] -> lty
-
-type marshal =
-    Function of string | Types of (string list * string list * string)
-
-let return_type (l,types) = parser
-    [< ' Kwd"->"; ' Ident ret >] -> Types (l, types, ret)
-  | [< >] -> Types (l, types, "")
-
-let marshaller = parser
-  | [< ' String s >] -> Function s
-  | [< ' Kwd":"; types = star label_type; s >] ->
-      return_type (List.split types) s
-  | [< >] -> Types ([], [], "")
-
-let simple_attr = parser [< ' Kwd"/"; ' Ident s >] -> s
-
-let field = parser
-    [< ' String name; mlname = may_name name; ' Ident gtype; ' Kwd":";
-       ' Ident attr0; attrs = star ~acc:[attr0] next_attr >] ->
-         if not (List.for_all attrs ~f:(List.mem ~set:attributes)) then
-           raise (Stream.Error "bad attribute");
-         `Prop (name, mlname, gtype, attrs)
-  | [< ' Kwd"method"; ' Ident name; ty = may_colon string "unit";
-       attrs = star simple_attr >] ->
-         if not (List.for_all attrs ~f:(List.mem ~set:["Wrap"])) then
-           raise (Stream.Error "bad attribute");
-         `Method (name, ty, attrs)
-  | [< ' Kwd"signal"; ' Ident name; m = marshaller; l = star simple_attr >] ->
-      if not (List.for_all l ~f:(List.mem ~set:["Wrap";"NoWrap"])) then
-        raise (Stream.Error "bad attribute");
-      `Signal (name, m, l)
-
-let split_fields l =
-  List.fold_right l ~init:([],[],[]) ~f:
-    (fun field (props,meths,sigs) -> match field with
-      `Prop p   -> (p::props,meths,sigs)
-    | `Method m -> (props,m::meths,sigs)
-    | `Signal s -> (props,meths,s::sigs))
-
-let verb_braces = ref 0
-
-let rec verbatim buf = parser
-  | [< ''}' ; s >] ->
-      if !verb_braces = 0 then Buffer.contents buf else begin
-        decr verb_braces; Buffer.add_char buf '}'; verbatim buf s;
-      end
-  | [< ''{'; s >] ->
-      Buffer.add_char buf '{'; incr verb_braces; verbatim buf s
-  | [< ''\\' ; 'c ; s >] ->
-      if c <> '}' && c <> '{' then Buffer.add_char buf '\\';
-      Buffer.add_char buf c; verbatim buf s
-  | [< 'c ; s >] -> Buffer.add_char buf c; verbatim buf s
-
-let read_pair = parser
-  | [< ' Ident cls ; data = may_string (camlize cls) >] -> (cls,data)
-
-let qualifier = parser
-  | [< ' Ident id ; data = may_string "" >] -> (id,data)
-
-let prefix = ref ""
-let tagprefix = ref ""
-let decls = ref []
-let headers = ref []
-let oheaders = ref []
-let initializers = ref []
-let checks = ref false
-let class_qualifiers =
-  ["abstract";"notype";"hv";"set";"wrap";"wrapset";"vset";"tag";"wrapsig";
-   "type";"gobject";]
-
-let process_phrase ~chars = parser
-    [< ' Ident"class"; ' Ident name; gtk_name = may_string (!prefix ^ name);
-       attrs = star qualifier; parent = may_colon ident "";
-       ' Kwd"{"; fields = star field; ' Kwd"}" >] ->
-         if List.exists attrs ~f:
-             (fun (x,_) -> not (List.mem x ~set:class_qualifiers))
-         then raise (Stream.Error "bad qualifier");
-         let attrs = ("parent",parent) :: attrs in
-         let attrs =
-           if parent = "GObject" then ("gobject","")::attrs else attrs in
-         let props, meths, sigs = split_fields fields in
-         decls := (name, gtk_name, attrs, props, meths, sigs) :: !decls
-  | [< ' Ident"initializer"; ' String func >] ->
-      initializers := !initializers @ [func]
-  | [< ' Ident"header"; ' Kwd"{" >] ->
-      let h = verbatim (Buffer.create 1000) chars in
-      headers := !headers @ [h]
-  | [< ' Ident"oheader"; ' Kwd"{" >] ->
-      let h = verbatim (Buffer.create 1000) chars in
-      oheaders := !oheaders @ [h]
-  | [< ' Ident"prefix"; ' String id >] ->
-      prefix := id
-  | [< ' Ident"tagprefix"; ' String id >] ->
-      tagprefix := id
-  | [< ' Ident"conversions"; pre1 = may_string ""; pre2 = may_string pre1;
-       ' Kwd"{"; l = star read_pair; ' Kwd"}" >] ->
-      List.iter l ~f:(fun (k,d) ->
-        Hashtbl.add conversions ~key:(pre1^k) ~data:(if pre2="" then d else pre2^"."^d))
-  | [< ' Ident"classes"; ' Kwd"{"; l = star read_pair; ' Kwd"}" >] ->
-      List.iter l ~f:(fun (k,d) -> add_object k d)
-  | [< ' Ident"boxed"; ' Kwd"{"; l = star read_pair; ' Kwd"}" >] ->
-      List.iter l ~f:(fun (k,d) -> add_boxed k d)
-  | [< ' _ >] ->
-      raise (Stream.Error "")
-  | [< >] ->
-      raise End_of_file
-
-let all_props = Hashtbl.create 137
-let all_pnames = Hashtbl.create 137
-let outfile = ref ""
-let ooutfile = ref ""
-
-let process_file f =
-  let base = Filename.chop_extension f in
-  let baseM = String.capitalize_ascii base in
-  prefix := baseM;
-  (* Input *)
-  (* Redefining saves space in bytecode! *)
-  headers  := ["open Gobject"; "open Data";
-               "module Object = GtkObject"];
-  oheaders := ["open GtkSignal"; "open Gobject"; "open Data";
-               "let set = set"; "let get = get"; "let param = param"];
-  let ic = open_in f in
-  let chars = Stream.of_channel ic in
-  let s = lexer chars in
-  begin try while true do process_phrase ~chars s done with
-    End_of_file -> ()
-  | Stream.Error _ | Stream.Failure ->
-      Printf.eprintf "Parse error in file `%s' before char %d\n"
-        f (Stream.count chars);
-      exit 2
-  | exn ->
-      Printf.eprintf "Exception %s in file `%s' before char %d\n"
-        (Printexc.to_string exn) f (Stream.count chars);
-      exit 2
-  end;
-  (* Preproccess *)
-  let type_name name ~attrs =
-    try List.assoc "type" attrs with Not_found ->
-      if List.mem_assoc "gobject" ~map:attrs then camlize name
-      else if !prefix <> ""
-      then !prefix ^ "." ^ camlize name ^ " obj"
-      else camlize name ^ " obj"
-  in
-  let decls = List.rev !decls in
-  let decls = List.filter decls
-      ~f:(fun (_,_,attrs,_,_,_) -> not (List.mem_assoc "notype" ~map:attrs)) in
-  List.iter decls ~f:
-    (fun (name, gtk_name, attrs, _, _, _) ->
-      add_object gtk_name (type_name name ~attrs));
-  (* Output modules *)
-  if !outfile = "" then outfile := base ^ "Props.ml";
-  let oc = open_out !outfile in
-  let ppf = Format.formatter_of_out_channel oc in
-  let out fmt = Format.fprintf ppf fmt in
-  List.iter !headers ~f:(fun s -> out "%s@." s);
-  List.iter !initializers ~f:
-    (fun s ->
-      out "external %s : unit -> unit = \"%s\"@." s s;
-      out "let () = %s ()@." s);
-  let decls =
-    List.map decls ~f:
-      begin fun (name, gtk_name, attrs, props, meths, sigs) ->
-        (name, gtk_name, attrs,
-         List.filter props ~f:
-           begin fun (name,_,gtype,_) ->
-             try ignore (Hashtbl.find conversions gtype);
-               try
-                 let count, _ = Hashtbl.find all_props (name,gtype) in
-                 incr count;
-                 true
-               with Not_found ->
-                 Hashtbl.add all_props ~key:(name,gtype) ~data:(ref 1, ref ""); true
-             with Not_found ->
-               prerr_endline ("Warning: no conversion for type " ^ gtype ^
-                              " in class " ^ gtk_name);
-               false
-           end,
-         meths,
-         List.filter sigs ~f:
-           begin function
-           | _, Function _, _ -> true
-           | _, Types(_, l, ret), _ ->
-               List.for_all (if ret = "" then l else ret::l) ~f:
-                 (fun ty ->
-                   if Hashtbl.mem conversions ty then true else
-                   (prerr_endline ("Warning: no conversion for type " ^ ty ^
-                                   " in class " ^ gtk_name);
-                    false))
-           end)
-      end in
-  let defprop ~name ~mlname ~gtype ~tag =
-    let conv = Hashtbl.find conversions gtype in
-    out "@ @[<hv2>let %s " mlname;
-    if tag <> "gtk" then out ": ([>`%s],_) property " tag;
-    out "=@ @[<hov1>{name=\"%s\";@ conv=%s}@]@]" name conv
-  in
-  let shared_props =
-    Hashtbl.fold all_props ~init:[] ~f:
-      begin fun ~key:(name,gtype) ~data:(count,rpname) acc ->
-        if !count <= 1 then acc else
-        let pname = camlize name in
-        let pname =
-          if Hashtbl.mem all_pnames pname then pname ^ "_" ^ gtype
-          else (Hashtbl.add all_pnames ~key:pname ~data:(); pname) in
-        rpname := "PrivateProps." ^ pname;
-        (pname,name,gtype) :: acc
-      end
-  in
-  if shared_props <> [] then begin
-    out "@[<hv2>module PrivateProps = struct";
-    List.iter (List.sort ~cmp:compare shared_props) ~f:
-      (fun (pname,name,gtype) ->
-        defprop ~name ~mlname:pname ~gtype ~tag:"gtk");
-    out "@]\nend\n@.";
-  end;
-  (* Redefining saves space in bytecode! *)
-  out "let may_cons = Property.may_cons\n";
-  out "let may_cons_opt = Property.may_cons_opt\n@.";
-  let may_cons_props props =
-    if props <> [] then begin
-      out "@ @[<hv2>let pl = ";
-      List.iter props ~f:
-        begin fun (name,mlname,gtype,_) ->
-          let op =
-            if check_suffix gtype "_opt" then "may_cons_opt" else "may_cons"
-          in
-          out "(@;<0>%s P.%s %s " op (camlize name) mlname;
-        end;
-      out "pl";
-      for _k = 1 to List.length props do out ")" done;
-      out " in@]"
-    end
-  in
-  let omarshaller ~gtk_class ~name ppf (l,tyl,ret) =
-    let out fmt = Format.fprintf ppf fmt in
-    out "fun f ->@ @[<hov2>marshal%d" (List.length l);
-    if ret <> "" then
-      out "_ret@ ~ret:%s" (Hashtbl.find conversions ret);
-    List.iter tyl ~f:(fun ty -> out "@ %s" ty);
-    out "@ \"%s::%s\"" gtk_class name;
-    if List.for_all l ~f:((=) "") then out " f" else begin
-      let l = min_labelled l in
-      out "@ @[<hov2>(fun ";
-      for i = 1 to List.length l do out "x%d " i done;
-      out "->@ f";
-      let i = ref 0 in
-      List.iter l ~f:
-        (fun p ->
-          incr i; if p="" then out "@ x%d" !i else out "@ ~%s:x%d" p !i);
-      out ")@]";
-    end;
-    out "@]"
-  in
-  List.iter decls ~f:
-    begin fun (name, gtk_class, attrs, props, meths, sigs) ->
-      out "@[<hv2>module %s = struct" (camlizeM name);
-      out "@ @[<hv2>let cast w : %s =@ try_cast w \"%s\"@]"
-        (type_name name ~attrs) gtk_class;
-      let tag =
-        try List.assoc "tag" attrs
-        with Not_found -> !tagprefix ^ String.lowercase_ascii name
-      in
-      if props <> [] then begin
-        out "@ @[<hv2>module P = struct";
-        List.iter props ~f:
-          begin fun (name, _, gtype, _attrs) ->
-            let count, rpname = Hashtbl.find all_props (name,gtype) in
-            if !count > 1 then begin
-              out "@ let %s : ([>`%s],_) property = %s"
-                (camlize name) tag !rpname
-            end else
-              defprop ~name ~mlname:(camlize name) ~gtype ~tag
-          end;
-        out "@]@ end"
-      end;
-      if sigs <> [] then begin
-        out "@ @[<hv2>module S = struct@ open GtkSignal";
-        List.iter sigs ~f:
-          begin fun (name,marshaller,_) ->
-            out "@ @[<hv2>let %s =" (camlize name);
-            out "@ @[<hov1>{name=\"%s\";@ classe=`%s;@ marshaller="
-              name tag;
-            begin match marshaller with
-            | Function s -> out "%s" s
-            | Types ([], [], "") -> out "marshal_unit" 
-            | Types ([], [], ret) ->
-                out "fun f -> marshal0_ret ~ret:%s f"
-                  (Hashtbl.find conversions ret)
-            | Types (l, tyl, ret) ->
-                omarshaller ~gtk_class ~name ppf
-                  (l, List.map ~f:(Hashtbl.find conversions) tyl, ret)
-            end;
-            out "}@]@]";
-          end;
-        out "@]@ end";
-      end;
-      if not (List.mem_assoc "abstract" ~map:attrs) then begin
-        let cprops = List.filter props ~f:(fun (_,_,_,a) ->
-          List.mem "ConstructOnly" ~set:a && not (List.mem "NoSet" ~set:a)) in
-        out "@ @[<hv2>let create";
-        List.iter cprops ~f:(fun (_,name,_,_) -> out " ?%s" name);
-        if List.mem_assoc "hv" ~map:attrs then begin
-          out " (dir : Gtk.Tags.orientation) pl : %s ="
-            (type_name name ~attrs);
-          may_cons_props cprops;
-          out "@ @[<hov2>Object.make";
-          out "@ (if dir = `HORIZONTAL then \"%sH%s\" else \"%sV%s\")@  pl"
-            !prefix name !prefix name;
-          out "@]@]";
-        end else begin
-          out " pl : %s =" (type_name name ~attrs);
-          may_cons_props cprops;
-          if List.mem_assoc "gobject" ~map:attrs then
-            out "@ Gobject.unsafe_create"
-          else out "@ Object.make";
-           out " \"%s\" pl@]" gtk_class;
-        end
-      end;
-      List.iter meths ~f:
-        begin fun (name, typ, _attrs) ->
-          out "@ @[<hov2>external %s :" name;
-          out "@ @[<hv>[>`%s] obj ->@ %s@]" tag typ;
-          let cname = camlize ("ml" ^ gtk_class) ^ "_" ^ name in
-          out "@ = \"";
-          if arity typ > 4 then out "%s_bc\" \"" cname;
-          out "%s\"@]" cname;
-        end;
-      let set_props =
-        let set = List.mem_assoc "set" ~map:attrs in
-        List.filter props ~f:
-          (fun (_,_,_,a) ->
-            (set || List.mem "Set" ~set:a) && List.mem "Write" ~set:a &&
-            not (List.mem "ConstructOnly" ~set:a || List.mem "NoSet" ~set:a))
-      in
-      if set_props <> [] then begin
-        let props = set_props in
-        out "@ @[<hv2>@[<hov4>let make_params ~cont pl";
-        List.iter props ~f:(fun (_,name,_,_) -> out "@ ?%s" name);
-        out " =@]";
-        may_cons_props props;
-        out "@ cont pl@]";
-      end;
-      if !checks && (props <> [] || sigs <> []) then begin
-        if List.mem_assoc "abstract" ~map:attrs then 
-          out "@ @[<hv2>let check w ="
-        else begin
-          out "@ @[<hv2>let check () =";
-          out "@ let w = create%s [] in"
-            (if List.mem_assoc "hv" ~map:attrs then " `HORIZONTAL" else "");
-        end;
-        if props <> [] then out "@ let c p = Property.check w p in";
-        if sigs <> [] then begin
-          out "@ let closure = Closure.create ignore in";
-          out "@ let s name = GtkSignal.connect_by_name";
-          out " w ~name ~closure ~after:false in";
-        end;
-        out "@ @[<hov>";
-        List.iter props ~f:
-          (fun (name,_,_gtype,attrs) ->
-            if List.mem "Read" ~set:attrs then out "c P.%s;@ " (camlize name));
-        List.iter sigs ~f:(fun (name,_,_) -> out "s %s;@ " name);
-        out "()@]";
-      end;
-      out "@]@.end\n@."
-    end;
-  close_out oc;
-  (* Output classes *)
-  if !ooutfile = "" then ooutfile := "o" ^ !outfile;
-  let oc = open_out !ooutfile in
-  let ppf = Format.formatter_of_out_channel oc in
-  let out fmt = Format.fprintf ppf fmt in
-  List.iter !oheaders ~f:(fun s -> out "%s@." s);
-  out "open %s@." (String.capitalize_ascii (Filename.chop_extension !outfile));
-  out "@[<hv>";
-  let oprop ~name ~gtype ppf pname =
-    try
-      let conv = List.assoc gtype specials in
-      Format.fprintf ppf "{%s.P.%s with conv=%s}"
-        (camlizeM name) (camlize pname) conv
-    with Not_found ->
-      Format.fprintf ppf "%s.P.%s" (camlizeM name) (camlize pname)
-  in
-  List.iter decls ~f:
-    begin fun (name, gtk_class, attrs, props, meths, sigs) ->
-      let wrap = List.mem_assoc "wrap" ~map:attrs in
-      let wrapset = wrap || List.mem_assoc "wrapset" ~map:attrs in
-      let wr_props =
-        List.filter props ~f:
-          (fun (_,_,_,set) ->
-            let has = List.mem ~set in
-            (wrapset || has "Wrap") && has "Write" &&
-            not (has "ConstructOnly" || has "NoWrap"))
-      and rd_props =
-        List.filter props ~f:
-          (fun (_,_,_,set) ->
-            let has = List.mem ~set in
-            (wrap || has "Wrap") && has "Read" &&
-            not (has "NoWrap" || has "NoGet"))
-      and wr_meths =
-        List.filter meths ~f:(fun (_,_,attrs) -> List.mem "Wrap" ~set:attrs)
-      in
-      if wr_props <> [] || rd_props <> [] || wr_meths <> [] then begin
-        (* pre 3.10
-        out "@ @[<hv2>class virtual %s_props = object (self)" (camlize name);
-        out "@ method private virtual obj : _ obj";
-        List.iter wr_props ~f:(fun (pname,mlname,gtype,_) ->
-          out "@ @[<hv2>method set_%s =@ set %a self#obj@]"
-            mlname (oprop ~name ~gtype) pname);
-        List.iter rd_props ~f:(fun (pname,mlname,gtype,_) ->
-          out "@ @[<hv2>method %s =@ get %a self#obj@]"
-            mlname (oprop ~name ~gtype) pname);
-        List.iter wr_meths ~f:(fun (mname,typ,_) ->
-          out "@ @[<hv2>method %s %s=@ %s.%s self#obj@]"
-            mname (if typ = "unit" then "() " else "") (camlizeM name) mname);
-        *)
-        (* post 3.10 *)
-        out "@ @[<hv2>class virtual %s_props = object" (camlize name);
-        out "@ val virtual obj : _ obj";
-        List.iter wr_props ~f:(fun (pname,mlname,gtype,_) ->
-          out "@ @[<hv2>method set_%s =@ set %a obj@]"
-            mlname (oprop ~name ~gtype) pname);
-        List.iter rd_props ~f:(fun (pname,mlname,gtype,_) ->
-          out "@ @[<hv2>method %s =@ get %a obj@]"
-            mlname (oprop ~name ~gtype) pname);
-        List.iter wr_meths ~f:(fun (mname,typ,_) ->
-          out "@ @[<hv2>method %s %s=@ %s.%s obj@]"
-            mname (if typ = "unit" then "() " else "") (camlizeM name) mname);
-        out "@]@ end@ ";
-        (* #notify: easy connection to the "foo::notify" signal for the "foo"
-         * properties. *)
-        (*
-        out "@ @[<hv2>class virtual %s_notify obj = object (self)" (camlize name);
-        out "@ val obj : 'a obj = obj";
-        out "@ method private notify : 'b. ('a, 'b) property ->";
-        out "@   callback:('b -> unit) -> _ =";
-        out "@ fun prop ~callback -> GtkSignal.connect_property obj";
-        out "@   ~prop ~callback";
-        List.iter rd_props ~f:(fun (pname, mlname, gtype, _) ->
-          out "@ @[<hv2>method %s =@ self#notify %a@]"
-          mlname (oprop ~name ~gtype) pname);
-        out "@]@ end@ ";
-        *)
-      end;
-      let vset = List.mem_assoc "vset" ~map:attrs in
-      let vprops =
-        List.filter props ~f:
-          (fun (_,_,_,set) ->
-            let has = List.mem ~set in
-            (vset || has "VSet") && has "Write" &&
-            not (has "ConstructOnly" || has "NoVSet"))
-      in
-      if vprops <> [] then begin
-        out "@ @[<hv2>let %s_param = function" (camlize name);
-        List.iter vprops ~f:(fun (pname,mlname,gtype,_) ->
-          out "@ @[<hv4>| `%s p ->@ param %a p@]"
-            (String.uppercase_ascii mlname) (oprop ~name ~gtype) pname);
-        out "@]@ ";
-      end;
-      let wsig = List.mem_assoc "wrapsig" ~map:attrs in
-      let wsigs =
-        List.filter sigs ~f:
-          (fun (_,_,attrs) ->
-            List.mem "Wrap" ~set:attrs || wsig && not (List.mem "NoWrap" ~set:attrs))
-      in
-      if wsigs <> [] then begin
-        out "@ @[<hv2>class virtual %s_sigs = object (self)" (camlize name);
-        out "@ @[<hv2>method private virtual connect :";
-        out "@ 'b. ('a,'b) GtkSignal.t -> callback:'b -> GtkSignal.id@]";
-        out "@ @[<hv2>method private virtual notify :";
-        out "@ 'b. ('a,'b) property -> callback:('b -> unit) -> GtkSignal.id@]";
-        List.iter wsigs ~f:
-          begin fun (sname, types,_) ->
-            match types with Types(l, tyl,ret)
-              when List.exists tyl ~f:(List.mem_assoc ~map:specials) ->
-                let convs =
-                  List.map tyl ~f:
-                    (fun ty -> try List.assoc ty specials
-                      with Not_found -> Hashtbl.find conversions ty)
-                in
-                out "@ @[<hov2>method %s =@ self#connect" sname;
-                out "@ @[<hov1>{%s.S.%s with@ marshaller = %a}@]@]"
-                  (camlizeM name) sname
-                  (omarshaller ~gtk_class ~name:sname) (l, convs,ret)
-            | _ ->
-                out "@ @[<hv2>method %s =@ self#connect %s.S.%s@]"
-                  sname (camlizeM name) sname
-          end;
-        (* notify: easy connection to "foo::notify" signals for "foo"
-         * properties. *)
-        List.iter rd_props ~f:(fun (pname, mlname, gtype, _) ->
-          out "@ @[<hov2>method notify_%s ~callback =" mlname;
-          out "@ @[<hov1>self#notify %a ~callback@]@]"
-          (oprop ~name ~gtype) pname);
-        out "@]@ end@ ";
-      end
-    end;
-  out "@.";
-  close_out oc;
-  outfile := "";
-  ooutfile := ""
-
-let main () =
-  Arg.parse
-    [ "-checks", Arg.Set checks, "generate code for checks";
-      "-o", Arg.String (fun s -> outfile := s), "basic output file name";
-      "-oo", Arg.String (fun s -> ooutfile := s), "wrappers output file name" ]
-    process_file "usage: propcc <options> file.props ..."
-
-let () = Printexc.print main ()
diff --git a/lablgtk3/varcc.ml b/lablgtk3/varcc.ml
deleted file mode 100644
index 8569a9c..0000000
--- a/lablgtk3/varcc.ml
+++ /dev/null
@@ -1,344 +0,0 @@
-(* -*- caml -*- *)
-(* $Id$ *)
-
-(* Compile a list of variant tags into CPP defines *) 
-
-open StdLabels
-
-(* hash_variant, from ctype.ml *)
-
-let hash_variant s =
-  let accu = ref 0 in
-  for i = 0 to String.length s - 1 do
-    accu := 223 * !accu + Char.code s.[i]
-  done;
-  (* reduce to 31 bits *)
-  accu := !accu land (1 lsl 31 - 1);
-  (* make it signed for 64 bits architectures *)
-  if !accu > 0x3FFFFFFF then !accu - 1 lsl 31 else !accu
-
-let camlize id =
-  let b = Buffer.create (String.length id + 4) in
-  for i = 0 to String.length id - 1 do
-    if id.[i] >= 'A' && id.[i] <= 'Z' then
-      begin
-        if i > 0 then Buffer.add_char b '_';
-        Buffer.add_char b (Char.lowercase_ascii id.[i])
-      end
-    else Buffer.add_char b id.[i]
-  done;
-  Buffer.contents b
-
-open Genlex
-
-let lexer = make_lexer ["type"; "="; "["; "]"; "`"; "|"]
-
-let may_string (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (String s) -> Stream.junk strm__; s
-  | _ -> ""
-
-let may_bar (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Kwd "|") -> Stream.junk strm__; ()
-  | _ -> ()
-
-let rec ident_list (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Kwd "`") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (Ident x) ->
-          Stream.junk strm__;
-          let trans =
-            try may_string strm__ with
-              Stream.Failure -> raise (Stream.Error "")
-          in
-          let _ =
-            try may_bar strm__ with Stream.Failure -> raise (Stream.Error "")
-          in
-          let s = strm__ in (x, trans) :: ident_list s
-      | _ -> raise (Stream.Error "")
-      end
-  | _ -> []
-
-let static = ref false
-
-let rec star ?(acc = []) p (strm__ : _ Stream.t) =
-  match try Some (p strm__) with Stream.Failure -> None with
-    Some x -> let s = strm__ in star ~acc:(x :: acc) p s
-  | _ -> List.rev acc
-
-let flag (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Ident ("public" | "private" | "noconv" | "flags" as s)) ->
-      Stream.junk strm__; s
-  | _ -> raise Stream.Failure
-
-let protect (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Ident "protect") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (Ident m) -> Stream.junk strm__; Some m
-      | _ -> raise (Stream.Error "")
-      end
-  | _ -> None
-
-let may o f =
-  match o with
-    Some v -> f v
-  | None -> ()
-
-open Printf
-
-let hashes = Hashtbl.create 57
-
-let all_convs = ref []
-let package = ref ""
-let pkgprefix = ref ""
-
-let declaration ~hc ~cc (strm__ : _ Stream.t) =
-  match Stream.peek strm__ with
-    Some (Kwd "type") ->
-      Stream.junk strm__;
-      let flags =
-        try star flag strm__ with Stream.Failure -> raise (Stream.Error "")
-      in
-      let guard =
-        try protect strm__ with Stream.Failure -> raise (Stream.Error "")
-      in
-      begin match Stream.peek strm__ with
-        Some (Ident mlname) ->
-          Stream.junk strm__;
-          let name =
-            try may_string strm__ with
-              Stream.Failure -> raise (Stream.Error "")
-          in
-          begin match Stream.peek strm__ with
-            Some (Kwd "=") ->
-              Stream.junk strm__;
-              let prefix =
-                try may_string strm__ with
-                  Stream.Failure -> raise (Stream.Error "")
-              in
-              begin match Stream.peek strm__ with
-                Some (Kwd "[") ->
-                  Stream.junk strm__;
-                  let _ =
-                    try may_bar strm__ with
-                      Stream.Failure -> raise (Stream.Error "")
-                  in
-                  let tags =
-                    try ident_list strm__ with
-                      Stream.Failure -> raise (Stream.Error "")
-                  in
-                  begin match Stream.peek strm__ with
-                    Some (Kwd "]") ->
-                      Stream.junk strm__;
-                      let suffix =
-                        try may_string strm__ with
-                          Stream.Failure -> raise (Stream.Error "")
-                      in
-                      let oh x = fprintf hc x
-                      and oc x = fprintf cc x in
-                      let name =
-                        if name = "" then !pkgprefix ^ mlname else name
-                      in
-                      (* Output tag values to headers *)
-                      let first = ref true in
-                      List.iter tags
-                        ~f:(fun (tag, _) ->
-                           let hash = hash_variant tag in
-                           try
-                             let tag' = Hashtbl.find hashes hash in
-                             if tag <> tag' then
-                               failwith
-                                 (String.concat ~sep:" "
-                                    ["Doublon tag:"; tag; "and"; tag'])
-                           with Not_found ->
-                             Hashtbl.add hashes hash tag;
-                             if !first then
-                               begin
-                                 oh "/* %s : tags and macros */\n" name;
-                                 first := false
-                               end;
-                             oh "#define MLTAG_%s\t((value)(%d*2+1))\n" tag
-                               hash);
-                      if List.mem "noconv" ~set:flags then ()
-                      else
-                        let ctag tag trans =
-                          if trans <> "" then trans
-                          else
-                            let tag =
-                              if tag.[0] = '_' then
-                                String.sub tag ~pos:1
-                                  ~len:(String.length tag - 1)
-                              else tag
-                            in
-                            match
-                              if prefix = "" then None, ""
-                              else
-                                Some prefix.[String.length prefix - 1],
-                                String.sub prefix ~pos:0
-                                  ~len:(String.length prefix - 1)
-                            with
-                              Some '#', prefix ->
-                                prefix ^ String.uncapitalize_ascii tag ^
-                                suffix
-                            | Some '^', prefix ->
-                                prefix ^ String.uppercase_ascii tag ^ suffix
-                            | _ -> prefix ^ tag ^ suffix
-                        and cname = String.capitalize_ascii name in
-                        all_convs :=
-                          (name, mlname, tags, flags) :: !all_convs;
-                        let tags =
-                          List.sort tags
-                            ~cmp:(fun (tag1, _) (tag2, _) -> compare (hash_variant tag1) (hash_variant tag2))
-                        in
-                        (* Output table to code file *)
-                        oc "/* %s : conversion table */\n" name;
-                        let static =
-                          if !static && not (List.mem "public" ~set:flags) ||
-                             List.mem "private" ~set:flags
-                          then
-                            "static "
-                          else ""
-                        in
-                        oc "%sconst lookup_info ml_table_%s[] = {\n" static
-                          name;
-                        may guard (fun m -> oc "#ifdef %s\n" m);
-                        oc "  { 0, %d },\n" (List.length tags);
-                        List.iter tags
-                          ~f:(fun (tag, trans) -> oc "  { MLTAG_%s, %s },\n" tag (ctag tag trans));
-                        may guard
-                          (fun m ->
-                             oc "#else\n  {0, 0 }\n#endif /* %s */\n" m);
-                        oc "};\n\n";
-                        (* Output macros to headers *)
-                        if not !first then oh "\n";
-                        if static = "" then
-                          oh "extern const lookup_info ml_table_%s[];\n" name;
-                        oh
-                          "#define Val_%s(data) ml_lookup_from_c (ml_table_%s, data)\n"
-                          name name;
-                        oh
-                          "#define %s_val(key) ml_lookup_to_c (ml_table_%s, key)\n\n"
-                          cname name
-                  | _ -> raise (Stream.Error "")
-                  end
-              | _ -> raise (Stream.Error "")
-              end
-          | _ -> raise (Stream.Error "")
-          end
-      | _ -> raise (Stream.Error "")
-      end
-  | Some (Ident "package") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (String s) -> Stream.junk strm__; package := s
-      | _ -> raise (Stream.Error "")
-      end
-  | Some (Ident "prefix") ->
-      Stream.junk strm__;
-      begin match Stream.peek strm__ with
-        Some (String s) -> Stream.junk strm__; pkgprefix := s
-      | _ -> raise (Stream.Error "")
-      end
-  | _ -> raise End_of_file
-
-
-let process ic ~hc ~cc =
-  all_convs := [];
-  let chars = Stream.of_channel ic in
-  let s = lexer chars in
-  try while true do declaration s ~hc ~cc done with
-    End_of_file ->
-      if !all_convs <> [] && !package <> "" then
-        let oc x = fprintf cc x in
-        oc "CAMLprim value ml_%s_get_tables ()\n{\n" (camlize !package);
-        oc "  static const lookup_info *ml_lookup_tables[] = {\n";
-        let convs = List.rev !all_convs in
-        List.iter convs ~f:(fun (s, _, _, _) -> oc "    ml_table_%s,\n" s);
-        oc "  };\n";
-        (* When he have only one conversion, we must return it directly instead of       * an array that would be converted to a tuple *)
-        if List.length convs = 1 then
-          oc "  return (value)ml_lookup_tables[0];"
-        else oc "  return (value)ml_lookup_tables;";
-        oc "}\n";
-        let mlc = open_out (!package ^ "Enums.ml") in
-        let ppf = Format.formatter_of_out_channel mlc in
-        let out fmt = Format.fprintf ppf fmt in
-        out "(** %s enums *)\n@." !package;
-        out "@[";
-        List.iter convs
-          ~f:(fun (_, name, tags, _) ->
-             out "@[<hv 2>type %s =@ @[<hov>[ `%s" name (fst (List.hd tags));
-             List.iter (List.tl tags) ~f:(fun (s, _) -> out "@ | `%s" s);
-             out " ]@]@]@ ");
-        out "@]@.\n(**/**)\n@.";
-        out "@[<v2>module Conv = struct@ ";
-        out "open Gpointer\n@ ";
-        out "external _get_tables : unit ->@ ";
-        let (_, name0, _, _) = List.hd convs in
-        out "    %s variant_table@ " name0;
-        List.iter (List.tl convs)
-          ~f:(fun (_, s, _, _) -> out "  * %s variant_table@ " s);
-        out "  = \"ml_%s_get_tables\"\n@ " (camlize !package);
-        out "@[<hov 4>let %s_tbl" name0;
-        List.iter (List.tl convs) ~f:(fun (_, s, _, _) -> out ",@ %s_tbl" s);
-        out " = _get_tables ()@]\n";
-        let enum =
-          if List.length convs > 10 then
-            begin out "@ let _make_enum = Gobject.Data.enum"; "_make_enum" end
-          else "Gobject.Data.enum"
-        in
-        List.iter convs
-          ~f:(fun (_, s, _, flags) ->
-             let conv =
-               if List.mem "flags" ~set:flags then "Gobject.Data.flags"
-               else enum
-             in
-             out "@ let %s = %s %s_tbl" s conv s);
-        out "@]@.end@.";
-        close_out mlc
-  | Stream.Error err ->
-      failwith
-        (Printf.sprintf "Parsing error \"%s\" at character %d on input stream"
-           err (Stream.count chars))
-
-let main () =
-  let inputs = ref [] in
-  let header = ref "" in
-  let code = ref "" in
-  Arg.parse
-    ["-h", Arg.String ((:=) header), "file to output macros (file.h)";
-     "-c", Arg.String ((:=) code),
-     "file to output conversion tables (file.c)";
-     "-static", Arg.Set static, "do not export conversion tables"]
-    (fun s -> inputs := s :: !inputs) "usage: varcc [options] file.var";
-  let inputs = List.rev !inputs in
-  begin match inputs with
-    [] ->
-      if !header = "" then header := "a.h"; if !code = "" then code := "a.c"
-  | ip :: _ ->
-      let rad =
-        if Filename.check_suffix ip ".var" then Filename.chop_extension ip
-        else ip
-      in
-      if !header = "" then header := rad ^ ".h";
-      if !code = "" then code := rad ^ ".c"
-  end;
-  let hc = open_out !header
-  and cc = open_out !code in
-  if inputs = [] then process stdin ~hc ~cc
-  else
-    List.iter inputs
-      ~f:(fun file ->
-         let ic = open_in file in
-         try process ic ~hc ~cc; close_in ic with
-           exn -> close_in ic; prerr_endline ("Error in " ^ file); raise exn);
-  close_out hc;
-  close_out cc
-
-let _ = Printexc.print main ()
diff --git a/lablgtk3/varcc.ml4 b/lablgtk3/varcc.ml4
deleted file mode 100644
index 03b07d8..0000000
--- a/lablgtk3/varcc.ml4
+++ /dev/null
@@ -1,254 +0,0 @@
-(* -*- caml -*- *)
-(* $Id$ *)
-
-(* Compile a list of variant tags into CPP defines *) 
-
-open StdLabels
-
-(* hash_variant, from ctype.ml *)
-
-let hash_variant s =
-  let accu = ref 0 in
-  for i = 0 to String.length s - 1 do
-    accu := 223 * !accu + Char.code s.[i]
-  done;
-  (* reduce to 31 bits *)
-  accu := !accu land (1 lsl 31 - 1);
-  (* make it signed for 64 bits architectures *)
-  if !accu > 0x3FFFFFFF then !accu - (1 lsl 31) else !accu
-
-let camlize id =
-  let b = Buffer.create (String.length id + 4) in
-  for i = 0 to String.length id - 1 do
-    if id.[i] >= 'A' && id.[i] <= 'Z' then begin
-      if i > 0 then Buffer.add_char b '_';
-      Buffer.add_char b (Char.lowercase_ascii id.[i])
-    end
-    else Buffer.add_char b id.[i]
-  done;
-  Buffer.contents b
-
-open Genlex
-
-let lexer = make_lexer ["type"; "="; "["; "]"; "`"; "|"]
-
-let may_string = parser
-    [< ' String s >] -> s
-  | [< >] -> ""
-
-let may_bar = parser
-    [< ' Kwd "|" >] -> ()
-  | [< >] -> ()
-
-let rec ident_list = parser
-    [< ' Kwd "`"; ' Ident x; trans = may_string; _ = may_bar; s >] ->
-      (x, trans) :: ident_list s
-  | [< >] -> []
-
-let static = ref false
-
-let rec star ?(acc=[]) p = parser
-    [< x = p ; s >] -> star ~acc:(x::acc) p s
-  | [< >] -> List.rev acc
-
-let flag = parser
-    [< ' Ident ("public"|"private"|"noconv"|"flags" as s) >] -> s
-
-let protect = parser
-    [< ' Ident "protect" ; ' Ident m >] -> Some m
-  | [<>] -> None
-
-let may o f = 
-  match o with
-  | Some v -> f v
-  | None -> ()
-
-open Printf
-
-let hashes = Hashtbl.create 57
-
-let all_convs = ref []
-let package = ref ""
-let pkgprefix = ref ""
-
-let declaration ~hc ~cc = parser
-    [< ' Kwd "type"; flags = star flag; guard = protect;
-       ' Ident mlname; name = may_string; ' Kwd "="; prefix = may_string;
-       ' Kwd "["; _ = may_bar; tags = ident_list; ' Kwd "]";
-       suffix = may_string >] ->
-    let oh x = fprintf hc x and oc x = fprintf cc x in
-    let name = if name = "" then !pkgprefix ^ mlname else name in
-    (* Output tag values to headers *)
-    let first = ref true in
-    List.iter tags ~f:
-      begin fun (tag, _) ->
-        let hash = hash_variant tag in
-        try
-	  let tag' = Hashtbl.find hashes hash in
-	  if tag <> tag' then
-	    failwith (String.concat ~sep:" " ["Doublon tag:";tag;"and";tag'])
-        with Not_found ->
-	  Hashtbl.add hashes hash tag;
-          if !first then begin
-            oh "/* %s : tags and macros */\n" name; first := false
-          end;
-	  oh "#define MLTAG_%s\t((value)(%d*2+1))\n" tag hash;
-      end;
-    if List.mem "noconv" ~set:flags then () else
-    (* compute C name *)
-    let ctag tag trans =
-      if trans <> "" then trans else
-      let tag =
-	if tag.[0] = '_' then
-	  String.sub tag ~pos:1 ~len:(String.length tag -1)
-	else tag
-      in
-      match
-	if prefix = "" then None, ""
-	else
-	  Some (prefix.[String.length prefix - 1]), 
-	  String.sub prefix ~pos:0 ~len:(String.length prefix - 1)
-      with
-	Some '#', prefix ->
-	  prefix ^ String.uncapitalize_ascii tag ^ suffix
-      |	Some '^', prefix ->
-	  prefix ^ String.uppercase_ascii tag ^ suffix
-      |	_ ->
-	  prefix ^ tag ^ suffix
-    and cname =
-      String.capitalize_ascii name
-    in
-    all_convs := (name, mlname, tags, flags) :: !all_convs;
-    let tags =
-      List.sort tags ~cmp:
-        (fun (tag1,_) (tag2,_) ->
-          compare (hash_variant tag1) (hash_variant tag2))
-    in
-    (* Output table to code file *)
-    oc "/* %s : conversion table */\n" name;
-    let static =
-      if !static && not (List.mem "public" ~set:flags) || List.mem "private" ~set:flags
-      then "static " else "" in
-    oc "%sconst lookup_info ml_table_%s[] = {\n" static name;
-    may guard
-      (fun m -> oc "#ifdef %s\n" m) ;
-    oc "  { 0, %d },\n" (List.length tags);
-    List.iter tags ~f:
-      begin fun (tag,trans) ->
-	oc "  { MLTAG_%s, %s },\n" tag (ctag tag trans)
-      end;
-    may guard (fun m -> oc "#else\n  {0, 0 }\n#endif /* %s */\n" m) ;
-    oc "};\n\n";
-    (* Output macros to headers *)
-    if not !first then oh "\n";
-    if static = "" then oh "extern const lookup_info ml_table_%s[];\n" name;
-    oh "#define Val_%s(data) ml_lookup_from_c (ml_table_%s, data)\n"
-      name name;
-    oh "#define %s_val(key) ml_lookup_to_c (ml_table_%s, key)\n\n"
-      cname name;
-  | [< ' Ident "package"; ' String s >] ->
-      package := s
-  | [< ' Ident "prefix"; ' String s >] ->
-      pkgprefix := s
-  | [< >] -> raise End_of_file
-
-
-let process ic ~hc ~cc =  
-  all_convs := [];
-  let chars = Stream.of_channel ic in
-  let s = lexer chars in
-  try
-    while true do declaration s ~hc ~cc done
-  with End_of_file ->
-    if !all_convs <> [] && !package <> "" then begin
-      let oc x = fprintf cc x in
-      oc "CAMLprim value ml_%s_get_tables ()\n{\n" (camlize !package);
-      oc "  static const lookup_info *ml_lookup_tables[] = {\n";
-      let convs = List.rev !all_convs in
-      List.iter convs ~f:(fun (s,_,_,_) -> oc "    ml_table_%s,\n" s);
-      oc "  };\n";
-      (* When he have only one conversion, we must return it directly instead of       * an array that would be converted to a tuple *)
-      if List.length convs = 1 then
-        oc "  return (value)ml_lookup_tables[0];"
-      else
-        oc "  return (value)ml_lookup_tables;";
-      oc "}\n";
-      let mlc = open_out (!package ^ "Enums.ml") in
-      let ppf = Format.formatter_of_out_channel mlc in
-      let out fmt = Format.fprintf ppf fmt in
-      out "(** %s enums *)\n@." !package ;
-      out "@[";
-      List.iter convs ~f:
-        begin fun (_,name,tags,_) ->
-          out "@[<hv 2>type %s =@ @[<hov>[ `%s" name (fst (List.hd tags));
-          List.iter (List.tl tags) ~f:
-            (fun (s,_) -> out "@ | `%s" s);
-          out " ]@]@]@ "
-        end;
-      out "@]@.\n(**/**)\n@." ;
-      out "@[<v2>module Conv = struct@ ";
-      out "open Gpointer\n@ ";
-      out "external _get_tables : unit ->@ ";
-      let (_,name0,_,_) = List.hd convs in
-      out "    %s variant_table@ " name0;
-      List.iter (List.tl convs) ~f:
-        (fun (_,s,_,_) -> out "  * %s variant_table@ " s);
-      out "  = \"ml_%s_get_tables\"\n@ " (camlize !package);
-      out "@[<hov 4>let %s_tbl" name0;
-      List.iter (List.tl convs) ~f:(fun (_,s,_,_) -> out ",@ %s_tbl" s);
-      out " = _get_tables ()@]\n";
-      let enum =
-        if List.length convs > 10 then begin
-          out "@ let _make_enum = Gobject.Data.enum";
-          "_make_enum"
-        end else "Gobject.Data.enum"
-      in
-      List.iter convs ~f:
-        begin fun (_,s,_,flags) ->
-          let conv =
-            if List.mem "flags" ~set:flags then "Gobject.Data.flags" else enum in
-          out "@ let %s = %s %s_tbl" s conv s
-        end;
-      out "@]@.end@.";
-      close_out mlc
-    end
-  | Stream.Error err ->
-      failwith
-        (Printf.sprintf "Parsing error \"%s\" at character %d on input stream"
-           err (Stream.count chars))
-
-let main () =
-  let inputs = ref [] in
-  let header = ref "" in
-  let code = ref "" in
-  Arg.parse
-    [ "-h", Arg.String ((:=) header), "file to output macros (file.h)";
-      "-c", Arg.String ((:=) code),
-      "file to output conversion tables (file.c)";
-      "-static", Arg.Set static, "do not export conversion tables" ]
-    (fun s -> inputs := s :: !inputs)
-    "usage: varcc [options] file.var";
-  let inputs = List.rev !inputs in
-  begin match inputs with
-  | [] ->
-      if !header = "" then header := "a.h";
-      if !code = "" then code := "a.c"
-  | ip :: _ ->
-      let rad =
-        if Filename.check_suffix ip ".var" then Filename.chop_extension ip
-        else ip in
-      if !header = "" then header := rad ^ ".h";
-      if !code = "" then code := rad ^ ".c"
-  end;
-  let hc = open_out !header and cc = open_out !code in
-  if inputs = [] then process stdin ~hc ~cc else begin
-    List.iter inputs ~f:
-      begin fun file ->
-        let ic = open_in file in
-        try process ic ~hc ~cc; close_in ic
-        with exn -> close_in ic; prerr_endline ("Error in " ^ file); raise exn
-      end
-  end;
-  close_out hc; close_out cc
-
-let _ = Printexc.print main ()
diff --git a/lablgtk3/wrappers.c b/lablgtk3/wrappers.c
index fcf3ff3..1bc3066 100644
--- a/lablgtk3/wrappers.c
+++ b/lablgtk3/wrappers.c
@@ -37,7 +37,7 @@ CAMLexport value copy_memblock_indirected (void *src, asize_t size)
     mlsize_t wosize = Wosize_asize(size);
     value ret;
     if (!src) ml_raise_null_pointer ();
-    ret = alloc_shr (wosize+2, Abstract_tag);
+    ret = caml_alloc_shr (wosize+2, Abstract_tag);
     Field(ret,1) = (value)2;
     memcpy ((value *) ret + 2, src, size);
     return ret;
@@ -45,7 +45,7 @@ CAMLexport value copy_memblock_indirected (void *src, asize_t size)
 
 value alloc_memblock_indirected (asize_t size)
 {
-    value ret = alloc_shr (Wosize_asize(size)+2, Abstract_tag);
+    value ret = caml_alloc_shr (Wosize_asize(size)+2, Abstract_tag);
     Field(ret,1) = (value)2;
     return ret;
 }
@@ -83,7 +83,7 @@ CAMLexport value ml_alloc_custom(struct custom_operations * ops,
 CAMLprim value ml_some (value v)
 {
      CAMLparam1(v);
-     value ret = alloc_small(1,0);
+     value ret = caml_alloc_small(1,0);
      Field(ret,0) = v;
      CAMLreturn(ret);
 }
@@ -91,7 +91,7 @@ CAMLprim value ml_some (value v)
 value ml_cons (value v, value l)
 {
   CAMLparam2(v, l);
-  value cell = alloc_small(2, Tag_cons);
+  value cell = caml_alloc_small(2, Tag_cons);
   Field(cell, 0) = v;
   Field(cell, 1) = l;
   CAMLreturn(cell);
@@ -102,12 +102,12 @@ void ml_raise_null_pointer ()
   static const value * exn = NULL;
   if (exn == NULL)
       exn = caml_named_value ("null_pointer");
-  raise_constant (*exn);
+  caml_raise_constant (*exn);
 }   
 
 CAMLexport value Val_pointer (void *ptr)
 {
-    value ret = alloc_small (2, Abstract_tag);
+    value ret = caml_alloc_small (2, Abstract_tag);
     if (!ptr) ml_raise_null_pointer ();
     Field(ret,1) = (value)ptr;
     return ret;
@@ -116,12 +116,12 @@ CAMLexport value Val_pointer (void *ptr)
 CAMLprim value copy_string_check (const char*str)
 {
     if (!str) ml_raise_null_pointer ();
-    return copy_string ((char*) str);
+    return caml_copy_string ((char*) str);
 }
 
 value copy_string_or_null (const char*str)
 {
-    return copy_string (str ? (char*) str : "");
+    return caml_copy_string (str ? (char*) str : "");
 }
 
 value Val_option_string (const char *s)
@@ -129,16 +129,16 @@ value Val_option_string (const char *s)
 
 CAMLprim value *ml_global_root_new (value v)
 {
-    value *p = stat_alloc(sizeof(value));
+    value *p = caml_stat_alloc(sizeof(value));
     *p = v;
-    register_global_root (p);
+    caml_register_global_root (p);
     return p;
 }
 
 CAMLexport void ml_global_root_destroy (void *data)
 {
-    remove_global_root ((value *)data);
-    stat_free (data);
+    caml_remove_global_root ((value *)data);
+    caml_stat_free (data);
 }
 
 CAMLexport value ml_lookup_from_c (const lookup_info table[], int data)
@@ -146,7 +146,7 @@ CAMLexport value ml_lookup_from_c (const lookup_info table[], int data)
     int i;
     for (i = table[0].data; i > 0; i--)
 	if (table[i].data == data) return table[i].key;
-    invalid_argument ("ml_lookup_from_c");
+    caml_invalid_argument ("ml_lookup_from_c");
 }
     
 CAMLexport int ml_lookup_to_c (const lookup_info table[], value key)
@@ -158,7 +158,7 @@ CAMLexport int ml_lookup_to_c (const lookup_info table[], value key)
 	else first = current + 1;
     }
     if (table[first].key == key) return table[first].data;
-    invalid_argument ("ml_lookup_to_c");
+    caml_invalid_argument ("ml_lookup_to_c");
 }
 
 CAMLexport value ml_lookup_flags_getter (const lookup_info table[], int data)
@@ -169,7 +169,7 @@ CAMLexport value ml_lookup_flags_getter (const lookup_info table[], int data)
   l = Val_emptylist;
   for (i = table[0].data; i > 0; i--)
     if ((table[i].data & data) == table[i].data) {
-      cell = alloc_small(2, Tag_cons);
+      cell = caml_alloc_small(2, Tag_cons);
       Field(cell, 0) = table[i].key;
       Field(cell, 1) = l;
       l = cell;
@@ -211,8 +211,8 @@ string_list_of_strv (const gchar * const *v)
   head = l = Val_emptylist;
   while (v[i] != NULL)
     {
-      s = copy_string (v[i]);
-      cell = alloc_small (2, Tag_cons);
+      s = caml_copy_string (v[i]);
+      cell = caml_alloc_small (2, Tag_cons);
       Field (cell, 0) = s;
       Field (cell, 1) = Val_emptylist;
       if (l == Val_emptylist)
diff --git a/lablgtk3/wrappers.h b/lablgtk3/wrappers.h
index 8d45cb9..068e0b0 100644
--- a/lablgtk3/wrappers.h
+++ b/lablgtk3/wrappers.h
@@ -27,7 +27,7 @@
 
 /* Yell if a caml callback raised an exception */
 #define CAML_EXN_LOG(name) g_critical("%s: callback raised an exception", name)
-#define CAML_EXN_LOG_VERBOSE(name,exn) g_critical("%s: callback raised exception %s", name, format_caml_exception(Extract_exception(exn)))
+#define CAML_EXN_LOG_VERBOSE(name,exn) g_critical("%s: callback raised exception %s", name, caml_format_exception(Extract_exception(exn)))
 
 #include <caml/version.h>
 #include <caml/misc.h>
@@ -264,7 +264,7 @@ CAMLprim value cname##_bc (value *argv, int argn) \
 #define Char_val Int_val
 #define Float_val Double_val
 /* #define Float_val(x) ((float)Double_val(x)) */
-#define SizedString_val(x) String_val(x), string_length(x)
+#define SizedString_val(x) String_val(x), caml_string_length(x)
 
 #define Option_val(val,unwrap,default) \
 ((long)val-1 ? unwrap(Field(val,0)) : default)
@@ -282,9 +282,9 @@ CAMLprim value cname##_bc (value *argv, int argn) \
 
 #define Copy_array(ret,l,src,conv) \
  if (!l) ret = Atom(0); \
- else if (l <= Max_young_wosize) { int i; ret = alloc_tuple(l); \
+ else if (l <= Max_young_wosize) { int i; ret = caml_alloc_tuple(l); \
    for(i=0;i<l;i++) Field(ret,i) = conv(src[i]); } \
- else { int i; ret = alloc_shr(l,0); \
+ else { int i; ret = caml_alloc_shr(l,0); \
    for(i=0;i<l;i++) caml_initialize (&Field(ret,i), conv(src[i])); }
 
 #define Make_Val_final_pointer(type, init, final, adv) \
@@ -367,7 +367,7 @@ CAMLprim int OptFlags_##conv (value list) \
 #define Val_copy(val) copy_memblock_indirected (&val, sizeof(val))
 #define Val_string copy_string_check
 #define Val_optstring copy_string_or_null
-#define Optstring_val(v) (string_length(v) ? String_val(v) : (char*)NULL)
+#define Optstring_val(v) (caml_string_length(v) ? String_val(v) : (char*)NULL)
 #define Val_option(v,f) (v ? ml_some(f(v)) : Val_unit)
 #define Make_Val_option(T) \
 value Val_option_##T(T* v) { return Val_option(v,Val_##T); }
diff --git a/mllib/Makefile.in b/mllib/Makefile.in
index bbd9cef..c7c8ee5 100644
--- a/mllib/Makefile.in
+++ b/mllib/Makefile.in
@@ -31,8 +31,7 @@
 #
 
 # Config stuff
-OCAMLC = ocamlc
-OCAMLLEX = ocamllex
+OCAMLC = @OCAMLC@
 MLFLAGS = @MLFLAGS@
 top_srcdir = @top_srcdir@
 srcdir = @srcdir@
diff --git a/runtime/interp.c b/runtime/interp.c
index 03cf28a..d2b280c 100644
--- a/runtime/interp.c
+++ b/runtime/interp.c
@@ -100,6 +100,7 @@ static inline void putlong(value *v, longint x) {
 /* Macros used in action routines */
 
 #define error(msg, n)   runtime_error(msg, n, bp, pc0)
+#define cond_check(cond, msg, n)  if (cond) error(msg, n)
 
 #define local(n)        ((uchar *) bp + (n))
 #define parent(a, t)    indir(pointer(bp[SL]) + a, t)
diff --git a/runtime/keiko.iset b/runtime/keiko.iset
index ea0e5a8..c0c3954 100644
--- a/runtime/keiko.iset
+++ b/runtime/keiko.iset
@@ -359,22 +359,23 @@ inst CONVQD 0 M.dq  { flo_convq($1.q) }         { callout(long_flo,1,FLO,2); }
 
 # The operand of these checks is the line number to show in the error
 # message.  God forbid people should make source files containing
-# more than 65536 lines
+# more than 65536 lines.  Using the cond_check macro prevents recent
+# versions of GCC from complaining about misleafing layout.
 
 inst BOUND 2 T2 \
-    { if ((unsigned) $1.i >= (unsigned) $2.i) error(E_BOUND, $a); }
+    { cond_check((unsigned) $1.i >= (unsigned) $2.i, E_BOUND, $a); }
 inst NCHECK 2 T1 \
-    { if (pointer($1) == NULL) error(E_NULL, $a); }
+    { cond_check(pointer($1) == NULL, E_NULL, $a); }
 inst GCHECK 2 S1 \
-    { if (valptr($1) != NULL) error(E_GLOB, $a); }
+    { cond_check(valptr($1) != NULL, E_GLOB, $a); }
 inst ZCHECK 2 T1 \
-    { if ($1.i == 0) error(E_DIV, $a); }
+    { cond_check($1.i == 0, E_DIV, $a); }
 inst FZCHECK 2 T1 \
-    { if ($1.f == 0.0) error(E_FDIV, $a); }
+    { cond_check($1.f == 0.0, E_FDIV, $a); }
 inst DZCHECK 2 T1d \
-    { if ($1.d == 0.0) error(E_FDIV, $a); }
+    { cond_check($1.d == 0.0, E_FDIV, $a); }
 inst QZCHECK 2 T1q \
-    { if ($1.q == 0) error(E_DIV, $a); }
+    { cond_check($1.q == 0, E_DIV, $a); }
 inst ERROR 12 S0 \
     { error($a, $b); }
 
diff --git a/test/tByteWidth07.m b/test/tByteWidth07.m
new file mode 100644
index 0000000..76995f0
--- /dev/null
+++ b/test/tByteWidth07.m
@@ -0,0 +1,73 @@
+MODULE tByteWidth07; 
+
+IMPORT Out;
+
+TYPE rec = RECORD x, y: BYTE END;
+
+PROCEDURE Set(VAR r: rec); BEGIN r.x := 4; r.y := 5 END Set;
+
+VAR rr: rec;
+
+BEGIN
+  Set(rr);
+  Out.Int(rr.y, 0);
+  Out.Ln
+END tByteWidth07.
+
+(*<<
+5
+>>*)
+
+(*[[
+!! (SYMFILE #tByteWidth07 STAMP #tByteWidth07.%main 1 #tByteWidth07.m)
+!! (CHKSUM STAMP)
+!! 
+MODULE tByteWidth07 STAMP 0
+IMPORT Out STAMP
+ENDHDR
+
+PROC tByteWidth07.Set 0 3 0x00100001
+! PROCEDURE Set(VAR r: rec); BEGIN r.x := 4; r.y := 5 END Set;
+CONST 4
+LDLW 12
+STOREC
+CONST 5
+LDLW 12
+CONST 1
+STIC
+RETURN
+END
+
+PROC tByteWidth07.%main 0 3 0
+!   Set(rr);
+GLOBAL tByteWidth07.rec
+GLOBAL tByteWidth07.rr
+GLOBAL tByteWidth07.Set
+CALL 2
+!   Out.Int(rr.y, 0);
+CONST 0
+GLOBAL tByteWidth07.rr
+CONST 1
+LDIC
+GLOBAL Out.Int
+CALL 2
+!   Out.Ln
+GLOBAL Out.Ln
+CALL 0
+RETURN
+END
+
+! Global variables
+GLOVAR tByteWidth07.rr 2
+
+! Descriptor for rec
+DEFINE tByteWidth07.rec
+WORD 0
+WORD 0
+WORD tByteWidth07.rec.%anc
+
+DEFINE tByteWidth07.rec.%anc
+WORD tByteWidth07.rec
+
+! End of file
+]]*)
diff --git a/yacc/Makefile.in b/yacc/Makefile.in
index 2f23f52..a290f52 100644
--- a/yacc/Makefile.in
+++ b/yacc/Makefile.in
@@ -29,8 +29,8 @@
 #
 
 # Config stuff
-OCAMLC = ocamlc
-OCAMLLEX = ocamllex
+OCAMLC = @OCAMLC@
+OCAMLLEX = @OCAMLLEX@
 CAMLDEP = @top_srcdir@/camldep
 MLFLAGS = @MLFLAGS@
 srcdir = @srcdir@
@@ -39,32 +39,36 @@ SHELL = /bin/sh
 DEPEND = @DEPEND@
 EXEEXT = @EXEEXT@
 VPATH = @srcdir@
+LIBDIRS = @LIBDIRS@
 # End of config
 
 all: myacc yyparse.cmo
 
 INCLUDE = -I ../mllib
+ifdef LIBDIRS
+  INCLUDE += -I +str
+endif
 
 COMMON = ../mllib/mllib.cma yyparse.cmo error.cmo table.cmo grammar.cmo \
 	lr0.cmo report.cmo lalr.cmo conflict.cmo compile.cmo output.cmo
 
 bootyacc: $(COMMON) bootlexer.cmo bootyacc.cmo bootmain.cmo
-	ocamlc $(MLFLAGS) str.cma $^ -o $@ 
+	$(OCAMLC) $(MLFLAGS) $(INCLUDE) str.cma $^ -o $@ 
 
 myacc: $(COMMON) lexer.cmo yacc.cmo main.cmo
-	ocamlc $(MLFLAGS) str.cma $^ -o $@ 
+	$(OCAMLC) $(MLFLAGS) $(INCLUDE) str.cma $^ -o $@ 
 
 bootlexer.ml bootmain.ml: boot%: %
 	sed -e 's/Yacc/Bootyacc/g' -e 's/Lexer/Bootlexer/' $< >$@
 
 %.cmo: %.ml
-	ocamlc $(MLFLAGS) $(INCLUDE) -c -o $@ $<
+	$(OCAMLC) $(MLFLAGS) $(INCLUDE) -c -o $@ $<
 
 %.cmi: %.mli
-	ocamlc $(MLFLAGS) $(INCLUDE) -c -o $@ $<
+	$(OCAMLC) $(MLFLAGS) $(INCLUDE) -c -o $@ $<
 
 %.ml: %.mll
-	ocamllex -o $@ $<
+	$(OCAMLLEX) -o $@ $<
 
 %.mli %.ml: %.mly bootyacc
 	./bootyacc $<
